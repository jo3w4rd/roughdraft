<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-MC35ML');</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>Class AsyncOperation
   | Unity Technologies Developer Guide </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class AsyncOperation
   | Unity Technologies Developer Guide ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MC35ML" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="UnityEngine.AsyncOperation">
  
  
  <h1 id="UnityEngine_AsyncOperation" data-uid="UnityEngine.AsyncOperation">Class AsyncOperation
  </h1>
  <div class="markdown level0 summary"><p>Asynchronous operation coroutine.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.object">Object</a></div>
    <div class="level1"><a class="xref" href="UnityEngine.YieldInstruction.html">YieldInstruction</a></div>
    <div class="level2"><span class="xref">AsyncOperation</span></div>
  </div>
      <div class="level3"><a class="xref" href="UnityEngine.AssetBundleCreateRequest.html">AssetBundleCreateRequest</a></div>
      <div class="level3"><a class="xref" href="UnityEngine.AssetBundleRecompressOperation.html">AssetBundleRecompressOperation</a></div>
      <div class="level3"><a class="xref" href="UnityEngine.AssetBundleRequest.html">AssetBundleRequest</a></div>
      <div class="level3"><a class="xref" href="UnityEngine.ResourceRequest.html">ResourceRequest</a></div>
  <h6><strong>Namespace</strong>: <a class="xref" href="UnityEngine.html">UnityEngine</a></h6>
  <!--h6><strong>Assembly</strong>: cs.temp.dll.dll</h6-->
  <h5 id="UnityEngine_AsyncOperation_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class AsyncOperation : YieldInstruction</code></pre>
  </div>
  <h5 id="UnityEngine_AsyncOperation_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>You can <strong>yield</strong> until asynchronous operation continues, or manually check whether it&#39;s done
(::ref::isDone) or progress (::ref::progress).</p>
<p>SA: <a href="xref:UnityEngine.SceneManager.LoadSceneAsync">SceneManager.LoadSceneAsync</a>, <a href="xref:UnityEngine.AssetBundle.LoadAssetAsync">AssetBundle.LoadAssetAsync</a>, <a href="xref:UnityEngine.Resources.LoadAsync">Resources.LoadAsync</a>.</p>
</div>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="UnityEngine_AsyncOperation_allowSceneActivation_" data-uid="UnityEngine.AsyncOperation.allowSceneActivation*"></a>
  <h4 id="UnityEngine_AsyncOperation_allowSceneActivation" data-uid="UnityEngine.AsyncOperation.allowSceneActivation">allowSceneActivation</h4>
  <div class="markdown level1 summary"><p>Allow Scenes to be activated as soon as it is ready.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool allowSceneActivation { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="UnityEngine_AsyncOperation_allowSceneActivation_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When used in combination with LoadLevelAsync &amp; LoadLevelAdditiveAsync it allows you
to delay the actual activation of the Scene. (And unloading of the previous Scene).</p>
<p>When ::ref::allowSceneActivation is set to false then progress is stopped at 0.9.  The ::ref::isDone is then maintained at false.  When ::ref::allowSceneActivation is set to true ::ref::isDone can complete. While ::ref::isDone is false, the <a class="xref" href="UnityEngine.AsyncOperation.html">AsyncOperation</a> queue is stalled. For example, if a LoadSceneAsync.allowSceneActivation is set to false, and another <a class="xref" href="UnityEngine.AsyncOperation.html">AsyncOperation</a> (e.g. <a href="xref:UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync">SceneManagement.SceneManager.UnloadSceneAsync</a> ) is initialized, the last operation will not be called before the first ::ref::allowSceneActivation is set to true.</p>
</div>
  <h5 id="UnityEngine_AsyncOperation_allowSceneActivation_examples">Examples</h5>
  <pre><code>
//This script lets you load a Scene asynchronously. It uses an asyncOperation to calculate the progress and outputs the current progress to Text (could also be used to make progress bars).

//Attach this script to a GameObject
//Create a Button (__Create__&gt;__UI__&gt;__Button__) and a Text GameObject (__Create__&gt;__UI__&gt;__Text__) and attach them both to the Inspector of your GameObject
//In Play Mode, press your Button to load the Scene, and the Text changes depending on progress. Press the space key to activate the Scene.
//__Note:__ The progress may look like it goes straight to 100% if your Scene doesn’t have a lot to load.

using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class AsyncOperationProgressExample : MonoBehaviour
{
    public Text m_Text;
    public Button m_Button;

    void Start()
    {
        //Call the LoadButton() function when the user clicks this Button
        m_Button.onClick.AddListener(LoadButton);
    }

    void LoadButton()
    {
        //Start loading the Scene asynchronously and output the progress bar
        StartCoroutine(LoadScene());
    }

    IEnumerator LoadScene()
    {
        yield return null;

        //Begin to load the Scene you specify
        AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(&quot;Scene3&quot;);
        //Don&#39;t let the Scene activate until you allow it to
        asyncOperation.allowSceneActivation = false;
        Debug.Log(&quot;Pro :&quot; + asyncOperation.progress);
        //When the load is still in progress, output the Text and progress bar
        while (!asyncOperation.isDone)
        {
            //Output the current progress
            m_Text.text = &quot;Loading progress: &quot; + (asyncOperation.progress * 100) + &quot;%&quot;;

            // Check if the load has finished
            if (asyncOperation.progress &gt;= 0.9f)
            {
                //Change the Text to show the Scene is ready
                m_Text.text = &quot;Press the space bar to continue&quot;;
                //Wait to you press the space key to activate the Scene
                if (Input.GetKeyDown(KeyCode.Space))
                    //Activate the Scene
                    asyncOperation.allowSceneActivation = true;
            }

            yield return null;
        }
    }
}
</code></pre>
  
  
  <a id="UnityEngine_AsyncOperation_isDone_" data-uid="UnityEngine.AsyncOperation.isDone*"></a>
  <h4 id="UnityEngine_AsyncOperation_isDone" data-uid="UnityEngine.AsyncOperation.isDone">isDone</h4>
  <div class="markdown level1 summary"><p>Has the operation finished? (RO)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool isDone { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">Boolean</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="UnityEngine_AsyncOperation_isDone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Flipping to true can be delayed.  See ::ref::allowSceneActivation for more details.</p>
<p>SA: ::ref::progress.</p>
</div>
  
  
  <a id="UnityEngine_AsyncOperation_priority_" data-uid="UnityEngine.AsyncOperation.priority*"></a>
  <h4 id="UnityEngine_AsyncOperation_priority" data-uid="UnityEngine.AsyncOperation.priority">priority</h4>
  <div class="markdown level1 summary"><p>Priority lets you tweak in which order async operation calls will be performed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int priority { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">Int32</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="UnityEngine_AsyncOperation_priority_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When multiple asynchronous operations are queued up, the operation with the
higher priority will be executed first. Once an operation has been started on
the background thread, changing the priority will have no effect anymore.</p>
</div>
  
  
  <a id="UnityEngine_AsyncOperation_progress_" data-uid="UnityEngine.AsyncOperation.progress*"></a>
  <h4 id="UnityEngine_AsyncOperation_progress" data-uid="UnityEngine.AsyncOperation.progress">progress</h4>
  <div class="markdown level1 summary"><p>What&#39;s the operation&#39;s progress. (RO)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public float progress { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.single">Single</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="UnityEngine_AsyncOperation_progress_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Return an operation&#39;s progress. (Read Only)
This returns how close the operation is to finishing. The operation is finished when the progress float reaches 1.0 and <a href="xref:UnityEngine.isDone">isDone</a> is called. If you set <a href="xref:UnityEngine.allowSceneActivation">allowSceneActivation</a> to false, progress is halted at 0.9 until it is set to true.  This is extremely useful for creating loading bars.</p>
<p>SA: ::ref::isDone.</p>
</div>
  <h5 id="UnityEngine_AsyncOperation_progress_examples">Examples</h5>
  <pre><code>
//This script lets you load a Scene asynchronously. It uses an asyncOperation to calculate the progress and outputs the current progress to Text (could also be used to make progress bars).

//Attach this script to a GameObject
//Create a Button (__Create__&gt;__UI__&gt;__Button__) and a Text GameObject (__Create__&gt;__UI__&gt;__Text__) and attach them both to the Inspector of your GameObject
//In Play Mode, press your Button to load the Scene, and the Text changes depending on progress. Press the space key to activate the Scene.
//__Note:__ The progress may look like it goes straight to 100% if your Scene doesn’t have a lot to load.

using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class AsyncOperationProgressExample : MonoBehaviour
{
    public Text m_Text;
    public Button m_Button;

    void Start()
    {
        //Call the LoadButton() function when the user clicks this Button
        m_Button.onClick.AddListener(LoadButton);
    }

    void LoadButton()
    {
        //Start loading the Scene asynchronously and output the progress bar
        StartCoroutine(LoadScene());
    }

    IEnumerator LoadScene()
    {
        yield return null;

        //Begin to load the Scene you specify
        AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(&quot;Scene3&quot;);
        //Don&#39;t let the Scene activate until you allow it to
        asyncOperation.allowSceneActivation = false;
        Debug.Log(&quot;Pro :&quot; + asyncOperation.progress);
        //When the load is still in progress, output the Text and progress bar
        while (!asyncOperation.isDone)
        {
            //Output the current progress
            m_Text.text = &quot;Loading progress: &quot; + (asyncOperation.progress * 100) + &quot;%&quot;;

            // Check if the load has finished
            if (asyncOperation.progress &gt;= 0.9f)
            {
                //Change the Text to show the Scene is ready
                m_Text.text = &quot;Press the space bar to continue&quot;;
                //Wait to you press the space key to activate the Scene
                if (Input.GetKeyDown(KeyCode.Space))
                    //Activate the Scene
                    asyncOperation.allowSceneActivation = true;
            }

            yield return null;
        }
    }
}
</code></pre>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="UnityEngine_AsyncOperation_Finalize_" data-uid="UnityEngine.AsyncOperation.Finalize*"></a>
  <h4 id="UnityEngine_AsyncOperation_Finalize" data-uid="UnityEngine.AsyncOperation.Finalize">Finalize()</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected void Finalize()</code></pre>
  </div>
  <h3 id="events">Events
  </h3>
  
  
  <h4 id="UnityEngine_AsyncOperation_completed" data-uid="UnityEngine.AsyncOperation.completed">completed</h4>
  <div class="markdown level1 summary"><p>Event that is invoked upon operation completion.  An event handler that is registered in the same frame as the call that creates it will be invoked next frame, even if the operation is able to complete synchronously.  If a handler is registered after the operation has completed and has already invoked the complete event, the handler will be called synchronously.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event Action&lt;AsyncOperation&gt; completed</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="UnityEngine.AsyncOperation.html">AsyncOperation</a>&gt;</td>
        <td></td>
      </tr>
    </tbody>
  </table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2019 Unity Technologies<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
