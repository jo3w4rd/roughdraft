{
  "api/Global Namespace.AddressablesPlayerBuildProcessor.html": {
    "href": "api/Global Namespace.AddressablesPlayerBuildProcessor.html",
    "title": "Class AddressablesPlayerBuildProcessor | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesPlayerBuildProcessor Maintains Addresssables build data when processing a player build. Inheritance Object AddressablesPlayerBuildProcessor Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Global Namespace <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressablesPlayerBuildProcessor : IPreprocessBuildWithReport, IPostprocessBuildWithReport, IOrderedCallback Properties callbackOrder Returns the player build processor callback order. Declaration public int callbackOrder { get; } Property Value Type Description Int32 Implements IOrderedCallback.callbackOrder Methods OnPostprocessBuild(BuildReport) Removes temporary data created as part of a build. Declaration public void OnPostprocessBuild(BuildReport report) Parameters Type Name Description BuildReport report Implements IPostprocessBuildWithReport.OnPostprocessBuild(BuildReport) OnPreprocessBuild(BuildReport) Initializes temporary build data. Declaration public void OnPreprocessBuild(BuildReport report) Parameters Type Name Description BuildReport report Implements IPreprocessBuildWithReport.OnPreprocessBuild(BuildReport)"
  },
  "api/Global Namespace.html": {
    "href": "api/Global Namespace.html",
    "title": "Namespace Global Namespace | Addressables | 1.17.6-preview",
    "keywords": "Namespace Global Namespace Classes AddressablesPlayerBuildProcessor Maintains Addresssables build data when processing a player build. PackedPlayModeBuildLogs RevertUnchangedAssetsToPreviousAssetState RevertUnchangedAssetsToPreviousAssetState uses the asset state from the previous build to determine if any assets need to use their previous settings or use the newly build data. Structs PackedPlayModeBuildLogs.RuntimeBuildLog A container for build logs that need to be seen at runtime."
  },
  "api/Global Namespace.PackedPlayModeBuildLogs.html": {
    "href": "api/Global Namespace.PackedPlayModeBuildLogs.html",
    "title": "Class PackedPlayModeBuildLogs | Addressables | 1.17.6-preview",
    "keywords": "Class PackedPlayModeBuildLogs Inheritance Object PackedPlayModeBuildLogs Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Global Namespace <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class PackedPlayModeBuildLogs Properties RuntimeBuildLogs List of logs that need to appear in the runtime that was generated by the build. Declaration public List<PackedPlayModeBuildLogs.RuntimeBuildLog> RuntimeBuildLogs { get; set; } Property Value Type Description List < PackedPlayModeBuildLogs.RuntimeBuildLog >"
  },
  "api/Global Namespace.PackedPlayModeBuildLogs.RuntimeBuildLog.html": {
    "href": "api/Global Namespace.PackedPlayModeBuildLogs.RuntimeBuildLog.html",
    "title": "Struct PackedPlayModeBuildLogs.RuntimeBuildLog | Addressables | 1.17.6-preview",
    "keywords": "Struct PackedPlayModeBuildLogs.RuntimeBuildLog A container for build logs that need to be seen at runtime. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Global Namespace <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public struct RuntimeBuildLog Constructors RuntimeBuildLog(LogType, String) Create a container for build logs that need to be seen at runtime. Declaration public RuntimeBuildLog(LogType type, string message) Parameters Type Name Description LogType type The type of log. String message The message to be logged. Fields Message The contents of the build log. Declaration public string Message Field Value Type Description String Type The type of log being stored. This will determine how the message is portrayed at runtime. Declaration public LogType Type Field Value Type Description LogType"
  },
  "api/Global Namespace.RevertUnchangedAssetsToPreviousAssetState.html": {
    "href": "api/Global Namespace.RevertUnchangedAssetsToPreviousAssetState.html",
    "title": "Class RevertUnchangedAssetsToPreviousAssetState | Addressables | 1.17.6-preview",
    "keywords": "Class RevertUnchangedAssetsToPreviousAssetState RevertUnchangedAssetsToPreviousAssetState uses the asset state from the previous build to determine if any assets need to use their previous settings or use the newly build data. Inheritance Object RevertUnchangedAssetsToPreviousAssetState Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Global Namespace <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class RevertUnchangedAssetsToPreviousAssetState Methods Run(IAddressableAssetsBuildContext, ContentUpdateScript.ContentUpdateContext) Reverts asset entries to their previous state if not modified by the new build. Declaration public static ReturnCode Run(IAddressableAssetsBuildContext aaBuildContext, ContentUpdateScript.ContentUpdateContext updateContext) Parameters Type Name Description IAddressableAssetsBuildContext aaBuildContext The new build data. ContentUpdateScript.ContentUpdateContext updateContext The cached build data. Returns Type Description ReturnCode Returns the success ReturnCode if the content update succeeds."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Addressables Script Reference | Addressables | 1.17.6-preview",
    "keywords": "Addressables Script Reference This section of the documentation contains details of the scripting API that Unity provides for the Addressables package. The scripting reference is organised according to the classes available to scripts which are described along with their methods, properties and any other information relevant to their use. API are grouped by namespaces they belong to, and can be selected from the sidebar to the left. You can use the Filter control above the sidebar to filter the table of contents so that it only shows entries containing the string you enter. You can also use the Search control at the top of the window to perform a full-text search of the Addressables documentation."
  },
  "api/UnityEditor.AddressableAssets.AddressableAssetSettingsDefaultObject.html": {
    "href": "api/UnityEditor.AddressableAssets.AddressableAssetSettingsDefaultObject.html",
    "title": "Class AddressableAssetSettingsDefaultObject | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetSettingsDefaultObject Class used to get and set the default Addressable Asset settings object. Inheritance Object Object ScriptableObject AddressableAssetSettingsDefaultObject Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetSettingsDefaultObject : ScriptableObject Fields kDefaultConfigAssetName Default name for the addressable assets settings Declaration public const string kDefaultConfigAssetName = \"AddressableAssetSettings\" Field Value Type Description String kDefaultConfigFolder The default folder for the serialized version of this class. Declaration public const string kDefaultConfigFolder = \"Assets/AddressableAssetsData\" Field Value Type Description String kDefaultConfigObjectName The name of the default config object Declaration public const string kDefaultConfigObjectName = \"com.unity.addressableassets\" Field Value Type Description String Properties DefaultAssetPath Default path for addressable asset settings assets. Declaration public static string DefaultAssetPath { get; } Property Value Type Description String Settings Gets the default addressable asset settings object. This will return null during editor startup if EditorApplication.isUpdating or EditorApplication.isCompiling are true. Declaration public static AddressableAssetSettings Settings { get; set; } Property Value Type Description AddressableAssetSettings SettingsExists Used to determine if a default settings asset exists. Declaration public static bool SettingsExists { get; } Property Value Type Description Boolean Methods GetSettings(Boolean) Gets the settings object with the option to create a new one if it does not exist. Declaration public static AddressableAssetSettings GetSettings(bool create) Parameters Type Name Description Boolean create If true and no settings object exists, a new one will be created using the default config folder and asset name. Returns Type Description AddressableAssetSettings The default settings object."
  },
  "api/UnityEditor.AddressableAssets.Build.AddressableAssetBuildResult.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AddressableAssetBuildResult.html",
    "title": "Class AddressableAssetBuildResult | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetBuildResult Contains information about the status of the build. Inheritance Object AddressableAssetBuildResult AddressablesPlayerBuildResult AddressablesPlayModeBuildResult Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetBuildResult : IDataBuilderResult Properties Duration Duration of build, in seconds. Declaration public double Duration { get; set; } Property Value Type Description Double Implements IDataBuilderResult.Duration Error Error that caused the build to fail. Declaration public string Error { get; set; } Property Value Type Description String Implements IDataBuilderResult.Error FileRegistry Registry of files created during the build Declaration public FileRegistry FileRegistry { get; set; } Property Value Type Description FileRegistry Implements IDataBuilderResult.FileRegistry LocationCount The number of addressable assets contained in the build. Declaration public int LocationCount { get; set; } Property Value Type Description Int32 Implements IDataBuilderResult.LocationCount OutputPath Path of runtime settings file Declaration public string OutputPath { get; set; } Property Value Type Description String Implements IDataBuilderResult.OutputPath Methods CreateResult<TResult>(String, Int32, String) Helper method to create the desired result of a data builder. This should always be used to create the build result with additional details added as needed. The Result.Duration should always be set at the end of the build script in the non-error scenario. Declaration public static TResult CreateResult<TResult>(string settingsPath, int locCount, string err = \"\") where TResult : IDataBuilderResult Parameters Type Name Description String settingsPath Path to the settings.json file (name may not always match that exactly) generated by this build Int32 locCount Number of locations created by this build String err Error string if there were problems with the build. Defaults to empty Returns Type Description TResult Type Parameters Name Description TResult The actual build result created"
  },
  "api/UnityEditor.AddressableAssets.Build.AddressablesContentState.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AddressablesContentState.html",
    "title": "Class AddressablesContentState | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesContentState Data stored with each build that is used to generated content updates. Inheritance Object AddressablesContentState Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressablesContentState Fields cachedBundles Information about asset bundles created for the build. Declaration [SerializeField] public CachedBundleState[] cachedBundles Field Value Type Description CachedBundleState [] cachedInfos Dependency information for all assets in the build that have been marked StaticContent. Declaration [SerializeField] public CachedAssetState[] cachedInfos Field Value Type Description CachedAssetState [] editorVersion The version of the unity editor used to build the player. Declaration [SerializeField] public string editorVersion Field Value Type Description String playerVersion The version that the player was built with. This is usually set to AddressableAssetSettings.PlayerBuildVersion. Declaration [SerializeField] public string playerVersion Field Value Type Description String remoteCatalogLoadPath The path of a remote catalog. This is the only place the player knows to look for an updated catalog. Declaration [SerializeField] public string remoteCatalogLoadPath Field Value Type Description String"
  },
  "api/UnityEditor.AddressableAssets.Build.AddressablesDataBuilderInput.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AddressablesDataBuilderInput.html",
    "title": "Class AddressablesDataBuilderInput | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesDataBuilderInput Data builder context object for Addressables. Inheritance Object AddressablesDataBuilderInput Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressablesDataBuilderInput Constructors AddressablesDataBuilderInput(AddressableAssetSettings) Creates a default context object with values taken from the AddressableAssetSettings parameter. Declaration public AddressablesDataBuilderInput(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings The settings object to pull values from. AddressablesDataBuilderInput(AddressableAssetSettings, String) Creates a default context object with values taken from the AddressableAssetSettings parameter. Declaration public AddressablesDataBuilderInput(AddressableAssetSettings settings, string playerBuildVersion) Parameters Type Name Description AddressableAssetSettings settings The settings object to pull values from. String playerBuildVersion The player build version. Fields RuntimeCatalogFilename The name of the default Runtime Catalog file. Declaration public string RuntimeCatalogFilename Field Value Type Description String RuntimeSettingsFilename The name of the default Runtime Settings file. Declaration public string RuntimeSettingsFilename Field Value Type Description String Properties AddressableSettings The main addressables settings object. Declaration public AddressableAssetSettings AddressableSettings { get; } Property Value Type Description AddressableAssetSettings PlayerVersion Player build version. Declaration public string PlayerVersion { get; } Property Value Type Description String PreviousContentState The asset content state of a previous build. This allows detection of deltas with the current build content state. This will be null in standard builds. This is only set during content update builds. Declaration public AddressablesContentState PreviousContentState { get; } Property Value Type Description AddressablesContentState ProfilerEventsEnabled Bool to signify if profiler events should be broadcast. Declaration public bool ProfilerEventsEnabled { get; } Property Value Type Description Boolean Registry Registry of files created during the build Declaration public FileRegistry Registry { get; } Property Value Type Description FileRegistry Target Build target. Declaration public BuildTarget Target { get; } Property Value Type Description BuildTarget TargetGroup Build target group. Declaration public BuildTargetGroup TargetGroup { get; } Property Value Type Description BuildTargetGroup"
  },
  "api/UnityEditor.AddressableAssets.Build.AddressablesPlayerBuildResult.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AddressablesPlayerBuildResult.html",
    "title": "Class AddressablesPlayerBuildResult | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesPlayerBuildResult Build result for building the player. Inheritance Object AddressableAssetBuildResult AddressablesPlayerBuildResult Inherited Members AddressableAssetBuildResult.Duration AddressableAssetBuildResult.LocationCount AddressableAssetBuildResult.Error AddressableAssetBuildResult.OutputPath AddressableAssetBuildResult.FileRegistry AddressableAssetBuildResult.CreateResult<TResult>(String, Int32, String) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressablesPlayerBuildResult : AddressableAssetBuildResult, IDataBuilderResult"
  },
  "api/UnityEditor.AddressableAssets.Build.AddressablesPlayModeBuildResult.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AddressablesPlayModeBuildResult.html",
    "title": "Class AddressablesPlayModeBuildResult | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesPlayModeBuildResult Build result for entering play mode in the editor. Inheritance Object AddressableAssetBuildResult AddressablesPlayModeBuildResult Inherited Members AddressableAssetBuildResult.Duration AddressableAssetBuildResult.LocationCount AddressableAssetBuildResult.Error AddressableAssetBuildResult.OutputPath AddressableAssetBuildResult.FileRegistry AddressableAssetBuildResult.CreateResult<TResult>(String, Int32, String) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressablesPlayModeBuildResult : AddressableAssetBuildResult, IDataBuilderResult"
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AddressablesAnalyzeResultData.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AddressablesAnalyzeResultData.html",
    "title": "Class AddressablesAnalyzeResultData | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesAnalyzeResultData Represents the data acquired after analyzing Addressable assets. Inheritance Object AddressablesAnalyzeResultData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.AnalyzeRules <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressablesAnalyzeResultData : ISerializationCallbackReceiver Methods OnAfterDeserialize() Retrieves serialized data after a domain reload. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Converts our data to a serialized structure before a domain reload. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize()"
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeResultData.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeResultData.html",
    "title": "Class AnalyzeResultData | Addressables | 1.17.6-preview",
    "keywords": "Class AnalyzeResultData Represents the data acquired after analyzing Addressable assets. Inheritance Object Object ScriptableObject AnalyzeResultData Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.AnalyzeRules <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Obsolete(\"This has been made obsolete and is no longer functional. Analyze result data is handled internally.\")] public class AnalyzeResultData : ScriptableObject, ISerializationCallbackReceiver Methods OnAfterDeserialize() Retrieves serialized data after a domain reload. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Converts our data to a serialized structure before a domain reload. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize()"
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeRule.AnalyzeResult.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeRule.AnalyzeResult.html",
    "title": "Class AnalyzeRule.AnalyzeResult | Addressables | 1.17.6-preview",
    "keywords": "Class AnalyzeRule.AnalyzeResult Result data returned by rules. Inheritance Object AnalyzeRule.AnalyzeResult Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.AnalyzeRules <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AnalyzeResult Properties resultName Name of result data. This name uses AnalyzeRule.kDelimiter to signify breaks in the tree display. Declaration public string resultName { get; set; } Property Value Type Description String severity Severity of rule result Declaration public MessageType severity { get; set; } Property Value Type Description MessageType"
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeRule.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.AnalyzeRule.html",
    "title": "Class AnalyzeRule | Addressables | 1.17.6-preview",
    "keywords": "Class AnalyzeRule Base class for creating rules to analyze Addressables data. Use AnalyzeWindow.RegisterNewRule<T>() to register. a rule with the GUI window. Inheritance Object AnalyzeRule Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.AnalyzeRules <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AnalyzeRule Fields kDelimiter Delimiter character used in analyze rule string names. This is used when a rule result needs to display as a tree view hierarchy. A rule result of A:B:C will end up in the tree view with: A --- B ----- C Declaration public const char kDelimiter = ':' Field Value Type Description Char noErrors Represents a state where no errors were found after analyzing Addressables data. Declaration [NonSerialized] protected AnalyzeRule.AnalyzeResult noErrors Field Value Type Description AnalyzeRule.AnalyzeResult Properties CanFix True if this rule can fix itself. If child class sets this to true, class must override FixIssues Declaration public virtual bool CanFix { get; set; } Property Value Type Description Boolean ruleName Display name for rule Declaration public virtual string ruleName { get; } Property Value Type Description String Methods ClearAnalysis() Clears out the analysis results. When overriding, use to clear rule-specific data as well. Declaration public virtual void ClearAnalysis() FixIssues(AddressableAssetSettings) Fixing method to be run on results of the RefreshAnalysis. If CanFix returns true, this method must be overriden. It is recommended that RefreshAnalysis caches any data that will be needed to fix. Fix should not rerun RefreshAnalysis before fixing. Declaration public virtual void FixIssues(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings The settings object to analyze RefreshAnalysis(AddressableAssetSettings) This method runs the actual analysis for the rule. Declaration public virtual List<AnalyzeRule.AnalyzeResult> RefreshAnalysis(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings The settings object to analyze Returns Type Description List < AnalyzeRule.AnalyzeResult > A list of resulting information (warnings, errors, or info)"
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeRules.html",
    "title": "Namespace UnityEditor.AddressableAssets.Build.AnalyzeRules | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Build.AnalyzeRules Classes AddressablesAnalyzeResultData Represents the data acquired after analyzing Addressable assets. AnalyzeResultData Represents the data acquired after analyzing Addressable assets. AnalyzeRule Base class for creating rules to analyze Addressables data. Use AnalyzeWindow.RegisterNewRule<T>() to register. a rule with the GUI window. AnalyzeRule.AnalyzeResult Result data returned by rules."
  },
  "api/UnityEditor.AddressableAssets.Build.AnalyzeSystem.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AnalyzeSystem.html",
    "title": "Class AnalyzeSystem | Addressables | 1.17.6-preview",
    "keywords": "Class AnalyzeSystem Static system to manage Analyze functionality. Inheritance Object AnalyzeSystem Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public static class AnalyzeSystem Methods RegisterNewRule<TRule>() Method used to register any custom AnalyzeRules with the AnalyzeSystem. This replaces calling into the AnalyzeWindow directly to remove logic from the GUI. The recommended pattern is to create your rules like so: class MyRule : AnalyzeRule {} [InitializeOnLoad] class RegisterMyRule { static RegisterMyRule() { AnalyzeSystem.RegisterNewRule<MyRule>(); } } Declaration public static void RegisterNewRule<TRule>() where TRule : AnalyzeRule, new() Type Parameters Name Description TRule The rule type."
  },
  "api/UnityEditor.AddressableAssets.Build.AssetState.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.AssetState.html",
    "title": "Struct AssetState | Addressables | 1.17.6-preview",
    "keywords": "Struct AssetState The given state of an Asset. Represented by its guid and hash. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public struct AssetState : IEquatable<AssetState> Fields guid Asset states GUID. Declaration public GUID guid Field Value Type Description UnityEditor.GUID hash Asset State hash. Declaration public Hash128 hash Field Value Type Description Hash128 Methods Equals(AssetState) Check if one asset state is equal to another. Declaration public bool Equals(AssetState other) Parameters Type Name Description AssetState other Right hand side of comparision. Returns Type Description Boolean Returns true if the Asset States are equal to one another. Implements IEquatable<T>.Equals(T)"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.AddHashToBundleNameTask.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.AddHashToBundleNameTask.html",
    "title": "Class AddHashToBundleNameTask | Addressables | 1.17.6-preview",
    "keywords": "Class AddHashToBundleNameTask The BuildTask used to append the asset hash to the internal bundle name. Inheritance Object AddHashToBundleNameTask Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.BuildPipelineTasks <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddHashToBundleNameTask : IBuildTask Properties Version The task version. Declaration public int Version { get; } Property Value Type Description Int32 Implements IBuildTask.Version Methods Run() Runs the AddHashToBundleNameTask. Declaration public ReturnCode Run() Returns Type Description ReturnCode Success. Implements IBuildTask.Run()"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.BuildLayoutGenerationTask.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.BuildLayoutGenerationTask.html",
    "title": "Class BuildLayoutGenerationTask | Addressables | 1.17.6-preview",
    "keywords": "Class BuildLayoutGenerationTask The BuildTask used to generate the bundle layout. Inheritance Object BuildLayoutGenerationTask Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.BuildPipelineTasks <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class BuildLayoutGenerationTask : IBuildTask Properties BundleNameRemap The mapping of the old to new bundle names. Declaration public Dictionary<string, string> BundleNameRemap { get; } Property Value Type Description Dictionary < String , String > Version The GenerateLocationListsTask version. Declaration public int Version { get; } Property Value Type Description Int32 Implements IBuildTask.Version Methods Run() Runs the build task with the injected context. Declaration public ReturnCode Run() Returns Type Description ReturnCode The success or failure ReturnCode Implements IBuildTask.Run()"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.ExtractDataTask.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.ExtractDataTask.html",
    "title": "Class ExtractDataTask | Addressables | 1.17.6-preview",
    "keywords": "Class ExtractDataTask The BuildTask used to extract write data from the build. Inheritance Object ExtractDataTask Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.BuildPipelineTasks <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ExtractDataTask : IBuildTask Properties BuildCache Get the injected build cache of the task. Declaration public IBuildCache BuildCache { get; } Property Value Type Description IBuildCache BuildContext The build context of the task. Declaration public IBuildContext BuildContext { get; } Property Value Type Description IBuildContext DependencyData Get the injected dependency data of the task. Declaration public IDependencyData DependencyData { get; } Property Value Type Description IDependencyData Version The ExtractDataTask version. Declaration public int Version { get; } Property Value Type Description Int32 Implements IBuildTask.Version WriteData Get the injected write data of the task. Declaration public IBundleWriteData WriteData { get; } Property Value Type Description IBundleWriteData Methods Run() Runs the ExtractDataTask. The data for this task is all injected context so no operations are performed in the Run step. Declaration public ReturnCode Run() Returns Type Description ReturnCode Success. Implements IBuildTask.Run()"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.GenerateLocationListsTask.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.GenerateLocationListsTask.html",
    "title": "Class GenerateLocationListsTask | Addressables | 1.17.6-preview",
    "keywords": "Class GenerateLocationListsTask The BuildTask used to create location lists for Addressable assets. Inheritance Object GenerateLocationListsTask Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.BuildPipelineTasks <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class GenerateLocationListsTask : IBuildTask Properties Version The GenerateLocationListsTask version. Declaration public int Version { get; } Property Value Type Description Int32 Implements IBuildTask.Version Methods Run() Runs the build task with the injected context. Declaration public ReturnCode Run() Returns Type Description ReturnCode The success or failure ReturnCode Implements IBuildTask.Run() Run(IAddressableAssetsBuildContext, IBundleWriteData) Runs the build task with a give context and write data. Declaration [Obsolete(\"This method uses nonoptimized code. Use nonstatic version Run() instead.\")] public static ReturnCode Run(IAddressableAssetsBuildContext aaBuildContext, IBundleWriteData writeData) Parameters Type Name Description IAddressableAssetsBuildContext aaBuildContext The addressables build context. IBundleWriteData writeData The write data used to generate the location lists. Returns Type Description ReturnCode The success or failure ReturnCode"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildPipelineTasks.html",
    "title": "Namespace UnityEditor.AddressableAssets.Build.BuildPipelineTasks | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Build.BuildPipelineTasks Classes AddHashToBundleNameTask The BuildTask used to append the asset hash to the internal bundle name. BuildLayoutGenerationTask The BuildTask used to generate the bundle layout. ExtractDataTask The BuildTask used to extract write data from the build. GenerateLocationListsTask The BuildTask used to create location lists for Addressable assets."
  },
  "api/UnityEditor.AddressableAssets.Build.BuildScript.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildScript.html",
    "title": "Class BuildScript | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScript Entry point to set callbacks for builds. Inheritance Object BuildScript Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public static class BuildScript Fields buildCompleted Global delegate for handling the result of AddressableAssets builds. This will get called for player builds and when entering play mode. Declaration public static Action<AddressableAssetBuildResult> buildCompleted Field Value Type Description Action < AddressableAssetBuildResult >"
  },
  "api/UnityEditor.AddressableAssets.Build.BuildUtility.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.BuildUtility.html",
    "title": "Class BuildUtility | Addressables | 1.17.6-preview",
    "keywords": "Class BuildUtility Utility class for the Addressables Build Content process. Inheritance Object BuildUtility Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class BuildUtility Methods CheckModifiedScenesAndAskToSave() Used during the build to check for unsaved scenes and provide a user popup if there are any. Declaration public static bool CheckModifiedScenesAndAskToSave() Returns Type Description Boolean True if there were no unsaved scenes, or if user hits \"Save and Continue\" on popup. False if any scenes were unsaved, and user hits \"Cancel\" on popup. GetNameWithHashNaming(BundledAssetGroupSchema.BundleNamingStyle, String, String) Creates a new bundle name using its hash and a given naming style. Declaration public static string GetNameWithHashNaming(BundledAssetGroupSchema.BundleNamingStyle schemaBundleNaming, string hash, string sourceBundleName) Parameters Type Name Description BundledAssetGroupSchema.BundleNamingStyle schemaBundleNaming The bundle naming style. String hash The bundle hash. String sourceBundleName The original bundle name. Returns Type Description String Returns the new bundle name. IsEditorAssembly(Assembly) Determines if the given assembly is an editor assembly. Declaration public static bool IsEditorAssembly(Assembly assembly) Parameters Type Name Description Assembly assembly The assembly. Returns Type Description Boolean Returns true if the assembly is an editor assembly. Returns false otherwise."
  },
  "api/UnityEditor.AddressableAssets.Build.CachedAssetState.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.CachedAssetState.html",
    "title": "Class CachedAssetState | Addressables | 1.17.6-preview",
    "keywords": "Class CachedAssetState The Cached Asset State of an Addressable Asset. Inheritance Object CachedAssetState Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class CachedAssetState : IEquatable<CachedAssetState> Fields asset The Asset State. Declaration public AssetState asset Field Value Type Description AssetState bundleFileId The name of the cached asset states bundle file. Declaration public string bundleFileId Field Value Type Description String data The cached asset state data. Declaration public object data Field Value Type Description Object dependencies The Asset State of all dependencies. Declaration public AssetState[] dependencies Field Value Type Description AssetState [] groupGuid The guid for the group the cached asset state belongs to. Declaration public string groupGuid Field Value Type Description String Methods Equals(CachedAssetState) Checks if one cached asset state is equal to another given the asset state and dependency state. Declaration public bool Equals(CachedAssetState other) Parameters Type Name Description CachedAssetState other Right hand side of comparision. Returns Type Description Boolean Returns true if the cached asset states are equal to one another. Implements IEquatable<T>.Equals(T)"
  },
  "api/UnityEditor.AddressableAssets.Build.CachedBundleState.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.CachedBundleState.html",
    "title": "Class CachedBundleState | Addressables | 1.17.6-preview",
    "keywords": "Class CachedBundleState Cached state of asset bundles. Inheritance Object CachedBundleState Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class CachedBundleState Fields bundleFileId The name of the cached asset states bundle file. Declaration public string bundleFileId Field Value Type Description String data The cached bundle state data. Declaration public object data Field Value Type Description Object"
  },
  "api/UnityEditor.AddressableAssets.Build.ContentUpdateScript.ContentUpdateContext.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.ContentUpdateScript.ContentUpdateContext.html",
    "title": "Struct ContentUpdateScript.ContentUpdateContext | Addressables | 1.17.6-preview",
    "keywords": "Struct ContentUpdateScript.ContentUpdateContext Contains build information used for updating assets. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct ContentUpdateContext Fields BundleToInternalBundleIdMap The mapping of a bundle's name to its internal bundle id. Declaration public Dictionary<string, string> BundleToInternalBundleIdMap Field Value Type Description Dictionary < String , String > ContentState Stores the cached build data. Declaration public AddressablesContentState ContentState Field Value Type Description AddressablesContentState GuidToPreviousAssetStateMap The mapping of an asset's guid to its cached asset state. Declaration public Dictionary<string, CachedAssetState> GuidToPreviousAssetStateMap Field Value Type Description Dictionary < String , CachedAssetState > IdToCatalogDataEntryMap The mapping of an asset's or bundle's internal id to its catalog entry. Declaration public Dictionary<string, ContentCatalogDataEntry> IdToCatalogDataEntryMap Field Value Type Description Dictionary < String , ContentCatalogDataEntry > PreviousAssetStateCarryOver The list of asset state information gathered from the previous build. Declaration public List<CachedAssetState> PreviousAssetStateCarryOver Field Value Type Description List < CachedAssetState > Registry Stores the paths of the files created during a build. Declaration public FileRegistry Registry Field Value Type Description FileRegistry WriteData Stores the asset bundle write information. Declaration public IBundleWriteData WriteData Field Value Type Description IBundleWriteData"
  },
  "api/UnityEditor.AddressableAssets.Build.ContentUpdateScript.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.ContentUpdateScript.html",
    "title": "Class ContentUpdateScript | Addressables | 1.17.6-preview",
    "keywords": "Class ContentUpdateScript Contains methods used for the content update workflow. Inheritance Object ContentUpdateScript Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public static class ContentUpdateScript Methods BuildContentUpdate(AddressableAssetSettings, String) Builds player content using the player content version from a specified cache file. Declaration public static AddressablesPlayerBuildResult BuildContentUpdate(AddressableAssetSettings settings, string contentStateDataPath) Parameters Type Name Description AddressableAssetSettings settings The settings object to use for the build. String contentStateDataPath The path of the cache data to use. Returns Type Description AddressablesPlayerBuildResult The build operation. CreateContentUpdateGroup(AddressableAssetSettings, List<AddressableAssetEntry>, String) Create a new AddressableAssetGroup with the items and mark it as remote. Declaration public static void CreateContentUpdateGroup(AddressableAssetSettings settings, List<AddressableAssetEntry> items, string groupName) Parameters Type Name Description AddressableAssetSettings settings The settings object. List < AddressableAssetEntry > items The items to move. String groupName The name of the new group. GatherModifiedEntries(AddressableAssetSettings, String) Get all modified addressable asset entries in groups that have BundledAssetGroupSchema and ContentUpdateGroupSchema with static content enabled. This includes any Addressable dependencies that are affected by the modified entries. Declaration public static List<AddressableAssetEntry> GatherModifiedEntries(AddressableAssetSettings settings, string cacheDataPath) Parameters Type Name Description AddressableAssetSettings settings Addressable asset settings. String cacheDataPath The cache data path. Returns Type Description List < AddressableAssetEntry > A list of all modified entries and dependencies (list is empty if there are none); null if failed to load cache data. GatherModifiedEntriesWithDependencies(AddressableAssetSettings, String) Get a Dictionary of all modified values and their dependencies. Dependencies will be Addressable and part of a group with static content enabled. Declaration public static Dictionary<AddressableAssetEntry, List<AddressableAssetEntry>> GatherModifiedEntriesWithDependencies(AddressableAssetSettings settings, string cachePath) Parameters Type Name Description AddressableAssetSettings settings Addressable asset settings. String cachePath The cache data path. Returns Type Description Dictionary < AddressableAssetEntry , List < AddressableAssetEntry >> A dictionary mapping explicit changed entries to their dependencies. GetContentStateDataPath(Boolean) Gets the path of the cache data from a selected build. Declaration public static string GetContentStateDataPath(bool browse) Parameters Type Name Description Boolean browse If true, the user is allowed to browse for a specific file. Returns Type Description String LoadContentState(String) Loads cache data from a specific location Declaration public static AddressablesContentState LoadContentState(string contentStateDataPath) Parameters Type Name Description String contentStateDataPath Returns Type Description AddressablesContentState The ContentState object. SaveContentState(List<ContentCatalogDataEntry>, String, List<AddressableAssetEntry>, IDependencyData, String, String) Save the content update information for a set of AddressableAssetEntry objects. Declaration public static bool SaveContentState(List<ContentCatalogDataEntry> locations, string path, List<AddressableAssetEntry> entries, IDependencyData dependencyData, string playerVersion, string remoteCatalogPath) Parameters Type Name Description List < ContentCatalogDataEntry > locations The ContentCatalogDataEntry locations that were built into the Content Catalog. String path File to write content stat info to. If file already exists, it will be deleted before the new file is created. List < AddressableAssetEntry > entries The entries to save. IDependencyData dependencyData The raw dependency information generated from the build. String playerVersion The player version to save. This is usually set to AddressableAssetSettings.PlayerBuildVersion. String remoteCatalogPath The server path (if any) that contains an updateable content catalog. If this is empty, updates cannot occur. Returns Type Description Boolean True if the file is saved, false otherwise. SaveContentState(List<ContentCatalogDataEntry>, String, List<AddressableAssetEntry>, IDependencyData, String, String, List<CachedAssetState>) Save the content update information for a set of AddressableAssetEntry objects. Declaration public static bool SaveContentState(List<ContentCatalogDataEntry> locations, string path, List<AddressableAssetEntry> entries, IDependencyData dependencyData, string playerVersion, string remoteCatalogPath, List<CachedAssetState> carryOverCacheState) Parameters Type Name Description List < ContentCatalogDataEntry > locations The ContentCatalogDataEntry locations that were built into the Content Catalog. String path File to write content stat info to. If file already exists, it will be deleted before the new file is created. List < AddressableAssetEntry > entries The entries to save. IDependencyData dependencyData The raw dependency information generated from the build. String playerVersion The player version to save. This is usually set to AddressableAssetSettings.PlayerBuildVersion. String remoteCatalogPath The server path (if any) that contains an updateable content catalog. If this is empty, updates cannot occur. List < CachedAssetState > carryOverCacheState Cached state that needs to carry over from the previous build. This mainly affects Content Update. Returns Type Description Boolean True if the file is saved, false otherwise. SaveContentState(String, List<AddressableAssetEntry>, IDependencyData, String, String) Save the content update information for a set of AddressableAssetEntry objects. Declaration [Obsolete] public static bool SaveContentState(string path, List<AddressableAssetEntry> entries, IDependencyData dependencyData, string playerVersion, string remoteCatalogPath) Parameters Type Name Description String path File to write content stat info to. If file already exists, it will be deleted before the new file is created. List < AddressableAssetEntry > entries The entries to save. IDependencyData dependencyData The raw dependency information generated from the build. String playerVersion The player version to save. This is usually set to AddressableAssetSettings.PlayerBuildVersion. String remoteCatalogPath The server path (if any) that contains an updateable content catalog. If this is empty, updates cannot occur. Returns Type Description Boolean True if the file is saved, false otherwise."
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.AddressableAssetsBuildContext.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.AddressableAssetsBuildContext.html",
    "title": "Class AddressableAssetsBuildContext | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetsBuildContext Simple context object for passing data through SBP, between different sections of Addressables code. Inheritance Object AddressableAssetsBuildContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetsBuildContext : IAddressableAssetsBuildContext, IContextObject Fields assetEntries The list of all AddressableAssetEntry objects. Declaration public List<AddressableAssetEntry> assetEntries Field Value Type Description List < AddressableAssetEntry > assetGroupToBundles Mapping of asset group to bundles. Declaration public Dictionary<AddressableAssetGroup, List<string>> assetGroupToBundles Field Value Type Description Dictionary < AddressableAssetGroup , List < String >> bundleToAssetGroup Mapping of bundles to asset groups. Declaration public Dictionary<string, string> bundleToAssetGroup Field Value Type Description Dictionary < String , String > locations The list of catalog locations. Declaration public List<ContentCatalogDataEntry> locations Field Value Type Description List < ContentCatalogDataEntry > providerTypes Set of provider types needed in this build. Declaration public HashSet<Type> providerTypes Field Value Type Description HashSet < Type > runtimeData The current runtime data being built. Declaration public ResourceManagerRuntimeData runtimeData Field Value Type Description ResourceManagerRuntimeData settings The settings object to use. Declaration [Obsolete(\"Use Settings property instead.\")] public AddressableAssetSettings settings Field Value Type Description AddressableAssetSettings Properties Settings The settings object to use. Declaration public AddressableAssetSettings Settings { get; set; } Property Value Type Description AddressableAssetSettings"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.AddressableAssetsBundleBuildParameters.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.AddressableAssetsBundleBuildParameters.html",
    "title": "Class AddressableAssetsBundleBuildParameters | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetsBundleBuildParameters Custom bundle parameter container that provides custom compression settings per bundle. Inheritance Object BuildParameters BundleBuildParameters AddressableAssetsBundleBuildParameters Inherited Members BundleBuildParameters.AppendHash BundleBuildParameters.ContiguousBundles BuildParameters.GetContentBuildSettings() BuildParameters.GetScriptCompilationSettings() BuildParameters.GetOutputFilePathForIdentifier(String) BuildParameters.Target BuildParameters.Group BuildParameters.ContentBuildFlags BuildParameters.ScriptInfo BuildParameters.ScriptOptions BuildParameters.BundleCompression BuildParameters.OutputFolder BuildParameters.TempOutputFolder BuildParameters.ScriptOutputFolder BuildParameters.UseCache BuildParameters.CacheServerHost BuildParameters.CacheServerPort BuildParameters.WriteLinkXML Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetsBundleBuildParameters : BundleBuildParameters, IBundleBuildParameters, IBuildParameters, IContextObject Constructors AddressableAssetsBundleBuildParameters(AddressableAssetSettings, Dictionary<String, String>, BuildTarget, BuildTargetGroup, String) Create a AddressableAssetsBundleBuildParameters with data needed to determine the correct compression per bundle. Declaration public AddressableAssetsBundleBuildParameters(AddressableAssetSettings aaSettings, Dictionary<string, string> bundleToAssetGroup, BuildTarget target, BuildTargetGroup group, string outputFolder) Parameters Type Name Description AddressableAssetSettings aaSettings The AddressableAssetSettings object to use for retrieving groups. Dictionary < String , String > bundleToAssetGroup Mapping of bundle identifier to guid of asset groups. BuildTarget target The build target. This is used by the BundleBuildParameters base class. BuildTargetGroup group The build target group. This is used by the BundleBuildParameters base class. String outputFolder The path for the output folder. This is used by the BundleBuildParameters base class. Methods GetCompressionForIdentifier(String) Get the compressions settings for the specified asset bundle. Declaration public override BuildCompression GetCompressionForIdentifier(string identifier) Parameters Type Name Description String identifier The identifier of the asset bundle. Returns Type Description BuildCompression The compression setting for the asset group. If the group is not found, the default compression is used. Overrides BuildParameters.GetCompressionForIdentifier(String)"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptBase.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptBase.html",
    "title": "Class BuildScriptBase | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScriptBase Base class for build script assets Inheritance Object Object ScriptableObject BuildScriptBase BuildScriptFastMode BuildScriptPackedMode BuildScriptPackedPlayMode BuildScriptVirtualMode Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class BuildScriptBase : ScriptableObject, IDataBuilder Fields instanceProviderType The type of instance provider to create for the Addressables system. Declaration [FormerlySerializedAs(\"m_InstanceProviderType\")] public SerializedType instanceProviderType Field Value Type Description SerializedType sceneProviderType The type of scene provider to create for the addressables system. Declaration [FormerlySerializedAs(\"m_SceneProviderType\")] public SerializedType sceneProviderType Field Value Type Description SerializedType Properties Log Stores the logged information of all the build tasks. Declaration public IBuildLogger Log { get; } Property Value Type Description IBuildLogger Name The descriptive name used in the UI. Declaration public virtual string Name { get; } Property Value Type Description String Implements IDataBuilder.Name Methods BuildData<TResult>(AddressablesDataBuilderInput) Build the specified data with the provided builderInput. This is the public entry point. Child class overrides should use BuildDataImplementation<TResult>(AddressablesDataBuilderInput) Declaration public TResult BuildData<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build. Returns Type Description TResult The build data result. Type Parameters Name Description TResult The type of data to build. Implements IDataBuilder.BuildData<TResult>(AddressablesDataBuilderInput) BuildDataImplementation<TResult>(AddressablesDataBuilderInput) The implementation of BuildData<TResult>(AddressablesDataBuilderInput) . That is the public entry point, this is the home for child class overrides. Declaration protected virtual TResult BuildDataImplementation<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build Returns Type Description TResult The build data result Type Parameters Name Description TResult The type of data to build CanBuildData<T>() Used to determine if this builder is capable of building a specific type of data. Declaration public virtual bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if this builder can build this data. Type Parameters Name Description T The type of data needed to be built. Implements IDataBuilder.CanBuildData<T>() ClearCachedData() Used to clean up any cached data created by this builder. Declaration public virtual void ClearCachedData() Implements IDataBuilder.ClearCachedData() CreateLocationsForPlayerData(PlayerDataGroupSchema, AddressableAssetGroup, List<ContentCatalogDataEntry>, HashSet<Type>) Utility method for creating locations from player data. Declaration protected bool CreateLocationsForPlayerData(PlayerDataGroupSchema playerDataSchema, AddressableAssetGroup assetGroup, List<ContentCatalogDataEntry> locations, HashSet<Type> providerTypes) Parameters Type Name Description PlayerDataGroupSchema playerDataSchema The schema for the group. AddressableAssetGroup assetGroup The group to extract the locations from. List < ContentCatalogDataEntry > locations The list of created locations to fill in. HashSet < Type > providerTypes Any unknown provider types are added to this set in order to ensure they are not stripped. Returns Type Description Boolean True if any legacy locations were created. This is used by the build scripts to determine if a legacy provider is needed. DeleteFile(String) Utility method for deleting files. Declaration protected static void DeleteFile(string path) Parameters Type Name Description String path The file path to delete. IsDataBuilt() Checks to see if the data is built for the given builder. Declaration public virtual bool IsDataBuilt() Returns Type Description Boolean Returns true if the data is built. Returns false otherwise. ProcessAllGroups(AddressableAssetsBuildContext) Loops over each group, after doing some data checking. Declaration protected virtual string ProcessAllGroups(AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetsBuildContext aaContext The Addressables builderInput object to base the group processing on Returns Type Description String An error string if there were any problems processing the groups ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) Build processing of an individual group. Declaration protected virtual string ProcessGroup(AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetGroup assetGroup The group to process AddressableAssetsBuildContext aaContext The Addressables builderInput object to base the group processing on Returns Type Description String An error string if there were any problems processing the groups WriteFile(String, String, FileRegistry) Utility method to write a file. The directory will be created if it does not exist. Declaration protected static bool WriteFile(string path, string content, FileRegistry registry) Parameters Type Name Description String path The path of the file to write. String content The content of the file. FileRegistry registry The file registry used to track all produced artifacts. Returns Type Description Boolean True if the file was written."
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptFastMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptFastMode.html",
    "title": "Class BuildScriptFastMode | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScriptFastMode Only saves the guid of the settings asset to PlayerPrefs. All catalog data is generated directly from the settings as needed. Inheritance Object Object ScriptableObject BuildScriptBase BuildScriptFastMode Inherited Members BuildScriptBase.instanceProviderType BuildScriptBase.sceneProviderType BuildScriptBase.Log BuildScriptBase.BuildData<TResult>(AddressablesDataBuilderInput) BuildScriptBase.ProcessAllGroups(AddressableAssetsBuildContext) BuildScriptBase.CreateLocationsForPlayerData(PlayerDataGroupSchema, AddressableAssetGroup, List<ContentCatalogDataEntry>, HashSet<Type>) BuildScriptBase.DeleteFile(String) BuildScriptBase.WriteFile(String, String, FileRegistry) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"BuildScriptFastMode.asset\", menuName = \"Addressables/Content Builders/Use Asset Database (fastest)\")] public class BuildScriptFastMode : BuildScriptBase, IDataBuilder Properties Name The descriptive name used in the UI. Declaration public override string Name { get; } Property Value Type Description String Overrides BuildScriptBase.Name Methods BuildDataImplementation<TResult>(AddressablesDataBuilderInput) The implementation of BuildData<TResult>(AddressablesDataBuilderInput) . That is the public entry point, this is the home for child class overrides. Declaration protected override TResult BuildDataImplementation<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build Returns Type Description TResult The build data result Type Parameters Name Description TResult The type of data to build Overrides BuildScriptBase.BuildDataImplementation<TResult>(AddressablesDataBuilderInput) CanBuildData<T>() Used to determine if this builder is capable of building a specific type of data. Declaration public override bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if this builder can build this data. Type Parameters Name Description T The type of data needed to be built. Overrides BuildScriptBase.CanBuildData<T>() ClearCachedData() Used to clean up any cached data created by this builder. Declaration public override void ClearCachedData() Overrides BuildScriptBase.ClearCachedData() IsDataBuilt() Checks to see if the data is built for the given builder. Declaration public override bool IsDataBuilt() Returns Type Description Boolean Returns true if the data is built. Returns false otherwise. Overrides BuildScriptBase.IsDataBuilt() ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) Build processing of an individual group. Declaration protected override string ProcessGroup(AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetGroup assetGroup The group to process AddressableAssetsBuildContext aaContext The Addressables builderInput object to base the group processing on Returns Type Description String An error string if there were any problems processing the groups Overrides BuildScriptBase.ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext)"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptPackedMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptPackedMode.html",
    "title": "Class BuildScriptPackedMode | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScriptPackedMode Build scripts used for player builds and running with bundles in the editor. Inheritance Object Object ScriptableObject BuildScriptBase BuildScriptPackedMode Inherited Members BuildScriptBase.instanceProviderType BuildScriptBase.sceneProviderType BuildScriptBase.Log BuildScriptBase.BuildData<TResult>(AddressablesDataBuilderInput) BuildScriptBase.ProcessAllGroups(AddressableAssetsBuildContext) BuildScriptBase.CreateLocationsForPlayerData(PlayerDataGroupSchema, AddressableAssetGroup, List<ContentCatalogDataEntry>, HashSet<Type>) BuildScriptBase.DeleteFile(String) BuildScriptBase.WriteFile(String, String, FileRegistry) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"BuildScriptPacked.asset\", menuName = \"Addressables/Content Builders/Default Build Script\")] public class BuildScriptPackedMode : BuildScriptBase, IDataBuilder Properties Name The descriptive name used in the UI. Declaration public override string Name { get; } Property Value Type Description String Overrides BuildScriptBase.Name Methods BuildDataImplementation<TResult>(AddressablesDataBuilderInput) The implementation of BuildData<TResult>(AddressablesDataBuilderInput) . That is the public entry point, this is the home for child class overrides. Declaration protected override TResult BuildDataImplementation<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build Returns Type Description TResult The build data result Type Parameters Name Description TResult The type of data to build Overrides BuildScriptBase.BuildDataImplementation<TResult>(AddressablesDataBuilderInput) CanBuildData<T>() Used to determine if this builder is capable of building a specific type of data. Declaration public override bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if this builder can build this data. Type Parameters Name Description T The type of data needed to be built. Overrides BuildScriptBase.CanBuildData<T>() ClearCachedData() Used to clean up any cached data created by this builder. Declaration public override void ClearCachedData() Overrides BuildScriptBase.ClearCachedData() ConstructAssetBundleName(AddressableAssetGroup, BundledAssetGroupSchema, BundleDetails, String) Creates a name for an asset bundle using the provided information. Declaration protected virtual string ConstructAssetBundleName(AddressableAssetGroup assetGroup, BundledAssetGroupSchema schema, BundleDetails info, string assetBundleName) Parameters Type Name Description AddressableAssetGroup assetGroup The asset group. BundledAssetGroupSchema schema The schema of the group. BundleDetails info The bundle information. String assetBundleName The base name of the asset bundle. Returns Type Description String Returns the asset bundle name with the provided information. DoBuild<TResult>(AddressablesDataBuilderInput, AddressableAssetsBuildContext) The method that does the actual building after all the groups have been processed. Declaration protected virtual TResult DoBuild<TResult>(AddressablesDataBuilderInput builderInput, AddressableAssetsBuildContext aaContext) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The generic builderInput of the AddressableAssetsBuildContext aaContext Returns Type Description TResult Type Parameters Name Description TResult IsDataBuilt() Checks to see if the data is built for the given builder. Declaration public override bool IsDataBuilt() Returns Type Description Boolean Returns true if the data is built. Returns false otherwise. Overrides BuildScriptBase.IsDataBuilt() ProcessBundledAssetSchema(BundledAssetGroupSchema, AddressableAssetGroup, AddressableAssetsBuildContext) The processing of the bundled asset schema. This is where the bundle(s) for a given group are actually setup. Declaration protected virtual string ProcessBundledAssetSchema(BundledAssetGroupSchema schema, AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description BundledAssetGroupSchema schema The BundledAssetGroupSchema to process AddressableAssetGroup assetGroup The group this schema was pulled from AddressableAssetsBuildContext aaContext The general Addressables build builderInput Returns Type Description String The error string, if any. ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) Build processing of an individual group. Declaration protected override string ProcessGroup(AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetGroup assetGroup The group to process AddressableAssetsBuildContext aaContext The Addressables builderInput object to base the group processing on Returns Type Description String An error string if there were any problems processing the groups Overrides BuildScriptBase.ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) ProcessGroupSchema(AddressableAssetGroupSchema, AddressableAssetGroup, AddressableAssetsBuildContext) Called per group per schema to evaluate that schema. This can be an easy entry point for implementing the build aspects surrounding a custom schema. Note, you should not rely on schemas getting called in a specific order. Declaration protected virtual string ProcessGroupSchema(AddressableAssetGroupSchema schema, AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetGroupSchema schema The schema to process AddressableAssetGroup assetGroup The group this schema was pulled from AddressableAssetsBuildContext aaContext The general Addressables build builderInput Returns Type Description String"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptPackedPlayMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptPackedPlayMode.html",
    "title": "Class BuildScriptPackedPlayMode | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScriptPackedPlayMode Uses data built by BuildScriptPacked class. This script just sets up the correct variables and runs. Inheritance Object Object ScriptableObject BuildScriptBase BuildScriptPackedPlayMode Inherited Members BuildScriptBase.instanceProviderType BuildScriptBase.sceneProviderType BuildScriptBase.Log BuildScriptBase.BuildData<TResult>(AddressablesDataBuilderInput) BuildScriptBase.ProcessAllGroups(AddressableAssetsBuildContext) BuildScriptBase.ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) BuildScriptBase.CreateLocationsForPlayerData(PlayerDataGroupSchema, AddressableAssetGroup, List<ContentCatalogDataEntry>, HashSet<Type>) BuildScriptBase.DeleteFile(String) BuildScriptBase.WriteFile(String, String, FileRegistry) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"BuildScriptPackedPlayMode.asset\", menuName = \"Addressables/Content Builders/Use Existing Build (requires built groups)\")] public class BuildScriptPackedPlayMode : BuildScriptBase, IDataBuilder Properties Name The descriptive name used in the UI. Declaration public override string Name { get; } Property Value Type Description String Overrides BuildScriptBase.Name Methods BuildDataImplementation<TResult>(AddressablesDataBuilderInput) The implementation of BuildData<TResult>(AddressablesDataBuilderInput) . That is the public entry point, this is the home for child class overrides. Declaration protected override TResult BuildDataImplementation<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build Returns Type Description TResult The build data result Type Parameters Name Description TResult The type of data to build Overrides BuildScriptBase.BuildDataImplementation<TResult>(AddressablesDataBuilderInput) CanBuildData<T>() Used to determine if this builder is capable of building a specific type of data. Declaration public override bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if this builder can build this data. Type Parameters Name Description T The type of data needed to be built. Overrides BuildScriptBase.CanBuildData<T>() ClearCachedData() Used to clean up any cached data created by this builder. Declaration public override void ClearCachedData() Overrides BuildScriptBase.ClearCachedData() IsDataBuilt() Checks to see if the data is built for the given builder. Declaration public override bool IsDataBuilt() Returns Type Description Boolean Returns true if the data is built. Returns false otherwise. Overrides BuildScriptBase.IsDataBuilt()"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptVirtualMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.BuildScriptVirtualMode.html",
    "title": "Class BuildScriptVirtualMode | Addressables | 1.17.6-preview",
    "keywords": "Class BuildScriptVirtualMode Build script for creating virtual asset bundle dat for running in the editor. Inheritance Object Object ScriptableObject BuildScriptBase BuildScriptVirtualMode Inherited Members BuildScriptBase.instanceProviderType BuildScriptBase.sceneProviderType BuildScriptBase.Log BuildScriptBase.BuildData<TResult>(AddressablesDataBuilderInput) BuildScriptBase.ProcessAllGroups(AddressableAssetsBuildContext) BuildScriptBase.CreateLocationsForPlayerData(PlayerDataGroupSchema, AddressableAssetGroup, List<ContentCatalogDataEntry>, HashSet<Type>) BuildScriptBase.DeleteFile(String) BuildScriptBase.WriteFile(String, String, FileRegistry) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"BuildScriptVirtual.asset\", menuName = \"Addressables/Content Builders/Simulate Groups (advanced)\")] public class BuildScriptVirtualMode : BuildScriptBase, IDataBuilder Properties Name The descriptive name used in the UI. Declaration public override string Name { get; } Property Value Type Description String Overrides BuildScriptBase.Name Methods BuildDataImplementation<TResult>(AddressablesDataBuilderInput) The implementation of BuildData<TResult>(AddressablesDataBuilderInput) . That is the public entry point, this is the home for child class overrides. Declaration protected override TResult BuildDataImplementation<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput object used in the build Returns Type Description TResult The build data result Type Parameters Name Description TResult The type of data to build Overrides BuildScriptBase.BuildDataImplementation<TResult>(AddressablesDataBuilderInput) CanBuildData<T>() Used to determine if this builder is capable of building a specific type of data. Declaration public override bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if this builder can build this data. Type Parameters Name Description T The type of data needed to be built. Overrides BuildScriptBase.CanBuildData<T>() ClearCachedData() Used to clean up any cached data created by this builder. Declaration public override void ClearCachedData() Overrides BuildScriptBase.ClearCachedData() IsDataBuilt() Checks to see if the data is built for the given builder. Declaration public override bool IsDataBuilt() Returns Type Description Boolean Returns true if the data is built. Returns false otherwise. Overrides BuildScriptBase.IsDataBuilt() ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext) Build processing of an individual group. Declaration protected override string ProcessGroup(AddressableAssetGroup assetGroup, AddressableAssetsBuildContext aaContext) Parameters Type Name Description AddressableAssetGroup assetGroup The group to process AddressableAssetsBuildContext aaContext The Addressables builderInput object to base the group processing on Returns Type Description String An error string if there were any problems processing the groups Overrides BuildScriptBase.ProcessGroup(AddressableAssetGroup, AddressableAssetsBuildContext)"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.html",
    "title": "Namespace UnityEditor.AddressableAssets.Build.DataBuilders | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Build.DataBuilders Classes AddressableAssetsBuildContext Simple context object for passing data through SBP, between different sections of Addressables code. AddressableAssetsBundleBuildParameters Custom bundle parameter container that provides custom compression settings per bundle. BuildScriptBase Base class for build script assets BuildScriptFastMode Only saves the guid of the settings asset to PlayerPrefs. All catalog data is generated directly from the settings as needed. BuildScriptPackedMode Build scripts used for player builds and running with bundles in the editor. BuildScriptPackedPlayMode Uses data built by BuildScriptPacked class. This script just sets up the correct variables and runs. BuildScriptVirtualMode Build script for creating virtual asset bundle dat for running in the editor. Interfaces IAddressableAssetsBuildContext Interface for any Addressables specific context objects to be used in the Scriptable Build Pipeline context store"
  },
  "api/UnityEditor.AddressableAssets.Build.DataBuilders.IAddressableAssetsBuildContext.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.DataBuilders.IAddressableAssetsBuildContext.html",
    "title": "Interface IAddressableAssetsBuildContext | Addressables | 1.17.6-preview",
    "keywords": "Interface IAddressableAssetsBuildContext Interface for any Addressables specific context objects to be used in the Scriptable Build Pipeline context store Namespace : UnityEditor.AddressableAssets.Build.DataBuilders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IAddressableAssetsBuildContext : IContextObject"
  },
  "api/UnityEditor.AddressableAssets.Build.FileRegistry.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.FileRegistry.html",
    "title": "Class FileRegistry | Addressables | 1.17.6-preview",
    "keywords": "Class FileRegistry Use to contain files created during a build. Inheritance Object FileRegistry Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class FileRegistry Constructors FileRegistry() Initializes a new file registry instance. Declaration public FileRegistry() Methods AddFile(String) Adds a file path to our set of file paths. Declaration public void AddFile(string path) Parameters Type Name Description String path The file path. GetFilePathForBundle(String) Given a bundle name, determine the file path for the bundle. Declaration public string GetFilePathForBundle(string bundleName) Parameters Type Name Description String bundleName The name of the bundle. Returns Type Description String The full file path. GetFilePaths() Retrieves all the stored file paths. Declaration public IEnumerable<string> GetFilePaths() Returns Type Description IEnumerable < String > Returns all file paths as an IEnumerable. RemoveFile(String) Removes a file path from our set of file paths. Declaration public void RemoveFile(string path) Parameters Type Name Description String path The file path. ReplaceBundleEntry(String, String) Replace an entry in the File Registry with a new bundle name. Declaration public bool ReplaceBundleEntry(string bundleName, string newFileRegistryEntry) Parameters Type Name Description String bundleName The bundle name to replace. String newFileRegistryEntry The new file registry bundle name. Returns Type Description Boolean Returns true if a successful replacement occured."
  },
  "api/UnityEditor.AddressableAssets.Build.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.html",
    "title": "Namespace UnityEditor.AddressableAssets.Build | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Build Classes AddressableAssetBuildResult Contains information about the status of the build. AddressablesContentState Data stored with each build that is used to generated content updates. AddressablesDataBuilderInput Data builder context object for Addressables. AddressablesPlayerBuildResult Build result for building the player. AddressablesPlayModeBuildResult Build result for entering play mode in the editor. AnalyzeSystem Static system to manage Analyze functionality. BuildScript Entry point to set callbacks for builds. BuildUtility Utility class for the Addressables Build Content process. CachedAssetState The Cached Asset State of an Addressable Asset. CachedBundleState Cached state of asset bundles. ContentUpdateScript Contains methods used for the content update workflow. FileRegistry Use to contain files created during a build. LinkXmlGenerator This can be used to create a LinkXml for your build. This will ensure that the desired runtime types are packed into the build. SceneManagerState Serializable object that can be used to save and restore the state of the editor scene manager. Structs AssetState The given state of an Asset. Represented by its guid and hash. ContentUpdateScript.ContentUpdateContext Contains build information used for updating assets. Interfaces IDataBuilder Builds objects of type IDataBuilderResult. IDataBuilderResult The result of IDataBuilder.Build. Enums ShaderBundleNaming"
  },
  "api/UnityEditor.AddressableAssets.Build.IDataBuilder.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.IDataBuilder.html",
    "title": "Interface IDataBuilder | Addressables | 1.17.6-preview",
    "keywords": "Interface IDataBuilder Builds objects of type IDataBuilderResult. Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IDataBuilder Properties Name The name of the builder, used for GUI. Declaration string Name { get; } Property Value Type Description String Methods BuildData<TResult>(AddressablesDataBuilderInput) Build the data of a specific type. Declaration TResult BuildData<TResult>(AddressablesDataBuilderInput builderInput) where TResult : IDataBuilderResult Parameters Type Name Description AddressablesDataBuilderInput builderInput The builderInput used to build the data. Returns Type Description TResult The built data. Type Parameters Name Description TResult The data type. CanBuildData<T>() Can this builder build the type of data requested. Declaration bool CanBuildData<T>() where T : IDataBuilderResult Returns Type Description Boolean True if the build can build it. Type Parameters Name Description T The data type. ClearCachedData() Clears all cached data. Declaration void ClearCachedData()"
  },
  "api/UnityEditor.AddressableAssets.Build.IDataBuilderResult.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.IDataBuilderResult.html",
    "title": "Interface IDataBuilderResult | Addressables | 1.17.6-preview",
    "keywords": "Interface IDataBuilderResult The result of IDataBuilder.Build. Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IDataBuilderResult Properties Duration Duration of the build in seconds. Declaration double Duration { get; set; } Property Value Type Description Double Error Error string, if any. If Succeeded is true, this may be null. Declaration string Error { get; set; } Property Value Type Description String FileRegistry Registry of files created during the build Declaration FileRegistry FileRegistry { get; set; } Property Value Type Description FileRegistry LocationCount The number of addressable assets contained in the build. Declaration int LocationCount { get; set; } Property Value Type Description Int32 OutputPath Path of runtime settings file Declaration string OutputPath { get; set; } Property Value Type Description String"
  },
  "api/UnityEditor.AddressableAssets.Build.LinkXmlGenerator.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.LinkXmlGenerator.html",
    "title": "Class LinkXmlGenerator | Addressables | 1.17.6-preview",
    "keywords": "Class LinkXmlGenerator This can be used to create a LinkXml for your build. This will ensure that the desired runtime types are packed into the build. Inheritance Object LinkXmlGenerator LinkXmlGenerator Inherited Members LinkXmlGenerator.serializedClassesPerAssembly LinkXmlGenerator.CreateDefault() LinkXmlGenerator.GetEditorTypeConversions() LinkXmlGenerator.AddAssemblies(Assembly[]) LinkXmlGenerator.AddAssemblies(IEnumerable<Assembly>) LinkXmlGenerator.AddSerializedClass(IEnumerable<String>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Obsolete(\"UnityEditor.AddressableAssets.Build.LinkXmlGenerator is obsolete. Use UnityEditor.Build.Pipeline.Utilities.LinkXmlGenerator instead.\")] public class LinkXmlGenerator : LinkXmlGenerator Methods AddTypes(IEnumerable<Type>) Declaration public void AddTypes(IEnumerable<Type> types) Parameters Type Name Description IEnumerable < Type > types AddTypes(Type[]) Declaration public void AddTypes(params Type[] types) Parameters Type Name Description Type [] types Save(String) Declaration public void Save(string path) Parameters Type Name Description String path SetTypeConversion(Type, Type) Declaration public void SetTypeConversion(Type a, Type b) Parameters Type Name Description Type a Type b"
  },
  "api/UnityEditor.AddressableAssets.Build.SceneManagerState.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.SceneManagerState.html",
    "title": "Class SceneManagerState | Addressables | 1.17.6-preview",
    "keywords": "Class SceneManagerState Serializable object that can be used to save and restore the state of the editor scene manager. Inheritance Object SceneManagerState Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class SceneManagerState Methods AddScenesForPlayMode(List<EditorBuildSettingsScene>) Adds a set of scenes to the scene list for use in editor play mode. Declaration public static void AddScenesForPlayMode(List<EditorBuildSettingsScene> playModeScenes) Parameters Type Name Description List < EditorBuildSettingsScene > playModeScenes The scenes to add to the editor scenes list. Record(String) Record the state of the EditorSceneManager and save to a JSON file. Declaration public static void Record(string path = \"\") Parameters Type Name Description String path The path to save the recorded state. Restore(String, Boolean) Restore the state of the EditorSceneManager. Declaration public static void Restore(string path = \"\", bool restoreSceneManagerSetup = false) Parameters Type Name Description String path The path to load the state data from. This file is generated by calling SceneManagerState.Record. Boolean restoreSceneManagerSetup If true, the recorded active scenes are restored. EditorBuildSettings.scenes are always restored."
  },
  "api/UnityEditor.AddressableAssets.Build.ShaderBundleNaming.html": {
    "href": "api/UnityEditor.AddressableAssets.Build.ShaderBundleNaming.html",
    "title": "Enum ShaderBundleNaming | Addressables | 1.17.6-preview",
    "keywords": "Enum ShaderBundleNaming Namespace : UnityEditor.AddressableAssets.Build <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum ShaderBundleNaming Fields Name Description Value ProjectName 0 DefaultGroupGuid 1 Custom 2"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.BaseHostingService.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.BaseHostingService.html",
    "title": "Class BaseHostingService | Addressables | 1.17.6-preview",
    "keywords": "Class BaseHostingService Base class for hosting services. Inheritance Object BaseHostingService HttpHostingService Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public abstract class BaseHostingService : IHostingService Properties DescriptiveName Set by the HostingServicesManager, primarily used to disambiguate multiple instances of the same service in the GUI. Declaration public virtual string DescriptiveName { get; set; } Property Value Type Description String Implements IHostingService.DescriptiveName HostingServiceContentRoots List of content roots for hosting service. Declaration public abstract List<string> HostingServiceContentRoots { get; } Property Value Type Description List < String > Implements IHostingService.HostingServiceContentRoots InstanceId uniquely identifies this service within the scope of the HostingServicesManager Declaration public virtual int InstanceId { get; set; } Property Value Type Description Int32 Implements IHostingService.InstanceId IsHostingServiceRunning Gets the current running status of the hosting service. Declaration public abstract bool IsHostingServiceRunning { get; } Property Value Type Description Boolean Implements IHostingService.IsHostingServiceRunning Logger Get and set the logger for the hosting service. Declaration public ILogger Logger { get; set; } Property Value Type Description ILogger Implements IHostingService.Logger ProfileVariables Dictionary of profile variables defined by the hosting service. Declaration public abstract Dictionary<string, string> ProfileVariables { get; } Property Value Type Description Dictionary < String , String > Implements IHostingService.ProfileVariables Methods DisambiguateProfileVar(String) Decodes a profile variable lookup ID based on string key Declaration protected virtual string DisambiguateProfileVar(string key) Parameters Type Name Description String key the key to look up Returns Type Description String The variable lookup ID. EvaluateProfileString(String) Expand special variables from Addressable profiles Declaration public virtual string EvaluateProfileString(string key) Parameters Type Name Description String key Key name to match Returns Type Description String replacement string value for key, or null if no match Implements IHostingService.EvaluateProfileString(String) Log(String, Object[]) Logs an info severity formatted message to the Logger specifically on this service. Logger Declaration protected void Log(string format, params object[] args) Parameters Type Name Description String format The base string Object [] args The parameters to be formatted into the base string LogError(String, Object[]) Logs an error severity formatted message to the Logger specifically on this service. Logger Declaration protected void LogError(string format, params object[] args) Parameters Type Name Description String format The base string Object [] args The parameters to be formatted into the base string LogFormat(LogType, String, Object[]) Logs a formatted message to the Logger specifically on this service. Logger Declaration protected void LogFormat(LogType logType, string format, object[] args) Parameters Type Name Description LogType logType Severity of the log String format The base string Object [] args The parameters to be formatted into the base string LogWarning(String, Object[]) Logs an warning severity formatted message to the Logger specifically on this service. Logger Declaration protected void LogWarning(string format, params object[] args) Parameters Type Name Description String format The base string Object [] args The parameters to be formatted into the base string OnAfterDeserialize(KeyDataStore) Called immediatley following a domain reload by the HostingServicesManager, for restoring state information after the service is recreated. Declaration public virtual void OnAfterDeserialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in restoring state information Implements IHostingService.OnAfterDeserialize(KeyDataStore) OnBeforeSerialize(KeyDataStore) Called by the HostingServicesManager before a domain reload, giving the hosting service an opportunity to persist state information. Declaration public virtual void OnBeforeSerialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in persisting state information Implements IHostingService.OnBeforeSerialize(KeyDataStore) OnGUI() Render the hosting service GUI. Declaration public abstract void OnGUI() Implements IHostingService.OnGUI() StartHostingService() Starts the hosting service. Declaration public abstract void StartHostingService() Implements IHostingService.StartHostingService() StopHostingService() Stops the hosting service. Declaration public abstract void StopHostingService() Implements IHostingService.StopHostingService()"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.HostingServicesManager.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.HostingServicesManager.html",
    "title": "Class HostingServicesManager | Addressables | 1.17.6-preview",
    "keywords": "Class HostingServicesManager Manages the hosting services. Inheritance Object HostingServicesManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class HostingServicesManager : ISerializationCallbackReceiver Constructors HostingServicesManager() Create a new HostingServicesManager Declaration public HostingServicesManager() Properties GlobalProfileVariables Key/Value pairs valid for profile variable substitution Declaration public Dictionary<string, string> GlobalProfileVariables { get; } Property Value Type Description Dictionary < String , String > HostingServices Return an enumerable list of all configured IHostingService objects Declaration public ICollection<IHostingService> HostingServices { get; } Property Value Type Description ICollection < IHostingService > IsInitialized Indicates whether or not this HostingServiceManager is initialized Declaration public bool IsInitialized { get; } Property Value Type Description Boolean Logger Direct logging output of all managed services Declaration public ILogger Logger { get; set; } Property Value Type Description ILogger NextInstanceId The id value that will be assigned to the next IHostingService add to the manager. Declaration public int NextInstanceId { get; } Property Value Type Description Int32 RegisteredServiceTypes Get an array of all IHostingService types that have been used by the manager, or are known built-in types available for use. Declaration public Type[] RegisteredServiceTypes { get; } Property Value Type Description Type [] Methods AddHostingService(Type, String) Add a new hosting service instance of the given type. The serviceType must implement the IHostingService interface, or an ArgumentException is thrown. Declaration public IHostingService AddHostingService(Type serviceType, string name) Parameters Type Name Description Type serviceType A Type object for the service. Must implement IHostingService String name A descriptive name for the new service instance. Returns Type Description IHostingService BatchMode() Static method for use in starting up the HostingServicesManager in batch mode. This method without parameters will find and use the default AddressableAssetSettings object. Declaration public static void BatchMode() BatchMode(AddressableAssetSettings) Static method for use in starting up the HostingServicesManager in batch mode. Declaration public static void BatchMode(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings Initialize(AddressableAssetSettings) Initialize manager with the given AddressableAssetSettings object. Declaration public void Initialize(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings OnAfterDeserialize() Ensure object is ready for serialization, and calls OnBeforeSerialize(KeyDataStore) methods on all managed IHostingService instances Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Ensure object is ready for serialization, and calls OnBeforeSerialize(KeyDataStore) methods on all managed IHostingService instances Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize() OnDisable() Should be called by parent ScriptableObject instance OnDisable method Declaration public void OnDisable() OnEnable() Should be called by parent ScriptableObject instance OnEnable method Declaration public void OnEnable() RefreshGlobalProfileVariables() Refresh values in the global profile variables table. Declaration public void RefreshGlobalProfileVariables() RemoveHostingService(IHostingService) Stops the given IHostingService , unregisters callbacks, and removes it from management. This function does nothing if the service is not being managed by this HostingServicesManager Declaration public void RemoveHostingService(IHostingService svc) Parameters Type Name Description IHostingService svc StartAllServices() Calls StartHostingService() on all managed IHostingService instances where IsHostingServiceRunning is false Declaration public void StartAllServices() StopAllServices() Calls StopHostingService() on all managed IHostingService instances where IsHostingServiceRunning is true Declaration public void StopAllServices()"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.html",
    "title": "Namespace UnityEditor.AddressableAssets.HostingServices | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.HostingServices Classes BaseHostingService Base class for hosting services. HostingServicesManager Manages the hosting services. HttpHostingService HTTP implementation of hosting service. Interfaces IHostingService IHostingService implementations serve Addressable content from the Unity Editor to players running locally or on devices with network access to the Editor. IHostingServiceConfigurationProvider Interface for providing configuration data for IHostingService implementations Enums HttpHostingService.ResultCode Options for standard Http result codes"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.HttpHostingService.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.HttpHostingService.html",
    "title": "Class HttpHostingService | Addressables | 1.17.6-preview",
    "keywords": "Class HttpHostingService HTTP implementation of hosting service. Inheritance Object BaseHostingService HttpHostingService Inherited Members BaseHostingService.Logger BaseHostingService.DisambiguateProfileVar(String) BaseHostingService.DescriptiveName BaseHostingService.InstanceId BaseHostingService.EvaluateProfileString(String) BaseHostingService.LogFormat(LogType, String, Object[]) BaseHostingService.Log(String, Object[]) BaseHostingService.LogWarning(String, Object[]) BaseHostingService.LogError(String, Object[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class HttpHostingService : BaseHostingService, IHostingService Constructors HttpHostingService() Create a new HttpHostingService Declaration public HttpHostingService() Properties HostingServiceContentRoots List of content roots for hosting service. Declaration public override List<string> HostingServiceContentRoots { get; } Property Value Type Description List < String > Overrides BaseHostingService.HostingServiceContentRoots HostingServicePort The port number on which the service is listening Declaration public int HostingServicePort { get; protected set; } Property Value Type Description Int32 IsHostingServiceRunning Gets the current running status of the hosting service. Declaration public override bool IsHostingServiceRunning { get; } Property Value Type Description Boolean Overrides BaseHostingService.IsHostingServiceRunning MyHttpListener The actual Http listener used by this service Declaration protected HttpListener MyHttpListener { get; set; } Property Value Type Description HttpListener ProfileVariables Dictionary of profile variables defined by the hosting service. Declaration public override Dictionary<string, string> ProfileVariables { get; } Property Value Type Description Dictionary < String , String > Overrides BaseHostingService.ProfileVariables Methods ConfigureHttpListener() Handles any configuration necessary for MyHttpListener before listening for connections. Declaration protected virtual void ConfigureHttpListener() FindFileInContentRoots(String) Searches for the given relative path within the configured content root directores. Declaration protected virtual string FindFileInContentRoots(string relativePath) Parameters Type Name Description String relativePath Returns Type Description String The full system path to the file if found, or null if file could not be found GetAvailablePort() Find an open network listen port on the local system Declaration protected static int GetAvailablePort() Returns Type Description Int32 a system assigned port, or 0 if none are available HandleRequest(IAsyncResult) Asynchronous callback to handle a client connection request on MyHttpListener . This method is recursive in that it will call itself immediately after receiving a new incoming request to listen for the next connection. Declaration protected virtual void HandleRequest(IAsyncResult ar) Parameters Type Name Description IAsyncResult ar Asynchronous result from previous request. Pass null to listen for an initial request Exceptions Type Condition ArgumentOutOfRangeException thrown when the request result code is unknown IsPortAvailable(Int32) Tests to see if the given port # is already in use Declaration protected static bool IsPortAvailable(int port) Parameters Type Name Description Int32 port port number to test Returns Type Description Boolean true if there is not a listener on the port OnAfterDeserialize(KeyDataStore) Called immediatley following a domain reload by the HostingServicesManager, for restoring state information after the service is recreated. Declaration public override void OnAfterDeserialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in restoring state information Overrides BaseHostingService.OnAfterDeserialize(KeyDataStore) OnBeforeSerialize(KeyDataStore) Called by the HostingServicesManager before a domain reload, giving the hosting service an opportunity to persist state information. Declaration public override void OnBeforeSerialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in persisting state information Overrides BaseHostingService.OnBeforeSerialize(KeyDataStore) OnGUI() Render the hosting service GUI. Declaration public override void OnGUI() Overrides BaseHostingService.OnGUI() ResetListenPort(Int32) Listen on a new port then next time the server starts. If the server is already running, it will be stopped and restarted automatically. Declaration public void ResetListenPort(int port = 0) Parameters Type Name Description Int32 port Specify a port to listen on. Default is 0 to choose any open port Return404(HttpListenerContext) Sets the status code to 404 on the given HttpListenerContext object. Declaration protected virtual void Return404(HttpListenerContext context) Parameters Type Name Description HttpListenerContext context The object to modify. ReturnFile(HttpListenerContext, String, Int32) Sends a file to the connected HTTP client Declaration protected virtual void ReturnFile(HttpListenerContext context, string filePath, int readBufferSize = 65536) Parameters Type Name Description HttpListenerContext context String filePath Int32 readBufferSize StartHostingService() Starts the hosting service. Declaration public override void StartHostingService() Overrides BaseHostingService.StartHostingService() StopHostingService() Stops the hosting service. Declaration public override void StopHostingService() Overrides BaseHostingService.StopHostingService()"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.HttpHostingService.ResultCode.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.HttpHostingService.ResultCode.html",
    "title": "Enum HttpHostingService.ResultCode | Addressables | 1.17.6-preview",
    "keywords": "Enum HttpHostingService.ResultCode Options for standard Http result codes Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax protected enum ResultCode Fields Name Description Value Ok Use to indicate that the request succeeded. 200 NotFound Use to indicate that the requested resource could not be found. 404"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.IHostingService.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.IHostingService.html",
    "title": "Interface IHostingService | Addressables | 1.17.6-preview",
    "keywords": "Interface IHostingService IHostingService implementations serve Addressable content from the Unity Editor to players running locally or on devices with network access to the Editor. Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IHostingService Properties DescriptiveName Set by the HostingServicesManager, primarily used to disambiguate multiple instances of the same service in the GUI. Declaration string DescriptiveName { get; set; } Property Value Type Description String HostingServiceContentRoots Get the list of root directories being served by this hosting service Declaration List<string> HostingServiceContentRoots { get; } Property Value Type Description List < String > InstanceId uniquely identifies this service within the scope of the HostingServicesManager Declaration int InstanceId { get; set; } Property Value Type Description Int32 IsHostingServiceRunning Get a boolean that indicates if this hosting service is running Declaration bool IsHostingServiceRunning { get; } Property Value Type Description Boolean Logger The ILogger instance to use for debug log output Declaration ILogger Logger { get; set; } Property Value Type Description ILogger ProfileVariables Get a map of all profile variables and their current values Declaration Dictionary<string, string> ProfileVariables { get; } Property Value Type Description Dictionary < String , String > Methods EvaluateProfileString(String) Expand special variables from Addressable profiles Declaration string EvaluateProfileString(string key) Parameters Type Name Description String key Key name to match Returns Type Description String replacement string value for key, or null if no match OnAfterDeserialize(KeyDataStore) Called immediatley following a domain reload by the HostingServicesManager, for restoring state information after the service is recreated. Declaration void OnAfterDeserialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in restoring state information OnBeforeSerialize(KeyDataStore) Called by the HostingServicesManager before a domain reload, giving the hosting service an opportunity to persist state information. Declaration void OnBeforeSerialize(KeyDataStore dataStore) Parameters Type Name Description KeyDataStore dataStore A key/value pair data store for use in persisting state information OnGUI() Draw configuration GUI elements Declaration void OnGUI() StartHostingService() Start the hosting service Declaration void StartHostingService() StopHostingService() Stop the hosting service Declaration void StopHostingService()"
  },
  "api/UnityEditor.AddressableAssets.HostingServices.IHostingServiceConfigurationProvider.html": {
    "href": "api/UnityEditor.AddressableAssets.HostingServices.IHostingServiceConfigurationProvider.html",
    "title": "Interface IHostingServiceConfigurationProvider | Addressables | 1.17.6-preview",
    "keywords": "Interface IHostingServiceConfigurationProvider Interface for providing configuration data for IHostingService implementations Namespace : UnityEditor.AddressableAssets.HostingServices <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IHostingServiceConfigurationProvider Properties HostingServicesContentRoot Returns the Hosting Service content root path for the given AddressableAssetGroup Declaration string HostingServicesContentRoot { get; } Property Value Type Description String"
  },
  "api/UnityEditor.AddressableAssets.html": {
    "href": "api/UnityEditor.AddressableAssets.html",
    "title": "Namespace UnityEditor.AddressableAssets | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets Classes AddressableAssetSettingsDefaultObject Class used to get and set the default Addressable Asset settings object."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetBuildSettings.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetBuildSettings.html",
    "title": "Class AddressableAssetBuildSettings | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetBuildSettings Build settings for addressables. Inheritance Object AddressableAssetBuildSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetBuildSettings Properties bundleBuildPath //Specifies where to build asset bundles, this is usually a temporary folder (or a folder in the project). Bundles are copied out of this location to their final destination. Declaration public string bundleBuildPath { get; set; } Property Value Type Description String cleanupStreamingAssetsAfterBuilds Controls whether to remove temporary files after each build. When disabled, build times in packed mode are faster, but may not reflect all changes in assets. Declaration public bool cleanupStreamingAssetsAfterBuilds { get; set; } Property Value Type Description Boolean compileScriptsInVirtualMode Controls whether to compile scripts when running in virtual mode. When disabled, build times are faster but the simulated bundle contents may not be accurate due to including editor code. Declaration public bool compileScriptsInVirtualMode { get; set; } Property Value Type Description Boolean LogResourceManagerExceptions When enabled, the Addressables.ResourceManager.ExceptionHandler is set to (op, ex) => Debug.LogException(ex); Declaration public bool LogResourceManagerExceptions { get; set; } Property Value Type Description Boolean"
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetEntry.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetEntry.html",
    "title": "Class AddressableAssetEntry | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetEntry Contains data for an addressable asset entry. Inheritance Object AddressableAssetEntry Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetEntry : ISerializationCallbackReceiver, IReferenceEntryData Properties address The address of the entry. This is treated as the primary key in the ResourceManager system. Declaration public string address { get; set; } Property Value Type Description String AssetPath The path of the asset. Declaration public string AssetPath { get; } Property Value Type Description String BundleFileId The id for the bundle file. Declaration public string BundleFileId { get; set; } Property Value Type Description String guid The asset guid. Declaration public string guid { get; } Property Value Type Description String IsInResources Is the asset in a resource folder. Declaration public bool IsInResources { get; set; } Property Value Type Description Boolean IsInSceneList Is scene in scene list. Declaration public bool IsInSceneList { get; set; } Property Value Type Description Boolean IsScene Is this entry for a scene. Declaration public bool IsScene { get; } Property Value Type Description Boolean IsSubAsset Is a sub asset. For example an asset in an addressable folder. Declaration public bool IsSubAsset { get; set; } Property Value Type Description Boolean labels The set of labels for this entry. There is no inherent limit to the number of labels. Declaration public HashSet<string> labels { get; } Property Value Type Description HashSet < String > MainAsset The main asset object for this entry. Declaration public Object MainAsset { get; } Property Value Type Description Object ParentEntry Stores a reference to the parent entry. Only used if the asset is a sub asset. Declaration public AddressableAssetEntry ParentEntry { get; set; } Property Value Type Description AddressableAssetEntry parentGroup The asset group that this entry belongs to. An entry can only belong to a single group at a time. Declaration public AddressableAssetGroup parentGroup { get; set; } Property Value Type Description AddressableAssetGroup ReadOnly Read only state of the entry. Declaration public bool ReadOnly { get; set; } Property Value Type Description Boolean TargetAsset The asset object for this entry. Declaration public Object TargetAsset { get; } Property Value Type Description Object Methods CreateCatalogEntries(List<ContentCatalogDataEntry>, Boolean, String, IEnumerable<Object>, Object, HashSet<Type>) Create all entries for this addressable asset. This will expand subassets (Sprites, Meshes, etc) and also different representations. Declaration public void CreateCatalogEntries(List<ContentCatalogDataEntry> entries, bool isBundled, string providerType, IEnumerable<object> dependencies, object extraData, HashSet<Type> providerTypes) Parameters Type Name Description List < ContentCatalogDataEntry > entries The list of entries to fill in. Boolean isBundled Whether the entry is bundles or not. This will affect the load path. String providerType The provider type for the main entry. IEnumerable < Object > dependencies Keys of dependencies Object extraData Extra data to append to catalog entries. HashSet < Type > providerTypes Any unknown provider types are added to this set in order to ensure they are not stripped. CreateKeyList() Creates a list of keys that can be used to load this entry. Declaration public List<object> CreateKeyList() Returns Type Description List < Object > The list of keys. This will contain the address, the guid as a Hash128 if valid, all assigned labels, and the scene index if applicable. GatherAllAssets(List<AddressableAssetEntry>, Boolean, Boolean, Boolean, Func<AddressableAssetEntry, Boolean>) Gathers all asset entries. Each explicit entry may contain multiple sub entries. For example, addressable folders create entries for each asset contained within. Declaration public void GatherAllAssets(List<AddressableAssetEntry> assets, bool includeSelf, bool recurseAll, bool includeSubObjects, Func<AddressableAssetEntry, bool> entryFilter = null) Parameters Type Name Description List < AddressableAssetEntry > assets The generated list of entries. For simple entries, this will contain just the entry itself if specified. Boolean includeSelf Determines if the entry should be contained in the result list or just sub entries. Boolean recurseAll Determines if full recursion should be done when gathering entries. Boolean includeSubObjects Determines if sub objects such as sprites should be included. Func < AddressableAssetEntry , Boolean > entryFilter Optional predicate to run against each entry, only returning those that pass. A null filter will return all entries GetAssetLoadPath(Boolean) The asset load path. This is used to determine the internal id of resource locations. Declaration public string GetAssetLoadPath(bool isBundled) Parameters Type Name Description Boolean isBundled True if the asset will be contained in an asset bundle. Returns Type Description String Return the runtime path that should be used to load this entry. GetAssetLoadPath(Boolean, HashSet<String>) The asset load path. This is used to determine the internal id of resource locations. Declaration public string GetAssetLoadPath(bool isBundled, HashSet<string> otherLoadPaths) Parameters Type Name Description Boolean isBundled True if the asset will be contained in an asset bundle. HashSet < String > otherLoadPaths The internal ids of the asset, typically shortened versions of the asset's GUID. Returns Type Description String Return the runtime path that should be used to load this entry. OnAfterDeserialize() Implementation of ISerializationCallbackReceiver. Converts data from serializable form after deserialization. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Implementation of ISerializationCallbackReceiver. Converts data to serializable form before serialization. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize() SetAddress(String, Boolean) Set the address of the entry. Declaration public void SetAddress(string addr, bool postEvent = true) Parameters Type Name Description String addr The address. Boolean postEvent Post modification event. SetLabel(String, Boolean, Boolean, Boolean) Set or unset a label on this entry. Declaration public bool SetLabel(string label, bool enable, bool force = false, bool postEvent = true) Parameters Type Name Description String label The label name. Boolean enable Setting to true will add the label, false will remove it. Boolean force When enable is true, setting force to true will force the label to exist on the parent AddressableAssetSettings object if it does not already. Boolean postEvent Post modification event. Returns Type Description Boolean ToString() Returns the address of the AddressableAssetEntry. Declaration public override string ToString() Returns Type Description String The address of the AddressableAssetEntry Overrides Object.ToString()"
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetEntryCollection.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetEntryCollection.html",
    "title": "Class AddressableAssetEntryCollection | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetEntryCollection Contains a list of AddressableAssetEntries that can be included in the settings. The purpose of this class is to provide a way of combining entries from external sources such as packages into your project settings. Inheritance Object Object ScriptableObject AddressableAssetEntryCollection Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetEntryCollection : ScriptableObject Properties Entries The collection of entries. Declaration public List<AddressableAssetEntry> Entries { get; } Property Value Type Description List < AddressableAssetEntry >"
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroup.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroup.html",
    "title": "Class AddressableAssetGroup | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetGroup Contains the collection of asset entries associated with this group. Inheritance Object Object ScriptableObject AddressableAssetGroup Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetGroup : ScriptableObject, IComparer<AddressableAssetEntry>, ISerializationCallbackReceiver Properties Default Is the default group. Declaration public virtual bool Default { get; } Property Value Type Description Boolean entries The collection of asset entries. Declaration public virtual ICollection<AddressableAssetEntry> entries { get; } Property Value Type Description ICollection < AddressableAssetEntry > Guid The group GUID. Declaration public virtual string Guid { get; } Property Value Type Description String Name The group name. Declaration public virtual string Name { get; set; } Property Value Type Description String ReadOnly Is this group read only. This is normally false. Built in resources (resource folders and the scene list) are put into a special read only group. Declaration public virtual bool ReadOnly { get; } Property Value Type Description Boolean Schemas List of schemas for this group. Declaration public List<AddressableAssetGroupSchema> Schemas { get; } Property Value Type Description List < AddressableAssetGroupSchema > SchemaTypes Get the types of added schema for this group. Declaration public List<Type> SchemaTypes { get; } Property Value Type Description List < Type > Settings The AddressableAssetSettings that this group belongs to. Declaration public AddressableAssetSettings Settings { get; } Property Value Type Description AddressableAssetSettings Methods AddSchema(Type, Boolean) Creates and adds a schema of a given type to this group. The schema asset will be created in the GroupSchemas directory relative to the settings asset. Declaration public AddressableAssetGroupSchema AddSchema(Type type, bool postEvent = true) Parameters Type Name Description Type type The schema type. This type must not already be added. Boolean postEvent Determines if this method call will post an event to the internal addressables event system Returns Type Description AddressableAssetGroupSchema The created schema object. AddSchema(AddressableAssetGroupSchema, Boolean) Adds a copy of the provided schema object. Declaration public AddressableAssetGroupSchema AddSchema(AddressableAssetGroupSchema schema, bool postEvent = true) Parameters Type Name Description AddressableAssetGroupSchema schema The schema to add. A copy will be made and saved in a folder relative to the main Addressables settings asset. Boolean postEvent Determines if this method call will post an event to the internal addressables event system Returns Type Description AddressableAssetGroupSchema The created schema object. AddSchema<TSchema>(Boolean) Creates and adds a schema of a given type to this group. Declaration public TSchema AddSchema<TSchema>(bool postEvent = true) where TSchema : AddressableAssetGroupSchema Parameters Type Name Description Boolean postEvent Determines if this method call will post an event to the internal addressables event system Returns Type Description TSchema The created schema object. Type Parameters Name Description TSchema The schema type. This type must not already be added. CanBeSetAsDefault() Check if a group has the appropriate schemas and attributes that the Default Group requires. Declaration public bool CanBeSetAsDefault() Returns Type Description Boolean ClearSchemas(Boolean, Boolean) Removes all schemas and optionally deletes the assets associated with them. Declaration public void ClearSchemas(bool deleteAssets, bool postEvent = true) Parameters Type Name Description Boolean deleteAssets If true, the schema assets will also be deleted. Boolean postEvent Determines if this method call will post an event to the internal addressables event system Compare(AddressableAssetEntry, AddressableAssetEntry) Compares two asset entries based on their guids. Declaration public virtual int Compare(AddressableAssetEntry x, AddressableAssetEntry y) Parameters Type Name Description AddressableAssetEntry x The first entry to compare. AddressableAssetEntry y The second entry to compare. Returns Type Description Int32 Returns 0 if both entries are null or equivalent. Returns -1 if the first entry is null or the first entry precedes the second entry in the sort order. Returns 1 if the second entry is null or the first entry follows the second entry in the sort order. Implements IComparer<T>.Compare(T, T) FindSchema(Type) Gets the index of a schema based on its specified type. Declaration public int FindSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description Int32 Valid index if found, otherwise returns -1. GatherAllAssets(List<AddressableAssetEntry>, Boolean, Boolean, Boolean, Func<AddressableAssetEntry, Boolean>) Gathers all asset entries. Each explicit entry may contain multiple sub entries. For example, addressable folders create entries for each asset contained within. Declaration public virtual void GatherAllAssets(List<AddressableAssetEntry> results, bool includeSelf, bool recurseAll, bool includeSubObjects, Func<AddressableAssetEntry, bool> entryFilter = null) Parameters Type Name Description List < AddressableAssetEntry > results The generated list of entries. For simple entries, this will contain just the entry itself if specified. Boolean includeSelf Determines if the entry should be contained in the result list or just sub entries. Boolean recurseAll Determines if full recursion should be done when gathering entries. Boolean includeSubObjects Determines if sub objects such as sprites should be included. Func < AddressableAssetEntry , Boolean > entryFilter Optional predicate to run against each entry, only returning those that pass. A null filter will return all entries GetAssetEntry(String) Get an entry via the asset guid. Declaration public virtual AddressableAssetEntry GetAssetEntry(string guid) Parameters Type Name Description String guid The asset guid. Returns Type Description AddressableAssetEntry GetSchema(Type) Gets an added schema of the specified type. Declaration public AddressableAssetGroupSchema GetSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description AddressableAssetGroupSchema The schema if found, otherwise null. GetSchema<TSchema>() Gets an added schema of the specified type. Declaration public TSchema GetSchema<TSchema>() where TSchema : AddressableAssetGroupSchema Returns Type Description TSchema The schema if found, otherwise null. Type Parameters Name Description TSchema The schema type. HasSchema(Type) Checks if the group contains a schema of a given type. Declaration public bool HasSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description Boolean True if the schema type or subclass has been added to this group. HasSchema<TSchema>() Checks if the group contains a schema of a given type. Declaration public bool HasSchema<TSchema>() Returns Type Description Boolean True if the schema type or subclass has been added to this group. Type Parameters Name Description TSchema The schema type. IsDefaultGroup() Check to see if a group is the Default Group. Declaration public bool IsDefaultGroup() Returns Type Description Boolean OnAfterDeserialize() Converts data from serializable format. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Converts data to serializable format. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize() RemoveAssetEntry(AddressableAssetEntry, Boolean) Remove an entry. Declaration public void RemoveAssetEntry(AddressableAssetEntry entry, bool postEvent = true) Parameters Type Name Description AddressableAssetEntry entry The entry to remove. Boolean postEvent If true, post the event to callbacks. RemoveSchema(Type, Boolean) Remove a given schema from this group. Declaration public bool RemoveSchema(Type type, bool postEvent = true) Parameters Type Name Description Type type The schema type. Boolean postEvent Determines if this method call will post an event to the internal addressables event system Returns Type Description Boolean True if the schema was found and removed, false otherwise. RemoveSchema<TSchema>(Boolean) Remove a given schema from this group. Declaration public bool RemoveSchema<TSchema>(bool postEvent = true) Parameters Type Name Description Boolean postEvent Determines if this method call will post an event to the internal addressables event system Returns Type Description Boolean True if the schema was found and removed, false otherwise. Type Parameters Name Description TSchema The schema type. SetDirty(AddressableAssetSettings.ModificationEvent, Object, Boolean, Boolean) Marks the object as modified. Declaration public void SetDirty(AddressableAssetSettings.ModificationEvent modificationEvent, object eventData, bool postEvent, bool groupModified = false) Parameters Type Name Description AddressableAssetSettings.ModificationEvent modificationEvent The event type that is changed. Object eventData The object data that corresponds to the event. Boolean postEvent If true, the event is propagated to callbacks. Boolean groupModified If true, the group asset will be marked as dirty."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchema.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchema.html",
    "title": "Class AddressableAssetGroupSchema | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetGroupSchema Contains data for AddressableAssetGroups. Inheritance Object Object ScriptableObject AddressableAssetGroupSchema BundledAssetGroupSchema ContentUpdateGroupSchema PlayerDataGroupSchema Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetGroupSchema : ScriptableObject Properties Group Get the group that the schema belongs to. Declaration public AddressableAssetGroup Group { get; } Property Value Type Description AddressableAssetGroup Methods OnGUI() Used to display the GUI of the schema. Declaration public virtual void OnGUI() OnGUIMultiple(List<AddressableAssetGroupSchema>) Used to display the GUI of multiple selected groups. Declaration public virtual void OnGUIMultiple(List<AddressableAssetGroupSchema> otherSchemas) Parameters Type Name Description List < AddressableAssetGroupSchema > otherSchemas Schema instances in the other selected groups OnSetGroup(AddressableAssetGroup) Override this method to perform post creation initialization. Declaration protected virtual void OnSetGroup(AddressableAssetGroup group) Parameters Type Name Description AddressableAssetGroup group The group that the schema is added to. SetDirty(Boolean) Used to notify the addressables settings that data has been modified. This must be called by subclasses to ensure proper cache invalidation. Declaration protected void SetDirty(bool postEvent) Parameters Type Name Description Boolean postEvent Determines if this method call will post an event to the internal addressables event system ShowAllProperties() Used for drawing properties in the inspector. Declaration public virtual void ShowAllProperties() ShowMixedValue(SerializedProperty, List<AddressableAssetGroupSchema>, Type, String) Display mixed values for the specified property found in a list of schemas. Declaration protected void ShowMixedValue(SerializedProperty property, List<AddressableAssetGroupSchema> otherSchemas, Type type, string propertyName) Parameters Type Name Description SerializedProperty property The property. List < AddressableAssetGroupSchema > otherSchemas The list of schemas that may contain the property. Type type The property type. String propertyName The property name."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchemaSet.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchemaSet.html",
    "title": "Class AddressableAssetGroupSchemaSet | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetGroupSchemaSet Collection of AddressableAssetGroupSchema objects Inheritance Object AddressableAssetGroupSchemaSet Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetGroupSchemaSet Properties Schemas List of schemas for this group. Declaration public List<AddressableAssetGroupSchema> Schemas { get; } Property Value Type Description List < AddressableAssetGroupSchema > Types Get the list of schema types. Declaration public List<Type> Types { get; } Property Value Type Description List < Type > Methods AddSchema(Type, Func<Type, String>) Creates and adds a schema of a given type to this group. The schema asset will be created in the GroupSchemas directory relative to the settings asset. Declaration public AddressableAssetGroupSchema AddSchema(Type type, Func<Type, string> pathFunc) Parameters Type Name Description Type type The schema type. This type must not already be added. Func < Type , String > pathFunc A function that returns the path where this method can save the schema asset. Set to null to not create an in-project asset. Returns Type Description AddressableAssetGroupSchema The created schema object. AddSchema(AddressableAssetGroupSchema, Func<Type, String>) Adds a copy of the provided schema object. Declaration public AddressableAssetGroupSchema AddSchema(AddressableAssetGroupSchema schema, Func<Type, string> pathFunc) Parameters Type Name Description AddressableAssetGroupSchema schema The schema to copy. Func < Type , String > pathFunc A function that returns the path where this method can save the schema asset. Set to null to not create an in-project asset. Returns Type Description AddressableAssetGroupSchema The created schema object. ClearSchemas(Boolean) Removes all schemas and optionally deletes the assets associated with them. Declaration public void ClearSchemas(bool deleteAssets) Parameters Type Name Description Boolean deleteAssets If true, the schema assets will also be deleted. GetSchema(Type) Gets an added schema of the specified type. Declaration public AddressableAssetGroupSchema GetSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description AddressableAssetGroupSchema The schema if found, otherwise null. RemoveSchema(Type) Remove a given schema from this group. Declaration public bool RemoveSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description Boolean True if the schema was found and removed, false otherwise."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchemaTemplate.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupSchemaTemplate.html",
    "title": "Class AddressableAssetGroupSchemaTemplate | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetGroupSchemaTemplate Contains a set of schemas used by the GUI to create predefined asset groups. Inheritance Object AddressableAssetGroupSchemaTemplate Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetGroupSchemaTemplate Properties Description the description of the template. Declaration public string Description { get; } Property Value Type Description String DisplayName The display name of the template. Declaration public string DisplayName { get; } Property Value Type Description String Methods Create(String, String, Type[]) Creates a template with the specified name, descriptionm and schema types. Declaration public static AddressableAssetGroupSchemaTemplate Create(string name, string descr, params Type[] types) Parameters Type Name Description String name The name of the template. String descr The template description. Type [] types The schema types for the template. Returns Type Description AddressableAssetGroupSchemaTemplate The newly created schema template. GetTypes() The types of schemas in this template. Declaration public Type[] GetTypes() Returns Type Description Type [] The array of schema types."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupTemplate.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetGroupTemplate.html",
    "title": "Class AddressableAssetGroupTemplate | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetGroupTemplate Used to create template groups to make it easier for the user to create new groups. Inheritance Object Object ScriptableObject AddressableAssetGroupTemplate Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"AddressableAssetGroupTemplate.asset\", menuName = \"Addressables/Group Templates/Blank Group Template\")] public class AddressableAssetGroupTemplate : ScriptableObject, IGroupTemplate Properties Description The description of the AddressableAssetGroupTemplate Declaration public string Description { get; set; } Property Value Type Description String Implements IGroupTemplate.Description Name The name of the AddressableAssetGroupTemplate Declaration public string Name { get; } Property Value Type Description String Implements IGroupTemplate.Name SchemaObjects Returns the list of Preset objects of AddressableAssetGroupSchema associated with this template Declaration public List<AddressableAssetGroupSchema> SchemaObjects { get; } Property Value Type Description List < AddressableAssetGroupSchema > Methods AddSchema(Type, Boolean) Adds the AddressableAssetGroupSchema of type to the template. Declaration public bool AddSchema(Type type, bool postEvent = true) Parameters Type Name Description Type type The Type for the AddressableAssetGroupSchema to add to this template. Boolean postEvent If true, the event is propagated to callbacks. Returns Type Description Boolean If true, the type was added successfully. ApplyToAddressableAssetGroup(AddressableAssetGroup) Applies schema values for the group to the schema values found in the template Declaration public void ApplyToAddressableAssetGroup(AddressableAssetGroup group) Parameters Type Name Description AddressableAssetGroup group The AddressableAssetGroup to apply the schema settings to FindSchema(Type) Gets the index of a schema based on its specified type. Declaration public int FindSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description Int32 Valid index if found, otherwise returns -1. GetSchemaByType(Type) Gets an added schema of the specified type. Declaration public AddressableAssetGroupSchema GetSchemaByType(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description AddressableAssetGroupSchema The schema if found, otherwise null. GetTypes() Gets the types of the AddressableAssetGroupSchema associated with this template Declaration public Type[] GetTypes() Returns Type Description Type [] AddressableAssetGroupSchema types for schema on this template HasSchema(Type) Checks if the group contains a schema of a given type. Declaration public bool HasSchema(Type type) Parameters Type Name Description Type type The schema type. Returns Type Description Boolean True if the schema type or subclass has been added to this group. RemoveSchema(Type, Boolean) Removes the AddressableAssetGroupSchema of the type from the template. Declaration public bool RemoveSchema(Type type, bool postEvent = true) Parameters Type Name Description Type type The type of AddressableAssetGroupSchema to be removed. Boolean postEvent If true, the event is propagated to callbacks. Returns Type Description Boolean If true, the type was removed successfully. SetDirty(AddressableAssetSettings.ModificationEvent, Object, Boolean) Marks the object as modified. Declaration public void SetDirty(AddressableAssetSettings.ModificationEvent modificationEvent, object eventData, bool postEvent) Parameters Type Name Description AddressableAssetSettings.ModificationEvent modificationEvent The event type that is changed. Object eventData The object data that corresponds to the event. Boolean postEvent If true, the event is propagated to callbacks."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetProfileSettings.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetProfileSettings.html",
    "title": "Class AddressableAssetProfileSettings | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetProfileSettings Contains user defined variables to control build parameters. Inheritance Object AddressableAssetProfileSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AddressableAssetProfileSettings Fields customEntryString Text that represents a custom profile entry. Declaration public const string customEntryString = \"<custom>\" Field Value Type Description String undefinedEntryValue Text that represents an undefined profile entry. Declaration public const string undefinedEntryValue = \"<undefined>\" Field Value Type Description String Methods AddProfile(String, String) Adds a new profile. Declaration public string AddProfile(string name, string copyFromId) Parameters Type Name Description String name The name of the new profile. String copyFromId The id of the profile to copy values from. Returns Type Description String The id of the created profile. CreateValue(String, String) Create a new profile property. Declaration public string CreateValue(string variableName, string defaultValue) Parameters Type Name Description String variableName The name of the property. String defaultValue The default value. Returns Type Description String The id of the created variable. EvaluateString(String, String) Evaluate a string given a profile id. Declaration public string EvaluateString(string profileId, string varString) Parameters Type Name Description String profileId The profile id to use for evaluation. String varString The string to evaluate. Any tokens surrounded by '[' and ']' will be replaced with matching variables. Returns Type Description String The evaluated string. GetAllProfileNames() Get all profile names. Declaration public List<string> GetAllProfileNames() Returns Type Description List < String > The list of profile names. GetAllVariableIds() Gets the set of all profile ids. Declaration public HashSet<string> GetAllVariableIds() Returns Type Description HashSet < String > The set of profile ids. GetProfileId(String) Get the id of a given display name. Declaration public string GetProfileId(string profileName) Parameters Type Name Description String profileName The profile name. Returns Type Description String The id of the profile. Returns empty string if not found. GetProfileName(String) Get a profile's display name. Declaration public string GetProfileName(string profileId) Parameters Type Name Description String profileId The profile id. Returns Type Description String The display name of the profile. Returns empty string if not found. GetValueById(String, String) Get the value of a property. Declaration public string GetValueById(string profileId, string varId) Parameters Type Name Description String profileId The profile id. String varId The property id. Returns Type Description String GetValueByName(String, String) Get the value of a property by name. Declaration public string GetValueByName(string profileId, string varName) Parameters Type Name Description String profileId The profile id. String varName The variable name. Returns Type Description String GetVariableNames() Get all available variable names Declaration public List<string> GetVariableNames() Returns Type Description List < String > The variable names, sorted alphabetically. RemoveProfile(String) Removes a profile. Declaration public void RemoveProfile(string profileId) Parameters Type Name Description String profileId The id of the profile to remove. RemoveValue(String) Remove a profile property. Declaration public void RemoveValue(string variableId) Parameters Type Name Description String variableId The id of the property. RenameProfile(String, String) Renames a profile. profileId must refer to an existing profile. Profile names must be unique and must not be comprised of only whitespace. Returns false if profileId or newName is invalid. Declaration public bool RenameProfile(string profileId, string newName) Parameters Type Name Description String profileId The id of the profile to be renamed. String newName The new name to be given to the profile. Returns Type Description Boolean True if the rename is successful, false otherwise. Reset() Clears out the list of profiles, then creates a new default one. Declaration public string Reset() Returns Type Description String Returns the ID of the newly created default profile. SetDirty(AddressableAssetSettings.ModificationEvent, Object, Boolean) Marks the object as modified. Declaration public void SetDirty(AddressableAssetSettings.ModificationEvent modificationEvent, object eventData, bool postEvent) Parameters Type Name Description AddressableAssetSettings.ModificationEvent modificationEvent The event type that is changed. Object eventData The object data that corresponds to the event. Boolean postEvent If true, the event is propagated to callbacks. SetValue(String, String, String) Set the value of a variable for a specified profile. Declaration public void SetValue(string profileId, string variableName, string val) Parameters Type Name Description String profileId The profile id. String variableName The property name. String val The value to set the property."
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetSettings.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetSettings.html",
    "title": "Class AddressableAssetSettings | Addressables | 1.17.6-preview",
    "keywords": "Class AddressableAssetSettings Contains editor data for the addressables system. Inheritance Object Object ScriptableObject AddressableAssetSettings Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AddressableAssetSettings : ScriptableObject Fields kLocalBuildPath Default name of local build path. Declaration public const string kLocalBuildPath = \"LocalBuildPath\" Field Value Type Description String kLocalLoadPath Default name of local load path. Declaration public const string kLocalLoadPath = \"LocalLoadPath\" Field Value Type Description String kNewGroupName Default name of a newly created group. Declaration public const string kNewGroupName = \"New Group\" Field Value Type Description String kRemoteBuildPath Default name of remote build path. Declaration public const string kRemoteBuildPath = \"RemoteBuildPath\" Field Value Type Description String kRemoteLoadPath Default name of remote load path. Declaration public const string kRemoteLoadPath = \"RemoteLoadPath\" Field Value Type Description String Properties ActivePlayerDataBuilder Get the active data builder for player data. Declaration public IDataBuilder ActivePlayerDataBuilder { get; } Property Value Type Description IDataBuilder ActivePlayerDataBuilderIndex Get the index of the active player data builder. Declaration public int ActivePlayerDataBuilderIndex { get; set; } Property Value Type Description Int32 ActivePlayModeDataBuilder Get the active data builder for editor play mode data. Declaration public IDataBuilder ActivePlayModeDataBuilder { get; } Property Value Type Description IDataBuilder ActivePlayModeDataBuilderIndex Get the index of the active play mode data builder. Declaration public int ActivePlayModeDataBuilderIndex { get; set; } Property Value Type Description Int32 activeProfileId The active profile id. Declaration public string activeProfileId { get; set; } Property Value Type Description String AssetPath The path of the settings asset. Declaration public string AssetPath { get; } Property Value Type Description String BuildRemoteCatalog Determine if a remote catalog should be built-for and loaded-by the app. Declaration public bool BuildRemoteCatalog { get; set; } Property Value Type Description Boolean buildSettings Build settings object. Declaration public AddressableAssetBuildSettings buildSettings { get; } Property Value Type Description AddressableAssetBuildSettings BundleLocalCatalog Whether the local catalog should be serialized in an asset bundle or as json. Declaration public bool BundleLocalCatalog { get; set; } Property Value Type Description Boolean CertificateHandlerType The type of CertificateHandler to use for this provider. Declaration public Type CertificateHandlerType { get; set; } Property Value Type Description Type ConfigFolder The folder of the settings asset. Declaration public string ConfigFolder { get; } Property Value Type Description String ContiguousBundles If set, packs assets in bundles contiguously based on the ordering of the source asset which results in improved asset loading times. Disable this if you've built bundles with a version of Addressables older than 1.12.1 and you want to minimize bundle changes. Declaration public bool ContiguousBundles { get; set; } Property Value Type Description Boolean currentHash Hash of the current settings. This value is recomputed if anything changes. Declaration public Hash128 currentHash { get; } Property Value Type Description Hash128 CustomAssetEntryCommands The ids of the registered commands. Declaration public static IEnumerable<string> CustomAssetEntryCommands { get; } Property Value Type Description IEnumerable < String > CustomAssetGroupCommands The ids of the registered commands. Declaration public static IEnumerable<string> CustomAssetGroupCommands { get; } Property Value Type Description IEnumerable < String > DataBuilderFolder The folder for the script assets. Declaration public string DataBuilderFolder { get; } Property Value Type Description String DataBuilders List of ScriptableObjects that implement the IDataBuilder interface. These are used to create data for editor play mode and for player builds. Declaration public List<ScriptableObject> DataBuilders { get; } Property Value Type Description List < ScriptableObject > DefaultGroup The default group. This group is used when marking assets as addressable via the inspector. Declaration public AddressableAssetGroup DefaultGroup { get; set; } Property Value Type Description AddressableAssetGroup DisableCatalogUpdateOnStartup Tells Addressables if it should check for a Content Catalog Update during the initialization step. Declaration public bool DisableCatalogUpdateOnStartup { get; set; } Property Value Type Description Boolean GroupFolder The folder for the group assets. Declaration public string GroupFolder { get; } Property Value Type Description String groups List of asset groups. Declaration public List<AddressableAssetGroup> groups { get; } Property Value Type Description List < AddressableAssetGroup > GroupSchemaFolder The folder for the asset group schema assets. Declaration public string GroupSchemaFolder { get; } Property Value Type Description String GroupTemplateFolder The default folder for the group template assets. Declaration public string GroupTemplateFolder { get; } Property Value Type Description String GroupTemplateObjects List of ScriptableObjects that implement the IGroupTemplate interface for providing new templates. For use in the AddressableAssetsWindow to display new groups to create Declaration public List<ScriptableObject> GroupTemplateObjects { get; } Property Value Type Description List < ScriptableObject > HostingServicesManager Get the HostingServicesManager object. Declaration public HostingServicesManager HostingServicesManager { get; } Property Value Type Description HostingServicesManager IgnoreUnsupportedFilesInBuild Whether unsupported files during build should be ignored or treated as an error. Declaration public bool IgnoreUnsupportedFilesInBuild { get; set; } Property Value Type Description Boolean InitializationObjects List of ScriptableObjects that implement the IObjectInitializationDataProvider interface for providing runtime initialization. Declaration public List<ScriptableObject> InitializationObjects { get; } Property Value Type Description List < ScriptableObject > IsPersisted Returns whether this settings object is persisted to an asset. Declaration public bool IsPersisted { get; } Property Value Type Description Boolean MaxConcurrentWebRequests The maximum number of concurrent web requests. This value will be clamped from 1 to 1024. Declaration public int MaxConcurrentWebRequests { get; set; } Property Value Type Description Int32 OnDataBuilderComplete Event for handling the result of a DataBuilder.Build call. Declaration public Action<AddressableAssetSettings, IDataBuilder, IDataBuilderResult> OnDataBuilderComplete { get; set; } Property Value Type Description Action < AddressableAssetSettings , IDataBuilder , IDataBuilderResult > OnModification Event for handling settings changes. The object passed depends on the event type. Declaration public Action<AddressableAssetSettings, AddressableAssetSettings.ModificationEvent, object> OnModification { get; set; } Property Value Type Description Action < AddressableAssetSettings , AddressableAssetSettings.ModificationEvent , Object > OptimizeCatalogSize Enables size optimization of content catalogs. This may increase the cpu usage of loading the catalog. Declaration public bool OptimizeCatalogSize { get; set; } Property Value Type Description Boolean OverridePlayerVersion Allows for overriding the player version used to generated catalog names. Declaration public string OverridePlayerVersion { get; set; } Property Value Type Description String PlayerBuildVersion The version of the player build. This is implemented as a timestamp int UTC of the form string.Format(\"{0:D4}.{1:D2}.{2:D2}.{3:D2}.{4:D2}.{5:D2}\", now.Year, now.Month, now.Day, now.Hour, now.Minute, now.Second). Declaration public string PlayerBuildVersion { get; } Property Value Type Description String profileSettings Profile settings object. Declaration public AddressableAssetProfileSettings profileSettings { get; } Property Value Type Description AddressableAssetProfileSettings RemoteCatalogBuildPath The path to place a copy of the content catalog for online retrieval. To do any content updates to an existing built app, there must be a remote catalog. Overwriting the catalog is how the app gets informed of the updated content. Declaration public ProfileValueReference RemoteCatalogBuildPath { get; set; } Property Value Type Description ProfileValueReference RemoteCatalogLoadPath The path to load the remote content catalog from. This is the location the app will check to look for updated catalogs, which is the only indication the app has for updated content. Declaration public ProfileValueReference RemoteCatalogLoadPath { get; set; } Property Value Type Description ProfileValueReference ShaderBundleCustomNaming Custom Unity built in shader bundle prefix that is used if AddressableAssetSettings.ShaderBundleNaming is set to ShaderBundleNaming.Custom. Declaration public string ShaderBundleCustomNaming { get; set; } Property Value Type Description String ShaderBundleNaming Sets the naming convention used for the Unity built in shader bundle at build time. The recommended setting is Project Name. Declaration public ShaderBundleNaming ShaderBundleNaming { get; set; } Property Value Type Description ShaderBundleNaming UniqueBundleIds Set this to true to ensure unique bundle ids. Set to false to allow duplicate bundle ids. Declaration public bool UniqueBundleIds { get; set; } Property Value Type Description Boolean Methods AddDataBuilder(IDataBuilder, Boolean) Adds a data builder. Declaration public bool AddDataBuilder(IDataBuilder builder, bool postEvent = true) Parameters Type Name Description IDataBuilder builder The data builder to add. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the data builder was added. AddGroupTemplateObject(IGroupTemplate, Boolean) Adds a AddressableAssetsGroupTemplate object. Declaration public bool AddGroupTemplateObject(IGroupTemplate templateObject, bool postEvent = true) Parameters Type Name Description IGroupTemplate templateObject The AddressableAssetGroupTemplate object to add. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was added. AddInitializationObject(IObjectInitializationDataProvider, Boolean) Adds an initialization object. Declaration public bool AddInitializationObject(IObjectInitializationDataProvider initObject, bool postEvent = true) Parameters Type Name Description IObjectInitializationDataProvider initObject The initialization object to add. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was added. AddLabel(String, Boolean) Add a new label. Declaration public void AddLabel(string label, bool postEvent = true) Parameters Type Name Description String label The label name. Boolean postEvent Send modification event. BuildPlayerContent() Runs the active player data build script to create runtime data. See the BuildPlayerContent documentation for more details. Declaration public static void BuildPlayerContent() BuildPlayerContent(out AddressablesPlayerBuildResult) Runs the active player data build script to create runtime data. See the BuildPlayerContent documentation for more details. Declaration public static void BuildPlayerContent(out AddressablesPlayerBuildResult result) Parameters Type Name Description AddressablesPlayerBuildResult result Results from running the active player data build script. CleanPlayerContent(IDataBuilder) Deletes all created runtime data for the active player data builder. Declaration public static void CleanPlayerContent(IDataBuilder builder = null) Parameters Type Name Description IDataBuilder builder The builder to call ClearCachedData on. If null, all builders will be cleaned Create(String, String, Boolean, Boolean) Create a new AddressableAssetSettings object. Declaration public static AddressableAssetSettings Create(string configFolder, string configName, bool createDefaultGroups, bool isPersisted) Parameters Type Name Description String configFolder The folder to store the settings object. String configName The name of the settings object. Boolean createDefaultGroups If true, create groups for player data and local packed content. Boolean isPersisted If true, assets are created. Returns Type Description AddressableAssetSettings CreateAndAddGroupTemplate(String, String, Type[]) Creates a new AddressableAssetGroupTemplate Object with the set of schema types with default settings for use in the editor GUI. Declaration public bool CreateAndAddGroupTemplate(string displayName, string description, params Type[] types) Parameters Type Name Description String displayName The display name of the template. String description Description text use with the template. Type [] types The schema types for the template. Returns Type Description Boolean True if the template was added, false otherwise. CreateAssetReference(String) Create an AssetReference object. If the asset is not already addressable, it will be added. Declaration public AssetReference CreateAssetReference(string guid) Parameters Type Name Description String guid The guid of the asset reference. Returns Type Description AssetReference Returns the newly created AssetReference. CreateGroup(String, Boolean, Boolean, Boolean, List<AddressableAssetGroupSchema>, Type[]) Create a new asset group. Declaration public AddressableAssetGroup CreateGroup(string groupName, bool setAsDefaultGroup, bool readOnly, bool postEvent, List<AddressableAssetGroupSchema> schemasToCopy, params Type[] types) Parameters Type Name Description String groupName The group name. Boolean setAsDefaultGroup Set the new group as the default group. Boolean readOnly Is the new group read only. Boolean postEvent Post modification event. List < AddressableAssetGroupSchema > schemasToCopy Schema set to copy from. Type [] types Types of schemas to add. Returns Type Description AddressableAssetGroup The newly created group. CreateOrMoveEntry(String, AddressableAssetGroup, Boolean, Boolean) Create a new entry, or if one exists in a different group, move it into the new group. Declaration public AddressableAssetEntry CreateOrMoveEntry(string guid, AddressableAssetGroup targetParent, bool readOnly = false, bool postEvent = true) Parameters Type Name Description String guid The asset guid. AddressableAssetGroup targetParent The group to add the entry to. Boolean readOnly Is the new entry read only. Boolean postEvent Send modification event. Returns Type Description AddressableAssetEntry FindAssetEntry(String) Find and asset entry by guid. Declaration public AddressableAssetEntry FindAssetEntry(string guid) Parameters Type Name Description String guid The asset guid. Returns Type Description AddressableAssetEntry The found entry or null. FindGroup(Func<AddressableAssetGroup, Boolean>) Find asset group by functor. Declaration public AddressableAssetGroup FindGroup(Func<AddressableAssetGroup, bool> func) Parameters Type Name Description Func < AddressableAssetGroup , Boolean > func The functor to call on each group. The first group that evaluates to true is returned. Returns Type Description AddressableAssetGroup The group found or null. FindGroup(String) Find asset group by name. Declaration public AddressableAssetGroup FindGroup(string groupName) Parameters Type Name Description String groupName The name of the group. Returns Type Description AddressableAssetGroup The group found or null. GetAllAssets(List<AddressableAssetEntry>, Boolean, Func<AddressableAssetGroup, Boolean>, Func<AddressableAssetEntry, Boolean>) Gets all asset entries from all groups. Declaration public void GetAllAssets(List<AddressableAssetEntry> assets, bool includeSubObjects, Func<AddressableAssetGroup, bool> groupFilter = null, Func<AddressableAssetEntry, bool> entryFilter = null) Parameters Type Name Description List < AddressableAssetEntry > assets The list of asset entries. Boolean includeSubObjects Determines if sub objects such as sprites should be included. Func < AddressableAssetGroup , Boolean > groupFilter A method to filter groups. Groups will be processed if filter is null, or it returns TRUE Func < AddressableAssetEntry , Boolean > entryFilter A method to filter entries. Entries will be processed if filter is null, or it returns TRUE GetDataBuilder(Int32) Get The data builder at a specifc index. Declaration public IDataBuilder GetDataBuilder(int index) Parameters Type Name Description Int32 index The index of the builder. Returns Type Description IDataBuilder The data builder at the specified index. GetGroupTemplateObject(Int32) Get the IGroupTemplate at the specified index. Declaration public IGroupTemplate GetGroupTemplateObject(int index) Parameters Type Name Description Int32 index The index of the template object. Returns Type Description IGroupTemplate The AddressableAssetGroupTemplate object at the specified index. GetInitializationObject(Int32) Get the IObjectInitializationDataProvider at a specifc index. Declaration public IObjectInitializationDataProvider GetInitializationObject(int index) Parameters Type Name Description Int32 index The index of the initialization object. Returns Type Description IObjectInitializationDataProvider The initialization object at the specified index. GetLabels() Gets the list of all defined labels. Declaration public List<string> GetLabels() Returns Type Description List < String > Returns a list of all defined labels. InvokeAssetEntryCommand(String, IEnumerable<AddressableAssetEntry>) Invoke a registered command for a set of entries. Declaration public static bool InvokeAssetEntryCommand(string cmdId, IEnumerable<AddressableAssetEntry> entries) Parameters Type Name Description String cmdId The id of the command. IEnumerable < AddressableAssetEntry > entries The entries to run the command on. Returns Type Description Boolean Returns true if the command was executed without exceptions. InvokeAssetGroupCommand(String, IEnumerable<AddressableAssetGroup>) Invoke a registered command for a set of groups. Declaration public static bool InvokeAssetGroupCommand(string cmdId, IEnumerable<AddressableAssetGroup> groups) Parameters Type Name Description String cmdId The id of the command. IEnumerable < AddressableAssetGroup > groups Returns Type Description Boolean Returns true if the command was invoked successfully. MoveEntries(List<AddressableAssetEntry>, AddressableAssetGroup, Boolean, Boolean) Move an existing entry to a group. Declaration public void MoveEntries(List<AddressableAssetEntry> entries, AddressableAssetGroup targetParent, bool readOnly = false, bool postEvent = true) Parameters Type Name Description List < AddressableAssetEntry > entries The entries to move. AddressableAssetGroup targetParent The group to add the entries to. Boolean readOnly Should the entries be read only. Boolean postEvent Send modification event. MoveEntry(AddressableAssetEntry, AddressableAssetGroup, Boolean, Boolean) Move an existing entry to a group. Declaration public void MoveEntry(AddressableAssetEntry entry, AddressableAssetGroup targetParent, bool readOnly = false, bool postEvent = true) Parameters Type Name Description AddressableAssetEntry entry The entry to move. AddressableAssetGroup targetParent The group to add the entry to. Boolean readOnly Should the entry be read only. Boolean postEvent Send modification event. RegisterCustomAssetEntryCommand(String, Action<IEnumerable<AddressableAssetEntry>>) Register a custom command to process asset entries. These commands will be shown in the context menu of the groups window. Declaration public static bool RegisterCustomAssetEntryCommand(string cmdId, Action<IEnumerable<AddressableAssetEntry>> cmdFunc) Parameters Type Name Description String cmdId The id of the command. This will be used for the display name of the context menu item. Action < IEnumerable < AddressableAssetEntry >> cmdFunc The command handler function. Returns Type Description Boolean Returns true if the command was registered. RegisterCustomAssetGroupCommand(String, Action<IEnumerable<AddressableAssetGroup>>) Register a custom command to process asset groups. These commands will be shown in the context menu of the groups window. Declaration public static bool RegisterCustomAssetGroupCommand(string cmdId, Action<IEnumerable<AddressableAssetGroup>> cmdFunc) Parameters Type Name Description String cmdId The id of the command. This will be used for the display name of the context menu item. Action < IEnumerable < AddressableAssetGroup >> cmdFunc The command handler function. Returns Type Description Boolean Returns true if the command was registered. RemoveAssetEntry(String, Boolean) Remove an asset entry. Declaration public bool RemoveAssetEntry(string guid, bool postEvent = true) Parameters Type Name Description String guid The guid of the asset. Boolean postEvent Send modifcation event. Returns Type Description Boolean True if the entry was found and removed. RemoveDataBuilder(Int32, Boolean) Remove the data builder at the sprcified index. Declaration public bool RemoveDataBuilder(int index, bool postEvent = true) Parameters Type Name Description Int32 index The index to remove. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the builder was removed. RemoveGroup(AddressableAssetGroup) Remove an asset group. Declaration public void RemoveGroup(AddressableAssetGroup g) Parameters Type Name Description AddressableAssetGroup g RemoveGroupTemplateObject(Int32, Boolean) Remove the AddressableAssetGroupTemplate object at the specified index. Declaration public bool RemoveGroupTemplateObject(int index, bool postEvent = true) Parameters Type Name Description Int32 index The index to remove. Boolean postEvent Indicates if an event should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was removed. RemoveInitializationObject(Int32, Boolean) Remove the initialization object at the specified index. Declaration public bool RemoveInitializationObject(int index, bool postEvent = true) Parameters Type Name Description Int32 index The index to remove. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was removed. RemoveLabel(String, Boolean) Remove a label by name. Declaration public void RemoveLabel(string label, bool postEvent = true) Parameters Type Name Description String label The label name. Boolean postEvent Send modification event. RemoveSchemaTemplate(Int32, Boolean) Remove the schema at the specified index. Declaration [Obsolete(\"GroupSchemaTemplates are deprecated, use GroupTemplateObjects\")] public bool RemoveSchemaTemplate(int index, bool postEvent = true) Parameters Type Name Description Int32 index The index to remove at. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the schema was removed. SetDataBuilderAtIndex(Int32, IDataBuilder, Boolean) Sets the data builder at the specified index. Declaration public bool SetDataBuilderAtIndex(int index, IDataBuilder builder, bool postEvent = true) Parameters Type Name Description Int32 index The index to set the builder. IDataBuilder builder The builder to set. This must be a valid scriptable object that implements the IDataBuilder interface. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the builder was set, false otherwise. SetDirty(AddressableAssetSettings.ModificationEvent, Object, Boolean, Boolean) Marks the object as modified. Declaration public void SetDirty(AddressableAssetSettings.ModificationEvent modificationEvent, object eventData, bool postEvent, bool settingsModified = false) Parameters Type Name Description AddressableAssetSettings.ModificationEvent modificationEvent The event type that is changed. Object eventData The object data that corresponds to the event. Boolean postEvent If true, the event is propagated to callbacks. Boolean settingsModified If true, the settings asset will be marked as dirty. SetGroupTemplateObjectAtIndex(Int32, IGroupTemplate, Boolean) Sets the initialization object at the specified index. Declaration public bool SetGroupTemplateObjectAtIndex(int index, IGroupTemplate templateObject, bool postEvent = true) Parameters Type Name Description Int32 index The index to set the initialization object. IGroupTemplate templateObject The rroup template object to set. This must be a valid scriptable object that implements the IGroupTemplate interface. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was set, false otherwise. SetInitializationObjectAtIndex(Int32, IObjectInitializationDataProvider, Boolean) Sets the initialization object at the specified index. Declaration public bool SetInitializationObjectAtIndex(int index, IObjectInitializationDataProvider initObject, bool postEvent = true) Parameters Type Name Description Int32 index The index to set the initialization object. IObjectInitializationDataProvider initObject The initialization object to set. This must be a valid scriptable object that implements the IInitializationObject interface. Boolean postEvent Indicates if an even should be posted to the Addressables event system for this change. Returns Type Description Boolean True if the initialization object was set, false otherwise. UnregisterCustomAssetEntryCommand(String) Removes a registered custom entry command. Declaration public static bool UnregisterCustomAssetEntryCommand(string cmdId) Parameters Type Name Description String cmdId The command id. Returns Type Description Boolean Returns true if the command was removed. UnregisterCustomAssetGroupCommand(String) Removes a registered custom group command. Declaration public static bool UnregisterCustomAssetGroupCommand(string cmdId) Parameters Type Name Description String cmdId The command id. Returns Type Description Boolean Returns true if the command was removed. Events OnModificationGlobal Event for handling settings changes on all instances of AddressableAssetSettings. The object passed depends on the event type. Declaration public static event Action<AddressableAssetSettings, AddressableAssetSettings.ModificationEvent, object> OnModificationGlobal Event Type Type Description Action < AddressableAssetSettings , AddressableAssetSettings.ModificationEvent , Object >"
  },
  "api/UnityEditor.AddressableAssets.Settings.AddressableAssetSettings.ModificationEvent.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.AddressableAssetSettings.ModificationEvent.html",
    "title": "Enum AddressableAssetSettings.ModificationEvent | Addressables | 1.17.6-preview",
    "keywords": "Enum AddressableAssetSettings.ModificationEvent Options for labelling all the different generated events. Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum ModificationEvent Fields Name Description Value GroupAdded Use to indicate that a group was added to the settings object. 0 GroupRemoved Use to indicate that a group was removed from the the settings object. 1 GroupRenamed Use to indicate that a group in the settings object was renamed. 2 GroupSchemaAdded Use to indicate that a schema was added to a group. 3 GroupSchemaRemoved Use to indicate that a schema was removed from a group. 4 GroupSchemaModified Use to indicate that a schema was modified. 5 GroupTemplateAdded Use to indicate that a group template was added to the settings object. 6 GroupTemplateRemoved Use to indicate that a group template was removed from the settings object. 7 GroupTemplateSchemaAdded Use to indicate that a schema was added to a group template. 8 GroupTemplateSchemaRemoved Use to indicate that a schema was removed from a group template. 9 EntryCreated Use to indicate that an asset entry was created. 10 EntryAdded Use to indicate that an asset entry was added to a group. 11 EntryMoved Use to indicate that an asset entry moved from one group to another. 12 EntryRemoved Use to indicate that an asset entry was removed from a group. 13 LabelAdded Use to indicate that an asset label was added to the settings object. 14 LabelRemoved Use to indicate that an asset label was removed from the settings object. 15 ProfileAdded Use to indicate that a profile was added to the settings object. 16 ProfileRemoved Use to indicate that a profile was removed from the settings object. 17 ProfileModified Use to indicate that a profile was modified. 18 ActiveProfileSet Use to indicate that a profile has been set as the active profile. 19 EntryModified Use to indicate that an asset entry was modified. 20 BuildSettingsChanged Use to indicate that the build settings object was modified. 21 ActiveBuildScriptChanged Use to indicate that a new build script is being used as the active build script. 22 DataBuilderAdded Use to indicate that a new data builder script was added to the settings object. 23 DataBuilderRemoved Use to indicate that a data builder script was removed from the settings object. 24 InitializationObjectAdded Use to indicate a new initialization object was added to the settings object. 25 InitializationObjectRemoved Use to indicate a initialization object was removed from the settings object. 26 ActivePlayModeScriptChanged Use to indicate that a new script is being used as the active playmode data builder. 27 BatchModification Use to indicate that a batch of asset entries was modified. Note that the posted object will be null. 28 HostingServicesManagerModified Use to indicate that the hosting services manager was modified. 29 GroupMoved Use to indicate that a group changed its order placement within the list of groups in the settings object. 30 CertificateHandlerChanged Use to indicate that a new certificate handler is being used for the initialization object provider. 31"
  },
  "api/UnityEditor.AddressableAssets.Settings.CacheInitializationSettings.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.CacheInitializationSettings.html",
    "title": "Class CacheInitializationSettings | Addressables | 1.17.6-preview",
    "keywords": "Class CacheInitializationSettings Asset container for CacheInitializationData. Inheritance Object Object ScriptableObject CacheInitializationSettings Inherited Members ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [CreateAssetMenu(fileName = \"CacheInitializationSettings.asset\", menuName = \"Addressables/Initialization/Cache Initialization Settings\")] public class CacheInitializationSettings : ScriptableObject, IObjectInitializationDataProvider Properties Data The cache initialization data that will be serialized and applied during Addressables initialization. Declaration public CacheInitializationData Data { get; set; } Property Value Type Description CacheInitializationData Name Display name used in GUI for this object. Declaration public string Name { get; } Property Value Type Description String Implements IObjectInitializationDataProvider.Name Methods CreateObjectInitializationData() Create initialization data to be serialized into the Addressables runtime data. Declaration public ObjectInitializationData CreateObjectInitializationData() Returns Type Description ObjectInitializationData The serialized data for the initialization class and the data. Implements IObjectInitializationDataProvider.CreateObjectInitializationData()"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.AssetNamingMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.AssetNamingMode.html",
    "title": "Enum BundledAssetGroupSchema.AssetNamingMode | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.AssetNamingMode Options for internal id of assets in bundles. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum AssetNamingMode Fields Name Description Value FullPath Use to identify assets by their full path. 0 Filename Use to identify assets by their filename only. There is a risk of collisions when assets in different folders have the same filename. 1 GUID Use to identify assets by their asset guid. This will save space over using the full path and will be stable if assets move in the project. 2 Dynamic This method attempts to use the smallest identifier for internal asset ids. For asset bundles with very few items, this can save a significant amount of space in the content catalog. 3"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleCompressionMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleCompressionMode.html",
    "title": "Enum BundledAssetGroupSchema.BundleCompressionMode | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.BundleCompressionMode Options for compressing bundles in this group. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum BundleCompressionMode Fields Name Description Value Uncompressed Use to indicate that bundles will not be compressed. 0 LZ4 Use to indicate that bundles will be compressed using the LZ4 compression algorithm. 1 LZMA Use to indicate that bundles will be compressed using the LZMA compression algorithm. 2"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleInternalIdMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleInternalIdMode.html",
    "title": "Enum BundledAssetGroupSchema.BundleInternalIdMode | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.BundleInternalIdMode Defines how internal bundles are named. This is used for both caching and for inter-bundle dependecies. If possible, GroupGuidProjectIdHash should be used as it is stable and unique between projects. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum BundleInternalIdMode Fields Name Description Value GroupGuid Use the guid of the group asset 0 GroupGuidProjectIdHash Use the hash of the group asset guid and the project id 1 GroupGuidProjectIdEntriesHash Use the hash of the group asset, the project id and the guids of the entries in the group 2"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleNamingStyle.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundleNamingStyle.html",
    "title": "Enum BundledAssetGroupSchema.BundleNamingStyle | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.BundleNamingStyle Used to determine how the final bundle name should look. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum BundleNamingStyle Fields Name Description Value AppendHash Use to indicate that the hash should be appended to the bundle name. 0 NoHash Use to indicate that the bundle name should not contain the hash. 1 OnlyHash Use to indicate that the bundle name should only contain the given hash. 2 FileNameHash Use to indicate that the bundle name should only contain the hash of the file name. 3"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundlePackingMode.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.BundlePackingMode.html",
    "title": "Enum BundledAssetGroupSchema.BundlePackingMode | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.BundlePackingMode Defines how bundles are created. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum BundlePackingMode Fields Name Description Value PackTogether Creates a bundle for all non-scene entries and another for all scenes entries. 0 PackSeparately Creates a bundle per entry. This is useful if each entry is a folder as all sub entries will go to the same bundle. 1 PackTogetherByLabel Creates a bundle per unique set of labels 2"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.CacheClearBehavior.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.CacheClearBehavior.html",
    "title": "Enum BundledAssetGroupSchema.CacheClearBehavior | Addressables | 1.17.6-preview",
    "keywords": "Enum BundledAssetGroupSchema.CacheClearBehavior Behavior for clearing old bundles from the cache. Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum CacheClearBehavior Fields Name Description Value ClearWhenSpaceIsNeededInCache Bundles are only removed from the cache when space is needed. 0 ClearWhenWhenNewVersionLoaded Bundles are removed from the cache when a newer version has been loaded successfully. 1"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.BundledAssetGroupSchema.html",
    "title": "Class BundledAssetGroupSchema | Addressables | 1.17.6-preview",
    "keywords": "Class BundledAssetGroupSchema Schema used for bundled asset groups. Inheritance Object Object ScriptableObject AddressableAssetGroupSchema BundledAssetGroupSchema Inherited Members AddressableAssetGroupSchema.Group AddressableAssetGroupSchema.SetDirty(Boolean) AddressableAssetGroupSchema.ShowMixedValue(SerializedProperty, List<AddressableAssetGroupSchema>, Type, String) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class BundledAssetGroupSchema : AddressableAssetGroupSchema, IHostingServiceConfigurationProvider, ISerializationCallbackReceiver Properties AssetBundledCacheClearBehavior Determines how other cached versions of asset bundles are cleared. Declaration public BundledAssetGroupSchema.CacheClearBehavior AssetBundledCacheClearBehavior { get; set; } Property Value Type Description BundledAssetGroupSchema.CacheClearBehavior AssetBundleProviderType The provider type to use for loading asset bundles. Declaration public SerializedType AssetBundleProviderType { get; } Property Value Type Description SerializedType BuildPath The path to copy asset bundles to. Declaration public ProfileValueReference BuildPath { get; } Property Value Type Description ProfileValueReference BundledAssetProviderType The provider type to use for loading assets from bundles. Declaration public SerializedType BundledAssetProviderType { get; } Property Value Type Description SerializedType BundleMode Controls how bundles are packed. If set to PackTogether, a single asset bundle will be created for the entire group, with the exception of scenes, which are packed in a second bundle. If set to PackSeparately, an asset bundle will be created for each entry in the group; in the case that an entry is a folder, one bundle is created for the folder and all of its sub entries. Declaration public BundledAssetGroupSchema.BundlePackingMode BundleMode { get; set; } Property Value Type Description BundledAssetGroupSchema.BundlePackingMode BundleNaming Naming style to use for generated AssetBundle(s). Declaration public BundledAssetGroupSchema.BundleNamingStyle BundleNaming { get; set; } Property Value Type Description BundledAssetGroupSchema.BundleNamingStyle ChunkedTransfer Indicates whether the UnityWebRequest system should employ the HTTP/1.1 chunked-transfer encoding method. Declaration public bool ChunkedTransfer { get; set; } Property Value Type Description Boolean Compression Build compression. Declaration public BundledAssetGroupSchema.BundleCompressionMode Compression { get; set; } Property Value Type Description BundledAssetGroupSchema.BundleCompressionMode ForceUniqueProvider If true, the bundle and asset provider for assets in this group will get unique provider ids and will only provide for assets in this group. Declaration public bool ForceUniqueProvider { get; set; } Property Value Type Description Boolean HostingServicesContentRoot Returns the Hosting Service content root path for the given AddressableAssetGroup Declaration public string HostingServicesContentRoot { get; } Property Value Type Description String Implements IHostingServiceConfigurationProvider.HostingServicesContentRoot IncludeAddressInCatalog If enabled, addresses are included in the content catalog. This is required if assets are to be loaded via their main address. Declaration public bool IncludeAddressInCatalog { get; set; } Property Value Type Description Boolean IncludeGUIDInCatalog If enabled, guids are included in content catalogs. This is required if assets are to be loaded via AssetReference. Declaration public bool IncludeGUIDInCatalog { get; set; } Property Value Type Description Boolean IncludeInBuild If true, the assets in this group will be included in the build of bundles. Declaration public bool IncludeInBuild { get; set; } Property Value Type Description Boolean IncludeLabelsInCatalog If enabled, labels are included in the content catalogs. This is required if labels are used at runtime load load assets. Declaration public bool IncludeLabelsInCatalog { get; set; } Property Value Type Description Boolean InternalBundleIdMode Internal bundle naming mode Declaration public BundledAssetGroupSchema.BundleInternalIdMode InternalBundleIdMode { get; set; } Property Value Type Description BundledAssetGroupSchema.BundleInternalIdMode InternalIdNamingMode Internal Id mode for assets in bundles. Declaration public BundledAssetGroupSchema.AssetNamingMode InternalIdNamingMode { get; set; } Property Value Type Description BundledAssetGroupSchema.AssetNamingMode LoadPath The path to load bundles from. Declaration public ProfileValueReference LoadPath { get; } Property Value Type Description ProfileValueReference RedirectLimit Indicates the number of redirects which this UnityWebRequest will follow before halting with a “Redirect Limit Exceeded” system error. Declaration public int RedirectLimit { get; set; } Property Value Type Description Int32 RetryCount Indicates the number of times the request will be retried. Declaration public int RetryCount { get; set; } Property Value Type Description Int32 Timeout Sets UnityWebRequest to attempt to abort after the number of seconds in timeout have passed. Declaration public int Timeout { get; set; } Property Value Type Description Int32 UseAssetBundleCache If true, the CRC and Hash values of the asset bundle are used to determine if a bundle can be loaded from the local cache instead of downloaded. Declaration public bool UseAssetBundleCache { get; set; } Property Value Type Description Boolean UseAssetBundleCrc If true, the CRC and Hash values of the asset bundle are used to determine if a bundle can be loaded from the local cache instead of downloaded. Declaration public bool UseAssetBundleCrc { get; set; } Property Value Type Description Boolean UseAssetBundleCrcForCachedBundles If true, the CRC and Hash values of the asset bundle are used to determine if a bundle can be loaded from the local cache instead of downloaded. Declaration public bool UseAssetBundleCrcForCachedBundles { get; set; } Property Value Type Description Boolean Methods GetAssetCachedProviderId() Returns the id of the asset provider needed to load from this group. Declaration public string GetAssetCachedProviderId() Returns Type Description String The id of the cached provider needed for this group. GetBuildCompressionForBundle(String) Gets the build compression settings for bundles in this group. Declaration public virtual BuildCompression GetBuildCompressionForBundle(string bundleId) Parameters Type Name Description String bundleId The bundle id. Returns Type Description BuildCompression The build compression. GetBundleCachedProviderId() Returns the id of the bundle provider needed to load from this group. Declaration public string GetBundleCachedProviderId() Returns Type Description String The id of the cached provider needed for this group. OnAfterDeserialize() Impementation of ISerializationCallbackReceiver, used to set callbacks for ProfileValueReference changes. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Impementation of ISerializationCallbackReceiver, does nothing. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize() OnGUI() Used to display the GUI of the schema. Declaration public override void OnGUI() Overrides AddressableAssetGroupSchema.OnGUI() OnGUIMultiple(List<AddressableAssetGroupSchema>) Used to display the GUI of multiple selected groups. Declaration public override void OnGUIMultiple(List<AddressableAssetGroupSchema> otherSchemas) Parameters Type Name Description List < AddressableAssetGroupSchema > otherSchemas Schema instances in the other selected groups Overrides AddressableAssetGroupSchema.OnGUIMultiple(List<AddressableAssetGroupSchema>) OnSetGroup(AddressableAssetGroup) Set default values taken from the assigned group. Declaration protected override void OnSetGroup(AddressableAssetGroup group) Parameters Type Name Description AddressableAssetGroup group The group this schema has been added to. Overrides AddressableAssetGroupSchema.OnSetGroup(AddressableAssetGroup) ShowAllProperties() Used for drawing properties in the inspector. Declaration public override void ShowAllProperties() Overrides AddressableAssetGroupSchema.ShowAllProperties()"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.ContentUpdateGroupSchema.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.ContentUpdateGroupSchema.html",
    "title": "Class ContentUpdateGroupSchema | Addressables | 1.17.6-preview",
    "keywords": "Class ContentUpdateGroupSchema Schema for content updates. Inheritance Object Object ScriptableObject AddressableAssetGroupSchema ContentUpdateGroupSchema Inherited Members AddressableAssetGroupSchema.Group AddressableAssetGroupSchema.OnSetGroup(AddressableAssetGroup) AddressableAssetGroupSchema.SetDirty(Boolean) AddressableAssetGroupSchema.ShowAllProperties() AddressableAssetGroupSchema.ShowMixedValue(SerializedProperty, List<AddressableAssetGroupSchema>, Type, String) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ContentUpdateGroupSchema : AddressableAssetGroupSchema Properties StaticContent Is the group static. This property is used in determining which assets need to be moved to a new remote group during the content update process. Declaration public bool StaticContent { get; set; } Property Value Type Description Boolean Methods OnGUI() Used to display the GUI of the schema. Declaration public override void OnGUI() Overrides AddressableAssetGroupSchema.OnGUI() OnGUIMultiple(List<AddressableAssetGroupSchema>) Used to display the GUI of multiple selected groups. Declaration public override void OnGUIMultiple(List<AddressableAssetGroupSchema> otherSchemas) Parameters Type Name Description List < AddressableAssetGroupSchema > otherSchemas Schema instances in the other selected groups Overrides AddressableAssetGroupSchema.OnGUIMultiple(List<AddressableAssetGroupSchema>)"
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.html",
    "title": "Namespace UnityEditor.AddressableAssets.Settings.GroupSchemas | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Settings.GroupSchemas Classes BundledAssetGroupSchema Schema used for bundled asset groups. ContentUpdateGroupSchema Schema for content updates. PlayerDataGroupSchema Schema for the player data asset group Enums BundledAssetGroupSchema.AssetNamingMode Options for internal id of assets in bundles. BundledAssetGroupSchema.BundleCompressionMode Options for compressing bundles in this group. BundledAssetGroupSchema.BundleInternalIdMode Defines how internal bundles are named. This is used for both caching and for inter-bundle dependecies. If possible, GroupGuidProjectIdHash should be used as it is stable and unique between projects. BundledAssetGroupSchema.BundleNamingStyle Used to determine how the final bundle name should look. BundledAssetGroupSchema.BundlePackingMode Defines how bundles are created. BundledAssetGroupSchema.CacheClearBehavior Behavior for clearing old bundles from the cache."
  },
  "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.PlayerDataGroupSchema.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.GroupSchemas.PlayerDataGroupSchema.html",
    "title": "Class PlayerDataGroupSchema | Addressables | 1.17.6-preview",
    "keywords": "Class PlayerDataGroupSchema Schema for the player data asset group Inheritance Object Object ScriptableObject AddressableAssetGroupSchema PlayerDataGroupSchema Inherited Members AddressableAssetGroupSchema.Group AddressableAssetGroupSchema.OnSetGroup(AddressableAssetGroup) AddressableAssetGroupSchema.OnGUI() AddressableAssetGroupSchema.SetDirty(Boolean) AddressableAssetGroupSchema.ShowAllProperties() AddressableAssetGroupSchema.ShowMixedValue(SerializedProperty, List<AddressableAssetGroupSchema>, Type, String) ScriptableObject.SetDirty() ScriptableObject.CreateInstance(String) ScriptableObject.CreateInstance(Type) ScriptableObject.CreateInstance<T>() Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings.GroupSchemas <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class PlayerDataGroupSchema : AddressableAssetGroupSchema Properties IncludeBuildSettingsScenes If enabled, all scenes in the editor build settings will have addresses generated during the build. Declaration public bool IncludeBuildSettingsScenes { get; set; } Property Value Type Description Boolean IncludeResourcesFolders If enabled, all assets in resources folders will have addresses generated during the build. Declaration public bool IncludeResourcesFolders { get; set; } Property Value Type Description Boolean Methods OnGUIMultiple(List<AddressableAssetGroupSchema>) Used to display the GUI of multiple selected groups. Declaration public override void OnGUIMultiple(List<AddressableAssetGroupSchema> otherSchemas) Parameters Type Name Description List < AddressableAssetGroupSchema > otherSchemas Schema instances in the other selected groups Overrides AddressableAssetGroupSchema.OnGUIMultiple(List<AddressableAssetGroupSchema>)"
  },
  "api/UnityEditor.AddressableAssets.Settings.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.html",
    "title": "Namespace UnityEditor.AddressableAssets.Settings | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEditor.AddressableAssets.Settings Classes AddressableAssetBuildSettings Build settings for addressables. AddressableAssetEntry Contains data for an addressable asset entry. AddressableAssetEntryCollection Contains a list of AddressableAssetEntries that can be included in the settings. The purpose of this class is to provide a way of combining entries from external sources such as packages into your project settings. AddressableAssetGroup Contains the collection of asset entries associated with this group. AddressableAssetGroupSchema Contains data for AddressableAssetGroups. AddressableAssetGroupSchemaSet Collection of AddressableAssetGroupSchema objects AddressableAssetGroupSchemaTemplate Contains a set of schemas used by the GUI to create predefined asset groups. AddressableAssetGroupTemplate Used to create template groups to make it easier for the user to create new groups. AddressableAssetProfileSettings Contains user defined variables to control build parameters. AddressableAssetSettings Contains editor data for the addressables system. CacheInitializationSettings Asset container for CacheInitializationData. KeyDataStore Contains serialized data in a generic serializable container. ProfileValueReference Used to store references to profile variables. This class is intended to be used for fields in user scripts, specifically ones that subclass AddressableAssetGroupSchema. ProjectConfigData The project configuration settings for addressables. Interfaces IGroupTemplate Stores information about a group template. Enums AddressableAssetSettings.ModificationEvent Options for labelling all the different generated events."
  },
  "api/UnityEditor.AddressableAssets.Settings.IGroupTemplate.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.IGroupTemplate.html",
    "title": "Interface IGroupTemplate | Addressables | 1.17.6-preview",
    "keywords": "Interface IGroupTemplate Stores information about a group template. Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IGroupTemplate Properties Description Description of the Template, to be used as a tooltip Declaration string Description { get; } Property Value Type Description String Name The name of the group, used for the menu and newly created group name. Declaration string Name { get; } Property Value Type Description String"
  },
  "api/UnityEditor.AddressableAssets.Settings.KeyDataStore.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.KeyDataStore.html",
    "title": "Class KeyDataStore | Addressables | 1.17.6-preview",
    "keywords": "Class KeyDataStore Contains serialized data in a generic serializable container. Inheritance Object KeyDataStore Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class KeyDataStore : ISerializationCallbackReceiver Properties Keys The collection of keys stored. Declaration public IEnumerable<string> Keys { get; } Property Value Type Description IEnumerable < String > OnSetData Delegate that is invoked when data is modified. Declaration public Action<string, object, bool> OnSetData { get; set; } Property Value Type Description Action < String , Object , Boolean > Methods GetData<T>(String, T, Boolean) Get data via a specified key. Declaration public T GetData<T>(string key, T defaultValue, bool addDefault = false) Parameters Type Name Description String key The key. T defaultValue The default value to return if the data is not found. Boolean addDefault Optional parameter to control whether to add the default value if the data is not found. Returns Type Description T Type Parameters Name Description T The data type. OnAfterDeserialize() Implementation of ISerializationCallbackReceiver interface, used to convert data from its serializable form. Declaration public void OnAfterDeserialize() Implements ISerializationCallbackReceiver.OnAfterDeserialize() OnBeforeSerialize() Implementation of ISerializationCallbackReceiver interface, used to convert data to a serializable form. Declaration public void OnBeforeSerialize() Implements ISerializationCallbackReceiver.OnBeforeSerialize() SetData(String, Object) Set the value of a specified key. Declaration public void SetData(string key, object data) Parameters Type Name Description String key The key. Object data The data to store. Supported types are strings, POD types, objects that have a static method named 'Parse' that convert a string to an object, and object that are serializable via JSONUtilty. SetDataFromString(String, String) Set data for a specified key from a string. Declaration public void SetDataFromString(string key, string data) Parameters Type Name Description String key The data key. String data The data string value."
  },
  "api/UnityEditor.AddressableAssets.Settings.ProfileValueReference.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.ProfileValueReference.html",
    "title": "Class ProfileValueReference | Addressables | 1.17.6-preview",
    "keywords": "Class ProfileValueReference Used to store references to profile variables. This class is intended to be used for fields in user scripts, specifically ones that subclass AddressableAssetGroupSchema. Inheritance Object ProfileValueReference Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class ProfileValueReference Fields OnValueChanged This delegate will be invoked when the reference profile id changes. This will NOT be invoked when the actual profile value itself changes. Declaration public Action<ProfileValueReference> OnValueChanged Field Value Type Description Action < ProfileValueReference > Properties Id Get the profile variable id. Declaration public string Id { get; } Property Value Type Description String Methods GetName(AddressableAssetSettings) Get the profile variable name that is referenced. Declaration public string GetName(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings The settings object. Returns Type Description String The name of the profile variable name. GetValue(AddressableAssetProfileSettings, String) Evaluate the profile value using the provided profile settings object and a profile id. Declaration public string GetValue(AddressableAssetProfileSettings profileSettings, string profileId) Parameters Type Name Description AddressableAssetProfileSettings profileSettings The profile settings object. String profileId The profile id. Returns Type Description String The evaluated string stored in the referenced profile variable. GetValue(AddressableAssetSettings) Evaluate the profile value using the provided settings object. Declaration public string GetValue(AddressableAssetSettings settings) Parameters Type Name Description AddressableAssetSettings settings The settings object to evaluate with. The activeProfileId will be used. Returns Type Description String The evaluated string stored in the referenced profile variable. SetVariableById(AddressableAssetSettings, String) Set the profile variable id using the id of the variable. Declaration public bool SetVariableById(AddressableAssetSettings settings, string id) Parameters Type Name Description AddressableAssetSettings settings The settings object. String id The id of the profile variable to set. Returns Type Description Boolean True if the profile data is found and set, false otherwise. SetVariableByName(AddressableAssetSettings, String) Set the profile variable id using the name of the variable. Declaration public bool SetVariableByName(AddressableAssetSettings settings, string name) Parameters Type Name Description AddressableAssetSettings settings The settings object. String name The name of the profile variable to set. Returns Type Description Boolean True if the profile data is found and set, false otherwise."
  },
  "api/UnityEditor.AddressableAssets.Settings.ProjectConfigData.html": {
    "href": "api/UnityEditor.AddressableAssets.Settings.ProjectConfigData.html",
    "title": "Class ProjectConfigData | Addressables | 1.17.6-preview",
    "keywords": "Class ProjectConfigData The project configuration settings for addressables. Inheritance Object ProjectConfigData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEditor.AddressableAssets.Settings <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ProjectConfigData Properties ActivePlayModeIndex The active play mode data builder index. Declaration public static int ActivePlayModeIndex { get; set; } Property Value Type Description Int32 GenerateBuildLayout Whether to generate the bundle build layout report. Declaration public static bool GenerateBuildLayout { get; set; } Property Value Type Description Boolean HierarchicalSearch Whether to allow searching for assets parsed hierarchally in the Addressables Groups window. Declaration public static bool HierarchicalSearch { get; set; } Property Value Type Description Boolean LocalLoadSpeed The local bundle loading speed used in the Simulate Groups (advanced) playmode. Declaration public static long LocalLoadSpeed { get; set; } Property Value Type Description Int64 PostProfilerEvents Whether to post profiler events in the ResourceManager profiler window. Declaration public static bool PostProfilerEvents { get; set; } Property Value Type Description Boolean RemoteLoadSpeed The remote bundle loading speed used in the Simulate Groups (advanced) playmode. Declaration public static long RemoteLoadSpeed { get; set; } Property Value Type Description Int64 ShowGroupsAsHierarchy Whether to display groups names parsed hierarchally in the Addressables Groups window. Declaration public static bool ShowGroupsAsHierarchy { get; set; } Property Value Type Description Boolean ShowSubObjectsInGroupView Whether to display sub objects in the Addressables Groups window. Declaration public static bool ShowSubObjectsInGroupView { get; set; } Property Value Type Description Boolean"
  },
  "api/UnityEngine.AddressableAssets.Addressables.html": {
    "href": "api/UnityEngine.AddressableAssets.Addressables.html",
    "title": "Class Addressables | Addressables | 1.17.6-preview",
    "keywords": "Class Addressables Entry point for Addressable API, this provides a simpler interface than using ResourceManager directly as it assumes string address type. Inheritance Object Addressables Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public static class Addressables Fields kAddressablesRuntimeBuildLogPath The name of the PlayerPrefs value used to set the path to check for build logs that need to be shown in the runtime. Declaration public const string kAddressablesRuntimeBuildLogPath = \"AddressablesRuntimeBuildLog\" Field Value Type Description String kAddressablesRuntimeDataPath The name of the PlayerPrefs value used to set the path to load the addressables runtime data file. Declaration public const string kAddressablesRuntimeDataPath = \"AddressablesRuntimeDataPath\" Field Value Type Description String Properties BuildPath The path used by the Addressables system for its initialization data. Declaration public static string BuildPath { get; } Property Value Type Description String InitializationOperation Initialization operation. You can register a callback with this if you need to run code after Addressables is ready. Any requests made before this operaton completes will automatically cahin to its result. Declaration [Obsolete] public static AsyncOperationHandle<IResourceLocator> InitializationOperation { get; } Property Value Type Description AsyncOperationHandle < IResourceLocator > InstanceProvider The Instance Provider used by the Addressables System. Declaration public static IInstanceProvider InstanceProvider { get; } Property Value Type Description IInstanceProvider InternalIdTransformFunc Functor to transform internal ids before being used by the providers. See the TransformInternalId documentation for more details. Declaration public static Func<IResourceLocation, string> InternalIdTransformFunc { get; set; } Property Value Type Description Func < IResourceLocation , String > PlayerBuildDataPath The path that addressables player data gets copied to during a player build. Declaration public static string PlayerBuildDataPath { get; } Property Value Type Description String ResourceLocators Gets the collection of configured IResourceLocator objects. Resource Locators are used to find IResourceLocation objects from user-defined typed keys. Declaration public static IEnumerable<IResourceLocator> ResourceLocators { get; } Property Value Type Description IEnumerable < IResourceLocator > The resource locators collection. ResourceManager Stores the ResourceManager associated with this Addressables instance. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager RuntimePath The path used by the Addressables system to load initialization data. Declaration public static string RuntimePath { get; } Property Value Type Description String StreamingAssetsSubFolder The subfolder used by the Addressables system for its initialization data. Declaration public static string StreamingAssetsSubFolder { get; } Property Value Type Description String Methods AddResourceLocator(IResourceLocator, String, IResourceLocation) Add a resource locator. Declaration public static void AddResourceLocator(IResourceLocator locator, string localCatalogHash = null, IResourceLocation remoteCatalogLocation = null) Parameters Type Name Description IResourceLocator locator The locator object. String localCatalogHash The hash of the local catalog. This can be null if the catalog cannot be updated. IResourceLocation remoteCatalogLocation The location of the remote catalog. This can be null if the catalog cannot be updated. CheckForCatalogUpdates(Boolean) Checks all updatable content catalogs for a new version. Declaration public static AsyncOperationHandle<List<string>> CheckForCatalogUpdates(bool autoReleaseHandle = true) Parameters Type Name Description Boolean autoReleaseHandle If true, the handle will automatically be released when the operation completes. Returns Type Description AsyncOperationHandle < List < String >> The operation containing the list of catalog ids that have an available update. This can be used to filter which catalogs to update with the UpdateContent. ClearDependencyCacheAsync(IList<Object>) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration [Obsolete] public static void ClearDependencyCacheAsync(IList<object> keys) Parameters Type Name Description IList < Object > keys The keys to clear the cache for. ClearDependencyCacheAsync(IList<Object>, Boolean) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration [Obsolete] public static AsyncOperationHandle<bool> ClearDependencyCacheAsync(IList<object> keys, bool autoReleaseHandle) Parameters Type Name Description IList < Object > keys The keys to clear the cache for. Boolean autoReleaseHandle If true, the returned AsyncOperationHandle will be released on completion. Returns Type Description AsyncOperationHandle < Boolean > The operation handle for the request. ClearDependencyCacheAsync(IList<IResourceLocation>) Clear the cached AssetBundles for a list of Addressable locations. Operation may be performed async if Addressables is initializing or updating. Declaration public static void ClearDependencyCacheAsync(IList<IResourceLocation> locations) Parameters Type Name Description IList < IResourceLocation > locations The locations to clear the cache for. ClearDependencyCacheAsync(IList<IResourceLocation>, Boolean) Clear the cached AssetBundles for a list of Addressable locations. Operation may be performed async if Addressables is initializing or updating. Declaration public static AsyncOperationHandle<bool> ClearDependencyCacheAsync(IList<IResourceLocation> locations, bool autoReleaseHandle) Parameters Type Name Description IList < IResourceLocation > locations The locations to clear the cache for. Boolean autoReleaseHandle If true, the returned AsyncOperationHandle will be released on completion. Returns Type Description AsyncOperationHandle < Boolean > The operation handle for the request. ClearDependencyCacheAsync(IEnumerable) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration public static void ClearDependencyCacheAsync(IEnumerable keys) Parameters Type Name Description IEnumerable keys The keys to clear the cache for. ClearDependencyCacheAsync(IEnumerable, Boolean) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration public static AsyncOperationHandle<bool> ClearDependencyCacheAsync(IEnumerable keys, bool autoReleaseHandle) Parameters Type Name Description IEnumerable keys The keys to clear the cache for. Boolean autoReleaseHandle If true, the returned AsyncOperationHandle will be released on completion. Returns Type Description AsyncOperationHandle < Boolean > The operation handle for the request. ClearDependencyCacheAsync(Object) Clear the cached AssetBundles for a given key. Operation may be performed async if Addressables is initializing or updating. Declaration public static void ClearDependencyCacheAsync(object key) Parameters Type Name Description Object key The key to clear the cache for. ClearDependencyCacheAsync(Object, Boolean) Clear the cached AssetBundles for a given key. Operation may be performed async if Addressables is initializing or updating. Declaration public static AsyncOperationHandle<bool> ClearDependencyCacheAsync(object key, bool autoReleaseHandle) Parameters Type Name Description Object key The key to clear the cache for. Boolean autoReleaseHandle If true, the returned AsyncOperationHandle will be released on completion. Returns Type Description AsyncOperationHandle < Boolean > The operation handle for the request. ClearDependencyCacheAsync(String) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration public static void ClearDependencyCacheAsync(string key) Parameters Type Name Description String key ClearDependencyCacheAsync(String, Boolean) Clear the cached AssetBundles for a list of Addressable keys. Operation may be performed async if Addressables is initializing or updating. Declaration public static AsyncOperationHandle<bool> ClearDependencyCacheAsync(string key, bool autoReleaseHandle) Parameters Type Name Description String key Boolean autoReleaseHandle If true, the returned AsyncOperationHandle will be released on completion. Returns Type Description AsyncOperationHandle < Boolean > The operation handle for the request. ClearResourceLocators() Remove all locators. Declaration public static void ClearResourceLocators() DownloadDependencies(Object) Downloads dependencies of assets marked with the specified label or address. Declaration [Obsolete] public static AsyncOperationHandle DownloadDependencies(object key) Parameters Type Name Description Object key The key of the asset(s) to load dependencies for. Returns Type Description AsyncOperationHandle The AsyncOperationHandle for the dependency load. DownloadDependenciesAsync(IList<Object>, Addressables.MergeMode, Boolean) Downloads dependencies of assets marked with the specified labels or addresses. See the DownloadDependenciesAsync documentation for more details. Declaration [Obsolete] public static AsyncOperationHandle DownloadDependenciesAsync(IList<object> keys, Addressables.MergeMode mode, bool autoReleaseHandle = false) Parameters Type Name Description IList < Object > keys List of keys for the locations. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Boolean autoReleaseHandle Automatically releases the handle on completion Returns Type Description AsyncOperationHandle The AsyncOperationHandle for the dependency load. DownloadDependenciesAsync(IList<IResourceLocation>, Boolean) Downloads dependencies of assets at given locations. See the DownloadDependenciesAsync documentation for more details. Declaration public static AsyncOperationHandle DownloadDependenciesAsync(IList<IResourceLocation> locations, bool autoReleaseHandle = false) Parameters Type Name Description IList < IResourceLocation > locations The locations of the assets. Boolean autoReleaseHandle Automatically releases the handle on completion Returns Type Description AsyncOperationHandle The AsyncOperationHandle for the dependency load. DownloadDependenciesAsync(IEnumerable, Addressables.MergeMode, Boolean) Downloads dependencies of assets marked with the specified labels or addresses. See the DownloadDependenciesAsync documentation for more details. Declaration public static AsyncOperationHandle DownloadDependenciesAsync(IEnumerable keys, Addressables.MergeMode mode, bool autoReleaseHandle = false) Parameters Type Name Description IEnumerable keys List of keys for the locations. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Boolean autoReleaseHandle Automatically releases the handle on completion Returns Type Description AsyncOperationHandle The AsyncOperationHandle for the dependency load. DownloadDependenciesAsync(Object, Boolean) Downloads dependencies of assets marked with the specified label or address. See the DownloadDependenciesAsync documentation for more details. Declaration public static AsyncOperationHandle DownloadDependenciesAsync(object key, bool autoReleaseHandle = false) Parameters Type Name Description Object key The key of the asset(s) to load dependencies for. Boolean autoReleaseHandle Automatically releases the handle on completion Returns Type Description AsyncOperationHandle The AsyncOperationHandle for the dependency load. GetDownloadSize(Object) Determines the required download size, dependencies included, for the specified key . Cached assets require no download and thus their download size will be 0. The Result of the operation is the download size in bytes. Declaration [Obsolete] public static AsyncOperationHandle<long> GetDownloadSize(object key) Parameters Type Name Description Object key The key of the asset(s) to get the download size of. Returns Type Description AsyncOperationHandle < Int64 > The operation handle for the request. GetDownloadSizeAsync(IList<Object>) Determines the required download size, dependencies included, for the specified keys . Cached assets require no download and thus their download size will be 0. The Result of the operation is the download size in bytes. Declaration [Obsolete] public static AsyncOperationHandle<long> GetDownloadSizeAsync(IList<object> keys) Parameters Type Name Description IList < Object > keys The keys of the asset(s) to get the download size of. Returns Type Description AsyncOperationHandle < Int64 > The operation handle for the request. GetDownloadSizeAsync(IEnumerable) Determines the required download size, dependencies included, for the specified keys . Cached assets require no download and thus their download size will be 0. The Result of the operation is the download size in bytes. Declaration public static AsyncOperationHandle<long> GetDownloadSizeAsync(IEnumerable keys) Parameters Type Name Description IEnumerable keys The keys of the asset(s) to get the download size of. Returns Type Description AsyncOperationHandle < Int64 > The operation handle for the request. GetDownloadSizeAsync(Object) Determines the required download size, dependencies included, for the specified key . Cached assets require no download and thus their download size will be 0. The Result of the operation is the download size in bytes. Declaration public static AsyncOperationHandle<long> GetDownloadSizeAsync(object key) Parameters Type Name Description Object key The key of the asset(s) to get the download size of. Returns Type Description AsyncOperationHandle < Int64 > The operation handle for the request. GetDownloadSizeAsync(String) Determines the required download size, dependencies included, for the specified key . Cached assets require no download and thus their download size will be 0. The Result of the operation is the download size in bytes. Declaration public static AsyncOperationHandle<long> GetDownloadSizeAsync(string key) Parameters Type Name Description String key The key of the asset(s) to get the download size of. Returns Type Description AsyncOperationHandle < Int64 > The operation handle for the request. Initialize() Initialize Addressables system. Addressables will be initialized on the first API call if this is not called explicitly. Declaration [Obsolete] public static AsyncOperationHandle<IResourceLocator> Initialize() Returns Type Description AsyncOperationHandle < IResourceLocator > The operation handle for the request. InitializeAsync() Initialize Addressables system. Addressables will be initialized on the first API call if this is not called explicitly. See the InitializeAsync documentation for more details. Declaration public static AsyncOperationHandle<IResourceLocator> InitializeAsync() Returns Type Description AsyncOperationHandle < IResourceLocator > The operation handle for the request. Instantiate(Object, InstantiationParameters, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(object key, InstantiationParameters instantiateParameters, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. InstantiationParameters instantiateParameters Parameters for instantiation. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. Instantiate(Object, Transform, Boolean, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(object key, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. Transform parent Parent transform for instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. Instantiate(Object, Vector3, Quaternion, Transform, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(object key, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. Vector3 position The position of the instantiated object. Quaternion rotation The rotation of the instantiated object. Transform parent Parent transform for instantiated object. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. Instantiate(IResourceLocation, InstantiationParameters, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(IResourceLocation location, InstantiationParameters instantiateParameters, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. InstantiationParameters instantiateParameters Parameters for instantiation. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. Instantiate(IResourceLocation, Transform, Boolean, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(IResourceLocation location, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. Transform parent Parent transform for instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. Instantiate(IResourceLocation, Vector3, Quaternion, Transform, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. Declaration [Obsolete] public static AsyncOperationHandle<GameObject> Instantiate(IResourceLocation location, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. Vector3 position The position of the instantiated object. Quaternion rotation The rotation of the instantiated object. Transform parent Parent transform for instantiated object. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(Object, InstantiationParameters, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(object key, InstantiationParameters instantiateParameters, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. InstantiationParameters instantiateParameters Parameters for instantiation. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(Object, Transform, Boolean, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(object key, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. Transform parent Parent transform for instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(Object, Vector3, Quaternion, Transform, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(object key, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) Parameters Type Name Description Object key The key of the location of the Object to instantiate. Vector3 position The position of the instantiated object. Quaternion rotation The rotation of the instantiated object. Transform parent Parent transform for instantiated object. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(IResourceLocation, InstantiationParameters, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, InstantiationParameters instantiateParameters, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. InstantiationParameters instantiateParameters Parameters for instantiation. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(IResourceLocation, Transform, Boolean, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. Transform parent Parent transform for instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. InstantiateAsync(IResourceLocation, Vector3, Quaternion, Transform, Boolean) Instantiate a single object. Note that the dependency loading is done asynchronously, but generally the actual instantiate is synchronous. See the InstantiateAsync documentation for more details. Declaration public static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) Parameters Type Name Description IResourceLocation location The location of the Object to instantiate. Vector3 position The position of the instantiated object. Quaternion rotation The rotation of the instantiated object. Transform parent Parent transform for instantiated object. Boolean trackHandle If true, Addressables will track this request to allow it to be released via the result object. Returns Type Description AsyncOperationHandle < GameObject > The operation handle for the request. LoadAsset<TObject>(Object) Load a single asset Declaration [Obsolete] public static AsyncOperationHandle<TObject> LoadAsset<TObject>(object key) Parameters Type Name Description Object key The key of the location of the asset. Returns Type Description AsyncOperationHandle <TObject> Returns the load operation. Type Parameters Name Description TObject The type of the asset. LoadAsset<TObject>(IResourceLocation) Load a single asset Declaration [Obsolete] public static AsyncOperationHandle<TObject> LoadAsset<TObject>(IResourceLocation location) Parameters Type Name Description IResourceLocation location The location of the asset. Returns Type Description AsyncOperationHandle <TObject> Returns the load operation. Type Parameters Name Description TObject The type of the asset. LoadAssetAsync<TObject>(Object) Load a single asset See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<TObject> LoadAssetAsync<TObject>(object key) Parameters Type Name Description Object key The key of the location of the asset. Returns Type Description AsyncOperationHandle <TObject> Returns the load operation. Type Parameters Name Description TObject The type of the asset. LoadAssetAsync<TObject>(IResourceLocation) Load a single asset See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<TObject> LoadAssetAsync<TObject>(IResourceLocation location) Parameters Type Name Description IResourceLocation location The location of the asset. Returns Type Description AsyncOperationHandle <TObject> Returns the load operation. Type Parameters Name Description TObject The type of the asset. LoadAssets<TObject>(IList<Object>, Action<TObject>, Addressables.MergeMode) Load mutliple assets Declaration [Obsolete] public static AsyncOperationHandle<IList<TObject>> LoadAssets<TObject>(IList<object> keys, Action<TObject> callback, Addressables.MergeMode mode) Parameters Type Name Description IList < Object > keys List of keys for the locations. Action <TObject> callback Callback Action that is called per load operation. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssets<TObject>(IList<IResourceLocation>, Action<TObject>) Load multiple assets Declaration [Obsolete] public static AsyncOperationHandle<IList<TObject>> LoadAssets<TObject>(IList<IResourceLocation> locations, Action<TObject> callback) Parameters Type Name Description IList < IResourceLocation > locations The locations of the assets. Action <TObject> callback Callback Action that is called per load operation. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssets<TObject>(Object, Action<TObject>) Load mutliple assets See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public static AsyncOperationHandle<IList<TObject>> LoadAssets<TObject>(object key, Action<TObject> callback) Parameters Type Name Description Object key Key for the locations. Action <TObject> callback Callback Action that is called per load operation. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(IList<Object>, Action<TObject>, Addressables.MergeMode) Load multiple assets. Each key in the provided list will be translated into a list of locations. Those many lists will be combined down to one based on the provided MergeMode. If any locations from the final list fail, all successful loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IList<object> keys, Action<TObject> callback, Addressables.MergeMode mode) Parameters Type Name Description IList < Object > keys List of keys for the locations. Action <TObject> callback Callback Action that is called per load operation. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(IList<Object>, Action<TObject>, Addressables.MergeMode, Boolean) Load multiple assets. Each key in the provided list will be translated into a list of locations. Those many lists will be combined down to one based on the provided MergeMode. See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IList<object> keys, Action<TObject> callback, Addressables.MergeMode mode, bool releaseDependenciesOnFailure) Parameters Type Name Description IList < Object > keys IEnumerable set of keys for the locations. Action <TObject> callback Callback Action that is called per load operation. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Boolean releaseDependenciesOnFailure If all matching locations succeed, this parameter is ignored. When true, if any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. When false, if any matching location fails, the returned .Result will be an IList of size equal to the number of locations attempted. Any failed location will correlate to a null in the IList, while successful loads will correlate to a TObject in the list. The .Status will still be Failed. When true, op does not need to be released if anything fails, when false, it must always be released. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject LoadAssetsAsync<TObject>(IList<IResourceLocation>, Action<TObject>) Load multiple assets, based on list of locations provided. If any fail, all successful loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IList<IResourceLocation> locations, Action<TObject> callback) Parameters Type Name Description IList < IResourceLocation > locations The locations of the assets. Action <TObject> callback Callback Action that is called per load operation. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(IList<IResourceLocation>, Action<TObject>, Boolean) Load multiple assets, based on list of locations provided. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IList<IResourceLocation> locations, Action<TObject> callback, bool releaseDependenciesOnFailure) Parameters Type Name Description IList < IResourceLocation > locations The locations of the assets. Action <TObject> callback Callback Action that is called per load operation. Boolean releaseDependenciesOnFailure If all matching locations succeed, this parameter is ignored. When true, if any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. When false, if any matching location fails, the returned .Result will be an IList of size equal to the number of locations attempted. Any failed location will correlate to a null in the IList, while successful loads will correlate to a TObject in the list. The .Status will still be Failed. When true, op does not need to be released if anything fails, when false, it must always be released. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(IEnumerable, Action<TObject>, Addressables.MergeMode) Load multiple assets. Each key in the provided list will be translated into a list of locations. Those many lists will be combined down to one based on the provided MergeMode. If any locations from the final list fail, all successful loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IEnumerable keys, Action<TObject> callback, Addressables.MergeMode mode) Parameters Type Name Description IEnumerable keys List of keys for the locations. Action <TObject> callback Callback Action that is called per load operation. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(IEnumerable, Action<TObject>, Addressables.MergeMode, Boolean) Load multiple assets. Each key in the provided list will be translated into a list of locations. Those many lists will be combined down to one based on the provided MergeMode. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IEnumerable keys, Action<TObject> callback, Addressables.MergeMode mode, bool releaseDependenciesOnFailure) Parameters Type Name Description IEnumerable keys IEnumerable set of keys for the locations. Action <TObject> callback Callback Action that is called per load operation. Addressables.MergeMode mode Method for merging the results of key matches. See Addressables.MergeMode for specifics Boolean releaseDependenciesOnFailure If all matching locations succeed, this parameter is ignored. When true, if any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. When false, if any matching location fails, the returned .Result will be an IList of size equal to the number of locations attempted. Any failed location will correlate to a null in the IList, while successful loads will correlate to a TObject in the list. The .Status will still be Failed. When true, op does not need to be released if anything fails, when false, it must always be released. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject LoadAssetsAsync<TObject>(Object, Action<TObject>) Load all assets that match the provided key. If any fail, all successful loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(object key, Action<TObject> callback) Parameters Type Name Description Object key Key for the locations. Action <TObject> callback Callback Action that is called per load operation (per loaded asset). Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadAssetsAsync<TObject>(Object, Action<TObject>, Boolean) Load all assets that match the provided key. See the Loading Addressable Assets documentation for more details. Declaration public static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(object key, Action<TObject> callback, bool releaseDependenciesOnFailure) Parameters Type Name Description Object key Key for the locations. Action <TObject> callback Callback Action that is called per load operation (per loaded asset). Boolean releaseDependenciesOnFailure If all matching locations succeed, this parameter is ignored. When true, if any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. When false, if any matching location fails, the returned .Result will be an IList of size equal to the number of locations attempted. Any failed location will correlate to a null in the IList, while successful loads will correlate to a TObject in the list. The .Status will still be Failed. When true, op does not need to be released if anything fails, when false, it must always be released. Returns Type Description AsyncOperationHandle < IList <TObject>> The operation handle for the request. Type Parameters Name Description TObject The type of the assets. LoadContentCatalog(String, String) Additively load catalogs from runtime data. The settings are not used. Declaration [Obsolete] public static AsyncOperationHandle<IResourceLocator> LoadContentCatalog(string catalogPath, string providerSuffix = null) Parameters Type Name Description String catalogPath The path to the runtime data. String providerSuffix This value, if not null or empty, will be appended to all provider ids loaded from this data. Returns Type Description AsyncOperationHandle < IResourceLocator > The operation handle for the request. LoadContentCatalogAsync(String, Boolean, String) Additively load catalogs from runtime data. In order for content catalog caching to work properly the catalog json file should have a .hash file associated with the catalog. This hash file will be used to determine if the catalog needs to be updated or not. If no .hash file is provided, the catalog will be loaded from the specified path every time. See the LoadContentCatalogAsync documentation for more details. Declaration public static AsyncOperationHandle<IResourceLocator> LoadContentCatalogAsync(string catalogPath, bool autoReleaseHandle, string providerSuffix = null) Parameters Type Name Description String catalogPath The path to the runtime data. Boolean autoReleaseHandle If true, the async operation handle will be automatically released on completion. String providerSuffix This value, if not null or empty, will be appended to all provider ids loaded from this data. Returns Type Description AsyncOperationHandle < IResourceLocator > The operation handle for the request. LoadContentCatalogAsync(String, String) Additively load catalogs from runtime data. In order for content catalog caching to work properly the catalog json file should have a .hash file associated with the catalog. This hash file will be used to determine if the catalog needs to be updated or not. If no .hash file is provided, the catalog will be loaded from the specified path every time. See the LoadContentCatalogAsync documentation for more details. Declaration public static AsyncOperationHandle<IResourceLocator> LoadContentCatalogAsync(string catalogPath, string providerSuffix = null) Parameters Type Name Description String catalogPath The path to the runtime data. String providerSuffix This value, if not null or empty, will be appended to all provider ids loaded from this data. Returns Type Description AsyncOperationHandle < IResourceLocator > The operation handle for the request. LoadResourceLocations(IList<Object>, Addressables.MergeMode, Type) Loads the resource locations specified by the keys. The method will always return success, with a valid IList of results. If nothing matches keys, IList will be empty Declaration [Obsolete] public static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocations(IList<object> keys, Addressables.MergeMode mode, Type type = null) Parameters Type Name Description IList < Object > keys The set of keys to use. Addressables.MergeMode mode The mode for merging the results of the found locations. Type type A type restriction for the lookup. Only locations of the provided type (or derived type) will be returned. Returns Type Description AsyncOperationHandle < IList < IResourceLocation >> The operation handle for the request. LoadResourceLocations(Object, Type) Request the locations for a given key. The method will always return success, with a valid IList of results. If nothing matches key, IList will be empty Declaration [Obsolete] public static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocations(object key, Type type = null) Parameters Type Name Description Object key The key for the locations. Type type A type restriction for the lookup. Only locations of the provided type (or derived type) will be returned. Returns Type Description AsyncOperationHandle < IList < IResourceLocation >> The operation handle for the request. LoadResourceLocationsAsync(IList<Object>, Addressables.MergeMode, Type) Loads the resource locations specified by the keys. The method will always return success, with a valid IList of results. If nothing matches keys, IList will be empty See the LoadResourceLocations documentation for more details. Declaration [Obsolete] public static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(IList<object> keys, Addressables.MergeMode mode, Type type = null) Parameters Type Name Description IList < Object > keys The set of keys to use. Addressables.MergeMode mode The mode for merging the results of the found locations. Type type A type restriction for the lookup. Only locations of the provided type (or derived type) will be returned. Returns Type Description AsyncOperationHandle < IList < IResourceLocation >> The operation handle for the request. LoadResourceLocationsAsync(IEnumerable, Addressables.MergeMode, Type) Loads the resource locations specified by the keys. The method will always return success, with a valid IList of results. If nothing matches keys, IList will be empty See the LoadResourceLocations documentation for more details. Declaration public static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(IEnumerable keys, Addressables.MergeMode mode, Type type = null) Parameters Type Name Description IEnumerable keys The set of keys to use. Addressables.MergeMode mode The mode for merging the results of the found locations. Type type A type restriction for the lookup. Only locations of the provided type (or derived type) will be returned. Returns Type Description AsyncOperationHandle < IList < IResourceLocation >> The operation handle for the request. LoadResourceLocationsAsync(Object, Type) Request the locations for a given key. The method will always return success, with a valid IList of results. If nothing matches key, IList will be empty See the LoadResourceLocations documentation for more details. Declaration public static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(object key, Type type = null) Parameters Type Name Description Object key The key for the locations. Type type A type restriction for the lookup. Only locations of the provided type (or derived type) will be returned. Returns Type Description AsyncOperationHandle < IList < IResourceLocation >> The operation handle for the request. LoadScene(Object, LoadSceneMode, Boolean, Int32) Load scene. Declaration [Obsolete] public static AsyncOperationHandle<SceneInstance> LoadScene(object key, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Parameters Type Name Description Object key The key of the location of the scene to load. LoadSceneMode loadMode Scene load mode. Boolean activateOnLoad If false, the scene will load but not activate (for background loading). The SceneInstance returned has an Activate() method that can be called to do this at a later point. Int32 priority Async operation priority for scene loading. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. LoadScene(IResourceLocation, LoadSceneMode, Boolean, Int32) Load scene. Declaration [Obsolete] public static AsyncOperationHandle<SceneInstance> LoadScene(IResourceLocation location, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Parameters Type Name Description IResourceLocation location The location of the scene to load. LoadSceneMode loadMode Scene load mode. Boolean activateOnLoad If false, the scene will load but not activate (for background loading). The SceneInstance returned has an Activate() method that can be called to do this at a later point. Int32 priority Async operation priority for scene loading. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. LoadSceneAsync(Object, LoadSceneMode, Boolean, Int32) Load scene. See the LoadSceneAsync documentation for more details. Declaration public static AsyncOperationHandle<SceneInstance> LoadSceneAsync(object key, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Parameters Type Name Description Object key The key of the location of the scene to load. LoadSceneMode loadMode Scene load mode. Boolean activateOnLoad If false, the scene will load but not activate (for background loading). The SceneInstance returned has an Activate() method that can be called to do this at a later point. Int32 priority Async operation priority for scene loading. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. LoadSceneAsync(IResourceLocation, LoadSceneMode, Boolean, Int32) Load scene. See the LoadSceneAsync documentation for more details. Declaration public static AsyncOperationHandle<SceneInstance> LoadSceneAsync(IResourceLocation location, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Parameters Type Name Description IResourceLocation location The location of the scene to load. LoadSceneMode loadMode Scene load mode. Boolean activateOnLoad If false, the scene will load but not activate (for background loading). The SceneInstance returned has an Activate() method that can be called to do this at a later point. Int32 priority Async operation priority for scene loading. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. Log(String) Debug.Log wrapper method that is contional on the ADDRESSABLES_LOG_ALL symbol definition. This can be set in the Player preferences in the 'Scripting Define Symbols'. Declaration [Conditional(\"ADDRESSABLES_LOG_ALL\")] public static void Log(string msg) Parameters Type Name Description String msg The msg to log LogError(String) Debug.LogError wrapper method. Declaration public static void LogError(string msg) Parameters Type Name Description String msg The msg to log LogErrorFormat(String, Object[]) Debug.LogErrorFormat wrapper method. Declaration public static void LogErrorFormat(string format, params object[] args) Parameters Type Name Description String format The string with format tags. Object [] args The args used to fill in the format tags. LogException(AsyncOperationHandle, Exception) Debug.LogException wrapper method. Declaration public static void LogException(AsyncOperationHandle op, Exception ex) Parameters Type Name Description AsyncOperationHandle op The operation handle. Exception ex The exception. LogFormat(String, Object[]) Debug.LogFormat wrapper method that is contional on the ADDRESSABLES_LOG_ALL symbol definition. This can be set in the Player preferences in the 'Scripting Define Symbols'. Declaration [Conditional(\"ADDRESSABLES_LOG_ALL\")] public static void LogFormat(string format, params object[] args) Parameters Type Name Description String format The string with format tags. Object [] args The args used to fill in the format tags. LogWarning(String) Debug.LogWarning wrapper method. Declaration public static void LogWarning(string msg) Parameters Type Name Description String msg The msg to log LogWarningFormat(String, Object[]) Debug.LogWarningFormat wrapper method. Declaration public static void LogWarningFormat(string format, params object[] args) Parameters Type Name Description String format The string with format tags. Object [] args The args used to fill in the format tags. Release(AsyncOperationHandle) Release the operation and its associated resources. Declaration public static void Release(AsyncOperationHandle handle) Parameters Type Name Description AsyncOperationHandle handle The operation handle to release. Release<TObject>(TObject) Release asset. Declaration public static void Release<TObject>(TObject obj) Parameters Type Name Description TObject obj The asset to release. Type Parameters Name Description TObject The type of the object being released Release<TObject>(AsyncOperationHandle<TObject>) Release the operation and its associated resources. Declaration public static void Release<TObject>(AsyncOperationHandle<TObject> handle) Parameters Type Name Description AsyncOperationHandle <TObject> handle The operation handle to release. Type Parameters Name Description TObject The type of the AsyncOperationHandle being released ReleaseInstance(GameObject) Releases and destroys an object that was created via Addressables.InstantiateAsync. Declaration public static bool ReleaseInstance(GameObject instance) Parameters Type Name Description GameObject instance The GameObject instance to be released and destroyed. Returns Type Description Boolean Returns true if the instance was successfully released. ReleaseInstance(AsyncOperationHandle) Releases and destroys an object that was created via Addressables.InstantiateAsync. Declaration public static bool ReleaseInstance(AsyncOperationHandle handle) Parameters Type Name Description AsyncOperationHandle handle The handle to the game object to destroy, that was returned by InstantiateAsync. Returns Type Description Boolean Returns true if the instance was successfully released. ReleaseInstance(AsyncOperationHandle<GameObject>) Releases and destroys an object that was created via Addressables.InstantiateAsync. Declaration public static bool ReleaseInstance(AsyncOperationHandle<GameObject> handle) Parameters Type Name Description AsyncOperationHandle < GameObject > handle The handle to the game object to destroy, that was returned by InstantiateAsync. Returns Type Description Boolean Returns true if the instance was successfully released. RemoveResourceLocator(IResourceLocator) Remove a locator; Declaration public static void RemoveResourceLocator(IResourceLocator locator) Parameters Type Name Description IResourceLocator locator The locator to remove. ResolveInternalId(String) Used to resolve a string using addressables config values Declaration public static string ResolveInternalId(string id) Parameters Type Name Description String id The internal id to resolve. Returns Type Description String Returns the string that the internal id represents. UnloadScene(AsyncOperationHandle, Boolean) Release scene Declaration [Obsolete] public static AsyncOperationHandle<SceneInstance> UnloadScene(AsyncOperationHandle handle, bool autoReleaseHandle = true) Parameters Type Name Description AsyncOperationHandle handle The handle returned by LoadSceneAsync for the scene to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UnloadScene(AsyncOperationHandle<SceneInstance>, Boolean) Release scene Declaration [Obsolete] public static AsyncOperationHandle<SceneInstance> UnloadScene(AsyncOperationHandle<SceneInstance> handle, bool autoReleaseHandle = true) Parameters Type Name Description AsyncOperationHandle < SceneInstance > handle The handle returned by LoadSceneAsync for the scene to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UnloadScene(SceneInstance, Boolean) Release scene Declaration [Obsolete] public static AsyncOperationHandle<SceneInstance> UnloadScene(SceneInstance scene, bool autoReleaseHandle = true) Parameters Type Name Description SceneInstance scene The SceneInstance to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UnloadSceneAsync(AsyncOperationHandle, Boolean) Release scene Declaration public static AsyncOperationHandle<SceneInstance> UnloadSceneAsync(AsyncOperationHandle handle, bool autoReleaseHandle = true) Parameters Type Name Description AsyncOperationHandle handle The handle returned by LoadSceneAsync for the scene to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UnloadSceneAsync(AsyncOperationHandle<SceneInstance>, Boolean) Release scene Declaration public static AsyncOperationHandle<SceneInstance> UnloadSceneAsync(AsyncOperationHandle<SceneInstance> handle, bool autoReleaseHandle = true) Parameters Type Name Description AsyncOperationHandle < SceneInstance > handle The handle returned by LoadSceneAsync for the scene to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UnloadSceneAsync(SceneInstance, Boolean) Release scene Declaration public static AsyncOperationHandle<SceneInstance> UnloadSceneAsync(SceneInstance scene, bool autoReleaseHandle = true) Parameters Type Name Description SceneInstance scene The SceneInstance to release. Boolean autoReleaseHandle If true, the handle will be released automatically when complete. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request. UpdateCatalogs(IEnumerable<String>, Boolean) Update the specified catalogs. See the UpdateCatalogs documentation for more details. Declaration public static AsyncOperationHandle<List<IResourceLocator>> UpdateCatalogs(IEnumerable<string> catalogs = null, bool autoReleaseHandle = true) Parameters Type Name Description IEnumerable < String > catalogs The set of catalogs to update. If null, all catalogs that have an available update will be updated. Boolean autoReleaseHandle If true, the handle will automatically be released when the operation completes. Returns Type Description AsyncOperationHandle < List < IResourceLocator >> The operation with the list of updated content catalog data."
  },
  "api/UnityEngine.AddressableAssets.Addressables.MergeMode.html": {
    "href": "api/UnityEngine.AddressableAssets.Addressables.MergeMode.html",
    "title": "Enum Addressables.MergeMode | Addressables | 1.17.6-preview",
    "keywords": "Enum Addressables.MergeMode Options for merging the results of requests. If keys (A, B) mapped to results ([1,2,4],[3,4,5])... UseFirst (or None) takes the results from the first key -- [1,2,4] Union takes results of each key and collects items that matched any key. -- [1,2,3,4,5] Intersection takes results of each key, and collects items that matched every key. -- [4] Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum MergeMode Fields Name Description Value None Use to indicate that no merge should occur. The first set of results will be used. 0 UseFirst Use to indicate that the merge should take the first set of results. 0 Union Use to indicate that the merge should take the union of the results. 1 Intersection Use to indicate that the merge should take the intersection of the results. 2"
  },
  "api/UnityEngine.AddressableAssets.AddressablesPlatform.html": {
    "href": "api/UnityEngine.AddressableAssets.AddressablesPlatform.html",
    "title": "Enum AddressablesPlatform | Addressables | 1.17.6-preview",
    "keywords": "Enum AddressablesPlatform Options for the Addressables build platform. Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum AddressablesPlatform Fields Name Description Value Unknown Use to indicate that the build platform is unknown. 0 Windows Use to indicate that the build platform is Windows. 1 OSX Use to indicate that the build platform is OSX. 2 Linux Use to indicate that the build platform is Linux. 3 PS4 Use to indicate that the build platform is PS4. 4 Switch Use to indicate that the build platform is PS4. 5 XboxOne Use to indicate that the build platform is XboxOne. 6 WebGL Use to indicate that the build platform is WebGL. 7 iOS Use to indicate that the build platform is iOS. 8 Android Use to indicate that the build platform is Android. 9 WindowsUniversal Use to indicate that the build platform is WindowsUniversal. 10"
  },
  "api/UnityEngine.AddressableAssets.AssetLabelReference.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetLabelReference.html",
    "title": "Class AssetLabelReference | Addressables | 1.17.6-preview",
    "keywords": "Class AssetLabelReference Reference to an asset label. This class can be used in scripts as a field and will use a CustomPropertyDrawer to provide a DropDown UI of available labels. Inheritance Object AssetLabelReference Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetLabelReference : IKeyEvaluator Properties labelString The label string. Declaration public string labelString { get; set; } Property Value Type Description String RuntimeKey The runtime key used for indexing values in the Addressables system. Declaration public object RuntimeKey { get; } Property Value Type Description Object Implements IKeyEvaluator.RuntimeKey Methods GetHashCode() Get the hash code of this object. Declaration public override int GetHashCode() Returns Type Description Int32 The hash code of the label string. Overrides Object.GetHashCode() RuntimeKeyIsValid() Checks if the current RuntimeKey is valid. Declaration public bool RuntimeKeyIsValid() Returns Type Description Boolean Whether the RuntimeKey is valid or not. Implements IKeyEvaluator.RuntimeKeyIsValid()"
  },
  "api/UnityEngine.AddressableAssets.AssetReference.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReference.html",
    "title": "Class AssetReference | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReference Reference to an addressable asset. This can be used in script to provide fields that can be easily set in the editor and loaded dynamically at runtime. To determine if the reference is set, use RuntimeKeyIsValid(). Inheritance Object AssetReference AssetReferenceT<TObject> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReference : IKeyEvaluator Constructors AssetReference() Construct a new AssetReference object. Declaration public AssetReference() AssetReference(String) Construct a new AssetReference object. Declaration public AssetReference(string guid) Parameters Type Name Description String guid The guid of the asset. Properties Asset The loaded asset. This value is only set after the AsyncOperationHandle returned from LoadAssetAsync completes. It will not be set if only InstantiateAsync is called. It will be set to null if release is called. Declaration public virtual Object Asset { get; } Property Value Type Description Object AssetGUID Stores the guid of the asset. Declaration public virtual string AssetGUID { get; } Property Value Type Description String IsDone Get the loading status of the internal operation. Declaration public bool IsDone { get; } Property Value Type Description Boolean OperationHandle The AsyncOperationHandle currently being used by the AssetReference. For example, if you call AssetReference.LoadAssetAsync, this property will return a handle to that operation. Declaration public AsyncOperationHandle OperationHandle { get; } Property Value Type Description AsyncOperationHandle RuntimeKey The actual key used to request the asset at runtime. RuntimeKeyIsValid() can be used to determine if this reference was set. Declaration public virtual object RuntimeKey { get; } Property Value Type Description Object Implements IKeyEvaluator.RuntimeKey SubObjectName Stores the name of the sub object. Declaration public virtual string SubObjectName { get; set; } Property Value Type Description String Methods Instantiate(Transform, Boolean) InstantiateAsync the referenced asset as type TObject. This cannot be used a second time until the first load is released. If you wish to call load multiple times on an AssetReference, use Addressables.InstantiateAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public AsyncOperationHandle<GameObject> Instantiate(Transform parent = null, bool instantiateInWorldSpace = false) Parameters Type Name Description Transform parent The parent of the instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Returns Type Description AsyncOperationHandle < GameObject > Returns the instantiation operation. Instantiate(Vector3, Quaternion, Transform) InstantiateAsync the referenced asset as type TObject. This cannot be used a second time until the first load is released. If you wish to call load multiple times on an AssetReference, use Addressables.InstantiateAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public AsyncOperationHandle<GameObject> Instantiate(Vector3 position, Quaternion rotation, Transform parent = null) Parameters Type Name Description Vector3 position Position of the instantiated object. Quaternion rotation Rotation of the instantiated object. Transform parent The parent of the instantiated object. Returns Type Description AsyncOperationHandle < GameObject > Returns the instantiation operation. InstantiateAsync(Transform, Boolean) InstantiateAsync the referenced asset as type TObject. This cannot be used a second time until the first load is released. If you wish to call load multiple times on an AssetReference, use Addressables.InstantiateAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration public virtual AsyncOperationHandle<GameObject> InstantiateAsync(Transform parent = null, bool instantiateInWorldSpace = false) Parameters Type Name Description Transform parent The parent of the instantiated object. Boolean instantiateInWorldSpace Option to retain world space when instantiated with a parent. Returns Type Description AsyncOperationHandle < GameObject > InstantiateAsync(Vector3, Quaternion, Transform) InstantiateAsync the referenced asset as type TObject. This cannot be used a second time until the first load is released. If you wish to call load multiple times on an AssetReference, use Addressables.InstantiateAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration public virtual AsyncOperationHandle<GameObject> InstantiateAsync(Vector3 position, Quaternion rotation, Transform parent = null) Parameters Type Name Description Vector3 position Position of the instantiated object. Quaternion rotation Rotation of the instantiated object. Transform parent The parent of the instantiated object. Returns Type Description AsyncOperationHandle < GameObject > IsValid() Returns the state of the internal operation. Declaration public bool IsValid() Returns Type Description Boolean True if the operation is valid. LoadAsset<TObject>() Declaration [Obsolete] public AsyncOperationHandle<TObject> LoadAsset<TObject>() Returns Type Description AsyncOperationHandle <TObject> Type Parameters Name Description TObject LoadAssetAsync<TObject>() Declaration public virtual AsyncOperationHandle<TObject> LoadAssetAsync<TObject>() Returns Type Description AsyncOperationHandle <TObject> Type Parameters Name Description TObject LoadScene() Loads the reference as a scene. This cannot be used a second time until the first load is released. If you wish to call load multiple times on an AssetReference, use Addressables.LoadSceneAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration [Obsolete] public AsyncOperationHandle<SceneInstance> LoadScene() Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the scene load. LoadSceneAsync(LoadSceneMode, Boolean, Int32) Loads the reference as a scene. This cannot be used a second time until the first load is unloaded. If you wish to call load multiple times on an AssetReference, use Addressables.LoadSceneAsync() and pass your AssetReference in as the key. See the Loading Addressable Assets documentation for more details. Declaration public virtual AsyncOperationHandle<SceneInstance> LoadSceneAsync(LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Parameters Type Name Description LoadSceneMode loadMode Scene load mode. Boolean activateOnLoad If false, the scene will load but not activate (for background loading). The SceneInstance returned has an Activate() method that can be called to do this at a later point. Int32 priority Async operation priority for scene loading. Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the request if there is not a valid cached operation, otherwise return default operation ReleaseAsset() Release the internal operation handle. Declaration public virtual void ReleaseAsset() ReleaseInstance(GameObject) Release an instantiated object. Declaration public virtual void ReleaseInstance(GameObject obj) Parameters Type Name Description GameObject obj The object to release. RuntimeKeyIsValid() Checks if the current RuntimeKey is valid. Declaration public virtual bool RuntimeKeyIsValid() Returns Type Description Boolean Whether the RuntimeKey is valid or not. Implements IKeyEvaluator.RuntimeKeyIsValid() ToString() String representation of asset reference. Declaration public override string ToString() Returns Type Description String The asset guid as a string. Overrides Object.ToString() UnLoadScene() Unloads the reference as a scene. Declaration public virtual AsyncOperationHandle<SceneInstance> UnLoadScene() Returns Type Description AsyncOperationHandle < SceneInstance > The operation handle for the scene load. ValidateAsset(String) Validates that the referenced asset allowable for this asset reference. Declaration public virtual bool ValidateAsset(string path) Parameters Type Name Description String path The path to the asset in question. Returns Type Description Boolean Whether the referenced asset is valid. ValidateAsset(Object) Validates that the referenced asset allowable for this asset reference. Declaration public virtual bool ValidateAsset(Object obj) Parameters Type Name Description Object obj The Object to validate. Returns Type Description Boolean Whether the referenced asset is valid."
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceAtlasedSprite.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceAtlasedSprite.html",
    "title": "Class AssetReferenceAtlasedSprite | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceAtlasedSprite Assetreference that only allows atlassed sprites. Inheritance Object AssetReference AssetReferenceT < Sprite > AssetReferenceAtlasedSprite Inherited Members AssetReferenceT<Sprite>.LoadAsset() AssetReferenceT<Sprite>.LoadAssetAsync() AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceAtlasedSprite : AssetReferenceT<Sprite>, IKeyEvaluator Constructors AssetReferenceAtlasedSprite(String) Constructs a new reference to a AssetReferenceAtlasedSprite. Declaration public AssetReferenceAtlasedSprite(string guid) Parameters Type Name Description String guid The object guid. Methods ValidateAsset(String) Validates that the asset located at a path is allowable for this asset reference. An asset is allowable if it is of the correct type or if one of its sub-asset is. Declaration public override bool ValidateAsset(string path) Parameters Type Name Description String path Returns Type Description Boolean Whether the referenced asset is valid. Overrides UnityEngine.AddressableAssets.AssetReferenceT<UnityEngine.Sprite>.ValidateAsset(System.String) ValidateAsset(Object) Validates that the referenced asset allowable for this asset reference. Declaration public override bool ValidateAsset(Object obj) Parameters Type Name Description Object obj The Object to validate. Returns Type Description Boolean Whether the referenced asset is valid. Overrides UnityEngine.AddressableAssets.AssetReferenceT<UnityEngine.Sprite>.ValidateAsset(UnityEngine.Object)"
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceGameObject.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceGameObject.html",
    "title": "Class AssetReferenceGameObject | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceGameObject GameObject only asset reference. Inheritance Object AssetReference AssetReferenceT < GameObject > AssetReferenceGameObject Inherited Members AssetReferenceT<GameObject>.LoadAsset() AssetReferenceT<GameObject>.LoadAssetAsync() AssetReferenceT<GameObject>.ValidateAsset(Object) AssetReferenceT<GameObject>.ValidateAsset(String) AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceGameObject : AssetReferenceT<GameObject>, IKeyEvaluator Constructors AssetReferenceGameObject(String) Constructs a new reference to a GameObject. Declaration public AssetReferenceGameObject(string guid) Parameters Type Name Description String guid The object guid."
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceSprite.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceSprite.html",
    "title": "Class AssetReferenceSprite | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceSprite Sprite only asset reference. Inheritance Object AssetReference AssetReferenceT < Sprite > AssetReferenceSprite Inherited Members AssetReferenceT<Sprite>.LoadAsset() AssetReferenceT<Sprite>.LoadAssetAsync() AssetReferenceT<Sprite>.ValidateAsset(Object) AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceSprite : AssetReferenceT<Sprite>, IKeyEvaluator Constructors AssetReferenceSprite(String) Constructs a new reference to a AssetReferenceSprite. Declaration public AssetReferenceSprite(string guid) Parameters Type Name Description String guid The object guid. Methods ValidateAsset(String) Validates that the asset located at a path is allowable for this asset reference. An asset is allowable if it is of the correct type or if one of its sub-asset is. Declaration public override bool ValidateAsset(string path) Parameters Type Name Description String path Returns Type Description Boolean Whether the referenced asset is valid. Overrides UnityEngine.AddressableAssets.AssetReferenceT<UnityEngine.Sprite>.ValidateAsset(System.String)"
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceT-1.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceT-1.html",
    "title": "Class AssetReferenceT<TObject> | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceT<TObject> Generic version of AssetReference class. This should not be used directly as CustomPropertyDrawers do not support generic types. Instead use the concrete derived classes such as AssetReferenceGameObject. Inheritance Object AssetReference AssetReferenceT<TObject> AssetReferenceAtlasedSprite AssetReferenceGameObject AssetReferenceSprite AssetReferenceTexture AssetReferenceTexture2D AssetReferenceTexture3D Inherited Members AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceT<TObject> : AssetReference, IKeyEvaluator where TObject : Object Type Parameters Name Description TObject Constructors AssetReferenceT(String) Construct a new AssetReference object. Declaration public AssetReferenceT(string guid) Parameters Type Name Description String guid The guid of the asset. Methods LoadAsset() Declaration [Obsolete] public AsyncOperationHandle<TObject> LoadAsset() Returns Type Description AsyncOperationHandle <TObject> LoadAssetAsync() Declaration public virtual AsyncOperationHandle<TObject> LoadAssetAsync() Returns Type Description AsyncOperationHandle <TObject> ValidateAsset(String) Validates that the asset located at a path is allowable for this asset reference. An asset is allowable if it is of the correct type or if one of its sub-asset is. Declaration public override bool ValidateAsset(string mainAssetPath) Parameters Type Name Description String mainAssetPath Returns Type Description Boolean Whether the referenced asset is valid. Overrides AssetReference.ValidateAsset(String) ValidateAsset(Object) Validates that the referenced asset allowable for this asset reference. Declaration public override bool ValidateAsset(Object obj) Parameters Type Name Description Object obj The Object to validate. Returns Type Description Boolean Whether the referenced asset is valid. Overrides AssetReference.ValidateAsset(Object)"
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceTexture.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceTexture.html",
    "title": "Class AssetReferenceTexture | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceTexture Texture only asset reference. Inheritance Object AssetReference AssetReferenceT < Texture > AssetReferenceTexture Inherited Members AssetReferenceT<Texture>.LoadAsset() AssetReferenceT<Texture>.LoadAssetAsync() AssetReferenceT<Texture>.ValidateAsset(Object) AssetReferenceT<Texture>.ValidateAsset(String) AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceTexture : AssetReferenceT<Texture>, IKeyEvaluator Constructors AssetReferenceTexture(String) Constructs a new reference to a Texture. Declaration public AssetReferenceTexture(string guid) Parameters Type Name Description String guid The object guid."
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceTexture2D.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceTexture2D.html",
    "title": "Class AssetReferenceTexture2D | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceTexture2D Texture2D only asset reference. Inheritance Object AssetReference AssetReferenceT < Texture2D > AssetReferenceTexture2D Inherited Members AssetReferenceT<Texture2D>.LoadAsset() AssetReferenceT<Texture2D>.LoadAssetAsync() AssetReferenceT<Texture2D>.ValidateAsset(Object) AssetReferenceT<Texture2D>.ValidateAsset(String) AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceTexture2D : AssetReferenceT<Texture2D>, IKeyEvaluator Constructors AssetReferenceTexture2D(String) Constructs a new reference to a Texture2D. Declaration public AssetReferenceTexture2D(string guid) Parameters Type Name Description String guid The object guid."
  },
  "api/UnityEngine.AddressableAssets.AssetReferenceTexture3D.html": {
    "href": "api/UnityEngine.AddressableAssets.AssetReferenceTexture3D.html",
    "title": "Class AssetReferenceTexture3D | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceTexture3D Texture3D only asset reference Inheritance Object AssetReference AssetReferenceT < Texture3D > AssetReferenceTexture3D Inherited Members AssetReferenceT<Texture3D>.LoadAsset() AssetReferenceT<Texture3D>.LoadAssetAsync() AssetReferenceT<Texture3D>.ValidateAsset(Object) AssetReferenceT<Texture3D>.ValidateAsset(String) AssetReference.OperationHandle AssetReference.RuntimeKey AssetReference.AssetGUID AssetReference.SubObjectName AssetReference.IsValid() AssetReference.IsDone AssetReference.Asset AssetReference.ToString() AssetReference.LoadAsset<TObject>() AssetReference.LoadScene() AssetReference.Instantiate(Vector3, Quaternion, Transform) AssetReference.Instantiate(Transform, Boolean) AssetReference.LoadAssetAsync<TObject>() AssetReference.LoadSceneAsync(LoadSceneMode, Boolean, Int32) AssetReference.UnLoadScene() AssetReference.InstantiateAsync(Vector3, Quaternion, Transform) AssetReference.InstantiateAsync(Transform, Boolean) AssetReference.RuntimeKeyIsValid() AssetReference.ReleaseAsset() AssetReference.ReleaseInstance(GameObject) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetReferenceTexture3D : AssetReferenceT<Texture3D>, IKeyEvaluator Constructors AssetReferenceTexture3D(String) Constructs a new reference to a Texture3D. Declaration public AssetReferenceTexture3D(string guid) Parameters Type Name Description String guid The object guid."
  },
  "api/UnityEngine.AddressableAssets.html": {
    "href": "api/UnityEngine.AddressableAssets.html",
    "title": "Namespace UnityEngine.AddressableAssets | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.AddressableAssets Classes Addressables Entry point for Addressable API, this provides a simpler interface than using ResourceManager directly as it assumes string address type. AssetLabelReference Reference to an asset label. This class can be used in scripts as a field and will use a CustomPropertyDrawer to provide a DropDown UI of available labels. AssetReference Reference to an addressable asset. This can be used in script to provide fields that can be easily set in the editor and loaded dynamically at runtime. To determine if the reference is set, use RuntimeKeyIsValid(). AssetReferenceAtlasedSprite Assetreference that only allows atlassed sprites. AssetReferenceGameObject GameObject only asset reference. AssetReferenceSprite Sprite only asset reference. AssetReferenceT<TObject> Generic version of AssetReference class. This should not be used directly as CustomPropertyDrawers do not support generic types. Instead use the concrete derived classes such as AssetReferenceGameObject. AssetReferenceTexture Texture only asset reference. AssetReferenceTexture2D Texture2D only asset reference. AssetReferenceTexture3D Texture3D only asset reference InvalidKeyException Exception to encapsulate invalid key errors. PlatformMappingService Determines the Addressables build platform that should be used based on the target player build platform. Interfaces IKeyEvaluator Interface for providing a key. This allows for objects passed into the Addressables system to provied a key instead of being used directly. Enums Addressables.MergeMode Options for merging the results of requests. If keys (A, B) mapped to results ([1,2,4],[3,4,5])... UseFirst (or None) takes the results from the first key -- [1,2,4] Union takes results of each key and collects items that matched any key. -- [1,2,3,4,5] Intersection takes results of each key, and collects items that matched every key. -- [4] AddressablesPlatform Options for the Addressables build platform."
  },
  "api/UnityEngine.AddressableAssets.IKeyEvaluator.html": {
    "href": "api/UnityEngine.AddressableAssets.IKeyEvaluator.html",
    "title": "Interface IKeyEvaluator | Addressables | 1.17.6-preview",
    "keywords": "Interface IKeyEvaluator Interface for providing a key. This allows for objects passed into the Addressables system to provied a key instead of being used directly. Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IKeyEvaluator Properties RuntimeKey The runtime key to use. Declaration object RuntimeKey { get; } Property Value Type Description Object Methods RuntimeKeyIsValid() Checks if the current RuntimeKey is valid. Declaration bool RuntimeKeyIsValid() Returns Type Description Boolean Whether the RuntimeKey is valid or not."
  },
  "api/UnityEngine.AddressableAssets.Initialization.AddressablesRuntimeProperties.html": {
    "href": "api/UnityEngine.AddressableAssets.Initialization.AddressablesRuntimeProperties.html",
    "title": "Class AddressablesRuntimeProperties | Addressables | 1.17.6-preview",
    "keywords": "Class AddressablesRuntimeProperties Supports the evaluation of embedded runtime variables in addressables locations Inheritance Object AddressablesRuntimeProperties Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.Initialization <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public static class AddressablesRuntimeProperties Methods ClearCachedPropertyValues() This will clear all PropertyValues that have been cached. This includes all values set by SetPropertyValue(String, String) as well as any reflection-evaluated properties. Declaration public static void ClearCachedPropertyValues() EvaluateProperty(String) Evaluates a named property using cached values and static public fields and properties. Be aware that a field or property may be stripped if not referenced anywhere else. Declaration public static string EvaluateProperty(string name) Parameters Type Name Description String name The property name. Returns Type Description String The value of the property. If not found, the name is returned. EvaluateString(String) Evaluates all tokens deliminated by '{' and '}' in a string and evaluates them with the EvaluateProperty method. Declaration public static string EvaluateString(string input) Parameters Type Name Description String input The input string. Returns Type Description String The evaluated string after resolving all tokens. EvaluateString(String, Char, Char, Func<String, String>) Evaluates all tokens deliminated by the specified delimiters in a string and evaluates them with the supplied method. Declaration public static string EvaluateString(string inputString, char startDelimiter, char endDelimiter, Func<string, string> varFunc) Parameters Type Name Description String inputString The string to evaluate. Char startDelimiter The start token delimiter. Char endDelimiter The end token delimiter. Func < String , String > varFunc Func that has a single string parameter and returns a string. Returns Type Description String The evaluated string. SetPropertyValue(String, String) Predefine a runtime property. Declaration public static void SetPropertyValue(string name, string val) Parameters Type Name Description String name The property name. String val The property value."
  },
  "api/UnityEngine.AddressableAssets.Initialization.CacheInitialization.html": {
    "href": "api/UnityEngine.AddressableAssets.Initialization.CacheInitialization.html",
    "title": "Class CacheInitialization | Addressables | 1.17.6-preview",
    "keywords": "Class CacheInitialization IInitializableObject that sets up the Caching system. Inheritance Object CacheInitialization Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.Initialization <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class CacheInitialization : IInitializableObject Methods Initialize(String, String) Sets properties of the Caching system. Declaration public bool Initialize(string id, string dataStr) Parameters Type Name Description String id The id of thei object. String dataStr The JSON serialized CacheInitializationData object. Returns Type Description Boolean True if the initialization succeeded. Implements IInitializableObject.Initialize(String, String) InitializeAsync(ResourceManager, String, String) Async operation for initializing a constructed object. Declaration public virtual AsyncOperationHandle<bool> InitializeAsync(ResourceManager rm, string id, string data) Parameters Type Name Description ResourceManager rm The current instance of Resource Manager. String id The id of the object. String data Serialized data for the object. Returns Type Description AsyncOperationHandle < Boolean > Async operation Implements IInitializableObject.InitializeAsync(ResourceManager, String, String)"
  },
  "api/UnityEngine.AddressableAssets.Initialization.CacheInitializationData.html": {
    "href": "api/UnityEngine.AddressableAssets.Initialization.CacheInitializationData.html",
    "title": "Class CacheInitializationData | Addressables | 1.17.6-preview",
    "keywords": "Class CacheInitializationData Contains settings for the Caching system. Inheritance Object CacheInitializationData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.Initialization <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class CacheInitializationData Properties CacheDirectoryOverride If not null or empty a new cache is created using Caching.AddCache and it is set active by assigning it to Caching.currentCacheForWriting. Declaration public string CacheDirectoryOverride { get; set; } Property Value Type Description String CompressionEnabled Enable recompression of asset bundles into LZ4 format as they are saved to the cache. This sets the Caching.compressionEnabled value. Declaration public bool CompressionEnabled { get; set; } Property Value Type Description Boolean ExpirationDelay Controls how long bundles are kept in the cache. This value is applied to Caching.currentCacheForWriting.expirationDelay. The value is in seconds and has a limit of 12960000 (150 days). Declaration public int ExpirationDelay { get; set; } Property Value Type Description Int32 LimitCacheSize If true, the maximum cache size will be set to MaximumCacheSize. Declaration public bool LimitCacheSize { get; set; } Property Value Type Description Boolean MaximumCacheSize The maximum size of the cache in bytes. This value is applied to Caching.currentCacheForWriting.maximumAvailableStorageSpace. This will only be set if LimitCacheSize is true. Declaration public long MaximumCacheSize { get; set; } Property Value Type Description Int64"
  },
  "api/UnityEngine.AddressableAssets.Initialization.html": {
    "href": "api/UnityEngine.AddressableAssets.Initialization.html",
    "title": "Namespace UnityEngine.AddressableAssets.Initialization | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.AddressableAssets.Initialization Classes AddressablesRuntimeProperties Supports the evaluation of embedded runtime variables in addressables locations CacheInitialization IInitializableObject that sets up the Caching system. CacheInitializationData Contains settings for the Caching system. ResourceManagerRuntimeData Runtime data that is used to initialize the Addressables system."
  },
  "api/UnityEngine.AddressableAssets.Initialization.ResourceManagerRuntimeData.html": {
    "href": "api/UnityEngine.AddressableAssets.Initialization.ResourceManagerRuntimeData.html",
    "title": "Class ResourceManagerRuntimeData | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceManagerRuntimeData Runtime data that is used to initialize the Addressables system. Inheritance Object ResourceManagerRuntimeData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.Initialization <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class ResourceManagerRuntimeData Fields kCatalogAddress Address of the contained catalogs. Declaration public const string kCatalogAddress = \"AddressablesMainContentCatalog\" Field Value Type Description String Properties BuildTarget The name of the build target that this data was prepared for. Declaration public string BuildTarget { get; set; } Property Value Type Description String CatalogLocations List of catalog locations to download in order (try remote first, then local) Declaration public List<ResourceLocationData> CatalogLocations { get; } Property Value Type Description List < ResourceLocationData > CertificateHandlerType The type of CertificateHandler to use for this provider. Declaration public Type CertificateHandlerType { get; set; } Property Value Type Description Type DisableCatalogUpdateOnStartup Determine if we should check for Remote Catalogs on during initialization. Declaration public bool DisableCatalogUpdateOnStartup { get; set; } Property Value Type Description Boolean InitializationObjects The list of initialization data. These objects will get deserialized and initialized during the Addressables initialization process. This happens after resource providers have been set up but before any catalogs are loaded. Declaration public List<ObjectInitializationData> InitializationObjects { get; } Property Value Type Description List < ObjectInitializationData > IsLocalCatalogInBundle Whether the local catalog has been serialized in an asset bundle or as json Declaration public bool IsLocalCatalogInBundle { get; set; } Property Value Type Description Boolean LogResourceManagerExceptions When enabled, the Addressables.ResourceManager.ExceptionHandler is set to (op, ex) => Debug.LogException(ex); Declaration public bool LogResourceManagerExceptions { get; set; } Property Value Type Description Boolean MaxConcurrentWebRequests The maximum number of concurrent web requests. This value will be clamped from 1 to 1024. Declaration public int MaxConcurrentWebRequests { get; set; } Property Value Type Description Int32 ProfileEvents Flag to control whether the ResourceManager sends profiler events. Declaration public bool ProfileEvents { get; set; } Property Value Type Description Boolean SettingsHash The hash of the settings that generated this runtime data. Declaration public string SettingsHash { get; set; } Property Value Type Description String"
  },
  "api/UnityEngine.AddressableAssets.InvalidKeyException.html": {
    "href": "api/UnityEngine.AddressableAssets.InvalidKeyException.html",
    "title": "Class InvalidKeyException | Addressables | 1.17.6-preview",
    "keywords": "Class InvalidKeyException Exception to encapsulate invalid key errors. Inheritance Object Exception InvalidKeyException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class InvalidKeyException : Exception, ISerializable, _Exception Constructors InvalidKeyException() Declaration public InvalidKeyException() InvalidKeyException(Object) Construct a new InvalidKeyException. Declaration public InvalidKeyException(object key) Parameters Type Name Description Object key The key that caused the exception. InvalidKeyException(Object, Type) Construct a new InvalidKeyException. Declaration public InvalidKeyException(object key, Type type) Parameters Type Name Description Object key The key that caused the exception. Type type The type of the key that caused the exception. InvalidKeyException(SerializationInfo, StreamingContext) Declaration protected InvalidKeyException(SerializationInfo message, StreamingContext context) Parameters Type Name Description SerializationInfo message StreamingContext context InvalidKeyException(String) Declaration public InvalidKeyException(string message) Parameters Type Name Description String message InvalidKeyException(String, Exception) Declaration public InvalidKeyException(string message, Exception innerException) Parameters Type Name Description String message Exception innerException Properties Key The key used to generate the exception. Declaration public object Key { get; } Property Value Type Description Object Message Stores information about the exception. Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message Type The type of the key used to generate the exception. Declaration public Type Type { get; } Property Value Type Description Type"
  },
  "api/UnityEngine.AddressableAssets.PlatformMappingService.html": {
    "href": "api/UnityEngine.AddressableAssets.PlatformMappingService.html",
    "title": "Class PlatformMappingService | Addressables | 1.17.6-preview",
    "keywords": "Class PlatformMappingService Determines the Addressables build platform that should be used based on the target player build platform. Inheritance Object PlatformMappingService Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class PlatformMappingService Methods GetPlatform() Retrieves the Addressables build platform that is being used. Declaration [Obsolete(\"This API doesn't adapt to the addition of new platforms. Use GetPlatformPathSubFolder instead.\")] public static AddressablesPlatform GetPlatform() Returns Type Description AddressablesPlatform Returns the Addressables build platform that is being used. GetPlatformPathSubFolder() Retrieves the Addressables platform subfolder of the build platform that is being used. Declaration public static string GetPlatformPathSubFolder() Returns Type Description String Returns the Addressables platform subfolder of the build platform that is being used."
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.ContentCatalogData.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.ContentCatalogData.html",
    "title": "Class ContentCatalogData | Addressables | 1.17.6-preview",
    "keywords": "Class ContentCatalogData Container for ContentCatalogEntries. Inheritance Object ContentCatalogData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class ContentCatalogData Constructors ContentCatalogData() Create a new ContentCatalogData object without any data. Declaration public ContentCatalogData() Properties InstanceProviderData Data for the Addressables.ResourceManager.InstanceProvider initialization; Declaration public ObjectInitializationData InstanceProviderData { get; set; } Property Value Type Description ObjectInitializationData InternalIds Internal Content Catalog Entry IDs for Addressable Assets. Declaration public string[] InternalIds { get; } Property Value Type Description String [] ProviderId Stores the id of the data provider. Declaration public string ProviderId { get; } Property Value Type Description String ProviderIds The IDs for the Resource Providers. Declaration public string[] ProviderIds { get; } Property Value Type Description String [] ResourceProviderData The list of resource provider data. Each entry will add an IResourceProvider to the Addressables.ResourceManager.ResourceProviders list. Declaration public List<ObjectInitializationData> ResourceProviderData { get; set; } Property Value Type Description List < ObjectInitializationData > SceneProviderData Data for the Addressables.ResourceManager.InstanceProvider initialization; Declaration public ObjectInitializationData SceneProviderData { get; set; } Property Value Type Description ObjectInitializationData Methods CreateLocator(String) Create IResourceLocator object Declaration public ResourceLocationMap CreateLocator(string providerSuffix = null) Parameters Type Name Description String providerSuffix If specified, this value will be appeneded to all provider ids. This is used when loading additional catalogs that need to have unique providers. Returns Type Description ResourceLocationMap ResourceLocationMap, which implements the IResourceLocator interface."
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.ContentCatalogDataEntry.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.ContentCatalogDataEntry.html",
    "title": "Class ContentCatalogDataEntry | Addressables | 1.17.6-preview",
    "keywords": "Class ContentCatalogDataEntry Contains serializable data for an IResourceLocation Inheritance Object ContentCatalogDataEntry Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ContentCatalogDataEntry Constructors ContentCatalogDataEntry(Type, String, String, IEnumerable<Object>, IEnumerable<Object>, Object) Creates a new ContentCatalogEntry object. Declaration public ContentCatalogDataEntry(Type type, string internalId, string provider, IEnumerable<object> keys, IEnumerable<object> dependencies = null, object extraData = null) Parameters Type Name Description Type type The entry type. String internalId The internal id. String provider The provider id. IEnumerable < Object > keys The collection of keys that can be used to retrieve this entry. IEnumerable < Object > dependencies Optional collection of keys for dependencies. Object extraData Optional additional data to be passed to the provider. For example, AssetBundleProviders use this for cache and crc data. Properties Data Serializable data for the provider. Declaration public object Data { get; set; } Property Value Type Description Object Dependencies Dependency keys. Declaration public List<object> Dependencies { get; } Property Value Type Description List < Object > InternalId Internl id. Declaration public string InternalId { get; set; } Property Value Type Description String Keys Keys for this location. Declaration public List<object> Keys { get; } Property Value Type Description List < Object > Provider IResourceProvider identifier. Declaration public string Provider { get; } Property Value Type Description String ResourceType The type of the resource for th location. Declaration public Type ResourceType { get; } Property Value Type Description Type"
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.html",
    "title": "Namespace UnityEngine.AddressableAssets.ResourceLocators | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.AddressableAssets.ResourceLocators Classes ContentCatalogData Container for ContentCatalogEntries. ContentCatalogDataEntry Contains serializable data for an IResourceLocation LegacyResourcesLocator Simple locator that acts as a passthrough for assets loaded from resources directories. ResourceLocationData Serializable location data. This is used for the locations of the content catalogs. ResourceLocationMap Simple implementation of an IResourceLocator Interfaces IResourceLocator Interface used by the Addressables system to find the locations of a given key."
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.IResourceLocator.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.IResourceLocator.html",
    "title": "Interface IResourceLocator | Addressables | 1.17.6-preview",
    "keywords": "Interface IResourceLocator Interface used by the Addressables system to find the locations of a given key. Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IResourceLocator Properties Keys The keys defined by this locator. Declaration IEnumerable<object> Keys { get; } Property Value Type Description IEnumerable < Object > LocatorId The id for this locator. Declaration string LocatorId { get; } Property Value Type Description String Methods Locate(Object, Type, out IList<IResourceLocation>) Retrieve the locations from a specified key. Declaration bool Locate(object key, Type type, out IList<IResourceLocation> locations) Parameters Type Name Description Object key The key to use. Type type The resource type. IList < IResourceLocation > locations The resulting set of locations for the key. Returns Type Description Boolean True if any locations were found with the specified key."
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.LegacyResourcesLocator.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.LegacyResourcesLocator.html",
    "title": "Class LegacyResourcesLocator | Addressables | 1.17.6-preview",
    "keywords": "Class LegacyResourcesLocator Simple locator that acts as a passthrough for assets loaded from resources directories. Inheritance Object LegacyResourcesLocator Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class LegacyResourcesLocator : IResourceLocator Properties Keys The keys available in this locator. Declaration public IEnumerable<object> Keys { get; } Property Value Type Description IEnumerable < Object > Implements IResourceLocator.Keys LocatorId Id of locator. Declaration public string LocatorId { get; } Property Value Type Description String Implements IResourceLocator.LocatorId Methods Locate(Object, Type, out IList<IResourceLocation>) The key is converted to a string and used as the internal id of the location added to the locations parameter. Declaration public bool Locate(object key, Type type, out IList<IResourceLocation> locations) Parameters Type Name Description Object key The key of the location. This should be a string with the resources path of the asset. Type type The resource type. IList < IResourceLocation > locations The list of locations. This will have at most one item. Returns Type Description Boolean True if the key is a string object and a location was created, false otherwise. Implements IResourceLocator.Locate(Object, Type, out IList<IResourceLocation>)"
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.ResourceLocationData.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.ResourceLocationData.html",
    "title": "Class ResourceLocationData | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceLocationData Serializable location data. This is used for the locations of the content catalogs. Inheritance Object ResourceLocationData Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class ResourceLocationData Constructors ResourceLocationData(String[], String, Type, Type, String[]) Construct a new ResourceLocationData object. Declaration public ResourceLocationData(string[] keys, string id, Type provider, Type t, string[] dependencies = null) Parameters Type Name Description String [] keys Array of keys for the location. This must contain at least one item. String id The internal id. Type provider The provider id. Type t The resource object type. String [] dependencies Optional array of dependencies. Properties Data Declaration public object Data { get; set; } Property Value Type Description Object Dependencies The collection of dependencies for this location. Declaration public string[] Dependencies { get; } Property Value Type Description String [] InternalId The internal id. Declaration public string InternalId { get; } Property Value Type Description String Keys The collection of keys for this location. Declaration public string[] Keys { get; } Property Value Type Description String [] Provider The provider id. Declaration public string Provider { get; } Property Value Type Description String ResourceType The type of the resource for the location. Declaration public Type ResourceType { get; } Property Value Type Description Type"
  },
  "api/UnityEngine.AddressableAssets.ResourceLocators.ResourceLocationMap.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceLocators.ResourceLocationMap.html",
    "title": "Class ResourceLocationMap | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceLocationMap Simple implementation of an IResourceLocator Inheritance Object ResourceLocationMap Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceLocators <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ResourceLocationMap : IResourceLocator Constructors ResourceLocationMap(String, IList<ResourceLocationData>) Construct a new ResourceLocationMap object with a list of locations. Declaration public ResourceLocationMap(string id, IList<ResourceLocationData> locations) Parameters Type Name Description String id The locator id. IList < ResourceLocationData > locations The list of locations to initialize with. ResourceLocationMap(String, Int32) Construct a new ResourceLocationMap object. Declaration public ResourceLocationMap(string id, int capacity = 0) Parameters Type Name Description String id The locator id. Int32 capacity The expected number of items. Properties Keys The keys available in this locator. Declaration public IEnumerable<object> Keys { get; } Property Value Type Description IEnumerable < Object > Implements IResourceLocator.Keys Locations The mapping of key to location lists. Declaration public Dictionary<object, IList<IResourceLocation>> Locations { get; } Property Value Type Description Dictionary < Object , IList < IResourceLocation >> LocatorId Stores the resource locator id. Declaration public string LocatorId { get; } Property Value Type Description String Implements IResourceLocator.LocatorId Methods Add(Object, IList<IResourceLocation>) Add a list of locations. Declaration public void Add(object key, IList<IResourceLocation> locations) Parameters Type Name Description Object key The key to reference the locations with. IList < IResourceLocation > locations The list of locations to store at the given key. Add(Object, IResourceLocation) Add a new location. Declaration public void Add(object key, IResourceLocation location) Parameters Type Name Description Object key The key to reference the location. IResourceLocation location The location to add. Locate(Object, Type, out IList<IResourceLocation>) Locate all of the locations that match the given key. Declaration public bool Locate(object key, Type type, out IList<IResourceLocation> locations) Parameters Type Name Description Object key The key used to locate the locations. Type type The resource type. IList < IResourceLocation > locations The list of found locations. This list is shared so it should not be modified. Returns Type Description Boolean Returns true if a location was found. Returns false otherwise. Implements IResourceLocator.Locate(Object, Type, out IList<IResourceLocation>)"
  },
  "api/UnityEngine.AddressableAssets.ResourceProviders.ContentCatalogProvider.DependencyHashIndex.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceProviders.ContentCatalogProvider.DependencyHashIndex.html",
    "title": "Enum ContentCatalogProvider.DependencyHashIndex | Addressables | 1.17.6-preview",
    "keywords": "Enum ContentCatalogProvider.DependencyHashIndex Options for specifying which entry in the catalog dependencies should hold each hash item. The Remote should point to the hash on the server. The Cache should point to the local cache copy of the remote data. Namespace : UnityEngine.AddressableAssets.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum DependencyHashIndex Fields Name Description Value Remote Use to represent the index of the remote entry in the dependencies list. 0 Cache Use to represent the index of the cache entry in the dependencies list. 1 Count Use to represent the number of entries in the dependencies list. 2"
  },
  "api/UnityEngine.AddressableAssets.ResourceProviders.ContentCatalogProvider.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceProviders.ContentCatalogProvider.html",
    "title": "Class ContentCatalogProvider | Addressables | 1.17.6-preview",
    "keywords": "Class ContentCatalogProvider Provider for content catalogs. This provider makes use of a hash file to determine if a newer version of the catalog needs to be downloaded. Inheritance Object ResourceProviderBase ContentCatalogProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.AddressableAssets.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ContentCatalogProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Constructors ContentCatalogProvider(ResourceManager) Constructor for this provider. Declaration public ContentCatalogProvider(ResourceManager resourceManagerInstance) Parameters Type Name Description ResourceManager resourceManagerInstance The resource manager to use. Fields DisableCatalogUpdateOnStart Use to indicate if the updating the catalog on startup should be disabled. Declaration public bool DisableCatalogUpdateOnStart Field Value Type Description Boolean IsLocalCatalogInBundle Use to indicate if the local catalog is in a bundle. Declaration public bool IsLocalCatalogInBundle Field Value Type Description Boolean Methods Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public override void Provide(ProvideHandle providerInterface) Parameters Type Name Description ProvideHandle providerInterface Overrides ResourceProviderBase.Provide(ProvideHandle) Release(IResourceLocation, Object) Release the specified object that was created from the specified location. Declaration public override void Release(IResourceLocation location, object obj) Parameters Type Name Description IResourceLocation location The location of the object Object obj The object to release. Overrides ResourceProviderBase.Release(IResourceLocation, Object)"
  },
  "api/UnityEngine.AddressableAssets.ResourceProviders.html": {
    "href": "api/UnityEngine.AddressableAssets.ResourceProviders.html",
    "title": "Namespace UnityEngine.AddressableAssets.ResourceProviders | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.AddressableAssets.ResourceProviders Classes ContentCatalogProvider Provider for content catalogs. This provider makes use of a hash file to determine if a newer version of the catalog needs to be downloaded. Enums ContentCatalogProvider.DependencyHashIndex Options for specifying which entry in the catalog dependencies should hold each hash item. The Remote should point to the hash on the server. The Cache should point to the local cache copy of the remote data."
  },
  "api/UnityEngine.AssetReferenceUILabelRestriction.html": {
    "href": "api/UnityEngine.AssetReferenceUILabelRestriction.html",
    "title": "Class AssetReferenceUILabelRestriction | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceUILabelRestriction Used to restrict an AssetReference field or property to only allow items wil specific labels. This is only enforced through the UI. Inheritance Object Attribute AssetReferenceUIRestriction AssetReferenceUILabelRestriction Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.Equals(Object) Attribute.GetHashCode() Attribute.Match(Object) Attribute.IsDefaultAttribute() Attribute._Attribute.GetTypeInfoCount(UInt32) Attribute._Attribute.GetTypeInfo(UInt32, UInt32, IntPtr) Attribute._Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr) Attribute._Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr) Attribute.TypeId Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)] public sealed class AssetReferenceUILabelRestriction : AssetReferenceUIRestriction, _Attribute Constructors AssetReferenceUILabelRestriction(String[]) Creates a new AssetReferenceUILabelRestriction object. Declaration public AssetReferenceUILabelRestriction(params string[] allowedLabels) Parameters Type Name Description String [] allowedLabels The labels allowed for the AssetReference. Fields m_AllowedLabels Stores the labels allowed for the AssetReference. Declaration public string[] m_AllowedLabels Field Value Type Description String [] m_CachedToString Stores the allowed labels formatted as a string. Declaration public string m_CachedToString Field Value Type Description String Methods ToString() Converts the information about the allowed labels to a formatted string. Declaration public override string ToString() Returns Type Description String Returns information about the allowed labels as a string. Overrides Object.ToString() ValidateAsset(String) Validates that the referenced asset allowable for this asset reference. Declaration public override bool ValidateAsset(string path) Parameters Type Name Description String path The path to the asset in question. Returns Type Description Boolean Whether the referenced asset is valid. Overrides AssetReferenceUIRestriction.ValidateAsset(String) ValidateAsset(Object) Validates that the referenced asset allowable for this asset reference. Declaration public override bool ValidateAsset(Object obj) Parameters Type Name Description Object obj The Object to validate. Returns Type Description Boolean Whether the referenced asset is valid. Overrides AssetReferenceUIRestriction.ValidateAsset(Object)"
  },
  "api/UnityEngine.AssetReferenceUIRestriction.html": {
    "href": "api/UnityEngine.AssetReferenceUIRestriction.html",
    "title": "Class AssetReferenceUIRestriction | Addressables | 1.17.6-preview",
    "keywords": "Class AssetReferenceUIRestriction Used to restrict an AssetReference field or property to only allow items wil specific labels. This is only enforced through the UI. Inheritance Object Attribute AssetReferenceUIRestriction AssetReferenceUILabelRestriction Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.Equals(Object) Attribute.GetHashCode() Attribute.Match(Object) Attribute.IsDefaultAttribute() Attribute._Attribute.GetTypeInfoCount(UInt32) Attribute._Attribute.GetTypeInfo(UInt32, UInt32, IntPtr) Attribute._Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr) Attribute._Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr) Attribute.TypeId Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)] public class AssetReferenceUIRestriction : Attribute, _Attribute Methods ValidateAsset(String) Validates that the referenced asset allowable for this asset reference. Declaration public virtual bool ValidateAsset(string path) Parameters Type Name Description String path The path to the asset in question. Returns Type Description Boolean Whether the referenced asset is valid. ValidateAsset(Object) Validates that the referenced asset allowable for this asset reference. Declaration public virtual bool ValidateAsset(Object obj) Parameters Type Name Description Object obj The Object to validate. Returns Type Description Boolean Whether the referenced asset is valid."
  },
  "api/UnityEngine.html": {
    "href": "api/UnityEngine.html",
    "title": "Namespace UnityEngine | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine Classes AssetReferenceUILabelRestriction Used to restrict an AssetReference field or property to only allow items wil specific labels. This is only enforced through the UI. AssetReferenceUIRestriction Used to restrict an AssetReference field or property to only allow items wil specific labels. This is only enforced through the UI."
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationBase-1.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationBase-1.html",
    "title": "Class AsyncOperationBase<TObject> | Addressables | 1.17.6-preview",
    "keywords": "Class AsyncOperationBase<TObject> base class for implemented AsyncOperations, implements the needed interfaces and consolidates redundant code Inheritance Object AsyncOperationBase<TObject> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.AsyncOperations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public abstract class AsyncOperationBase<TObject> : IAsyncOperation Type Parameters Name Description TObject The type of the operation. Constructors AsyncOperationBase() Basic constructor for AsyncOperationBase. Declaration protected AsyncOperationBase() Fields HasExecuted Declaration protected bool HasExecuted Field Value Type Description Boolean Properties DebugName A custom operation should override this method to provide a debug friendly name for the operation. Declaration protected virtual string DebugName { get; } Property Value Type Description String IsRunning True if the current op has begun but hasn't yet reached completion. False otherwise. Declaration public bool IsRunning { get; } Property Value Type Description Boolean Progress A custom operation should override this method to return the progress of the operation. Declaration protected virtual float Progress { get; } Property Value Type Description Single Progress of the operation. Value should be between 0.0f and 1.0f Result Accessor to Result of the operation. Declaration public TObject Result { get; set; } Property Value Type Description TObject Methods Complete(TObject, Boolean, String) Complete the operation and invoke events. Declaration public void Complete(TObject result, bool success, string errorMsg) Parameters Type Name Description TObject result The result object for the operation. Boolean success True if successful or if the operation failed silently. String errorMsg The error message if the operation has failed. Remarks An operation is considered to have failed silently if success is true and if errorMsg isn't null or empty. The exception handler will be called in cases of silent failures. Any failed operations will call Release on any dependencies that succeeded. Complete(TObject, Boolean, String, Boolean) Complete the operation and invoke events. Declaration public void Complete(TObject result, bool success, string errorMsg, bool releaseDependenciesOnFailure) Parameters Type Name Description TObject result The result object for the operation. Boolean success True if successful or if the operation failed silently. String errorMsg The error message if the operation has failed. Boolean releaseDependenciesOnFailure When true, failed operations will release any dependencies that succeeded. Remarks An operation is considered to have failed silently if success is true and if errorMsg isn't null or empty. The exception handler will be called in cases of silent failures. Destroy() This will be called by the resource manager when the reference count of the operation reaches zero. This method should not be called manually. A custom operation should override this method and release any held resources Declaration protected virtual void Destroy() Execute() This will be called by the resource manager after all dependent operation complete. This method should not be called manually. A custom operation should override this method and begin work when it is called. Declaration protected abstract void Execute() GetDependencies(List<AsyncOperationHandle>) A custom operation should override this method to provide a list of AsyncOperationHandles that it depends on. Declaration protected virtual void GetDependencies(List<AsyncOperationHandle> dependencies) Parameters Type Name Description List < AsyncOperationHandle > dependencies The list that should be populated with dependent AsyncOperationHandles. ToString() Converts the information about the operation to a formatted string. Declaration public override string ToString() Returns Type Description String Returns the information about the operation. Overrides Object.ToString() WaitForCompletion() Synchronously complete the async operation. Declaration public void WaitForCompletion()"
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle.html",
    "title": "Struct AsyncOperationHandle | Addressables | 1.17.6-preview",
    "keywords": "Struct AsyncOperationHandle Non typed operation handle. This allows for reference counting and checking for valid references. Inherited Members ValueType.Equals(Object) ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.AsyncOperations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct AsyncOperationHandle : IEnumerator Properties DebugName Debug name of the operation. Declaration public string DebugName { get; } Property Value Type Description String IsDone True if the operation is complete. Declaration public bool IsDone { get; } Property Value Type Description Boolean OperationException The exception for a failed operation. This will be null unless Status is failed. Declaration public Exception OperationException { get; } Property Value Type Description Exception PercentComplete The progress of the internal operation. This is evenly weighted between all sub-operations. For example, a LoadAssetAsync call could potentially be chained with InitializeAsync and have multiple dependent operations that download and load content. In that scenario, PercentComplete would reflect how far the overal operation was, and would not accurately represent just percent downloaded or percent loaded into memory. For accurate download percentages, use GetDownloadStatus(). Declaration public float PercentComplete { get; } Property Value Type Description Single Result The result object of the operations. Declaration public object Result { get; } Property Value Type Description Object Status The status of the internal operation. Declaration public AsyncOperationStatus Status { get; } Property Value Type Description AsyncOperationStatus Task Return a Task object to wait on when using async await. Declaration public Task<object> Task { get; } Property Value Type Description Task < Object > Methods Convert<T>() Converts handle to be typed. This does not increment the reference count. To convert back to non-typed, implicit conversion is available. Declaration public AsyncOperationHandle<T> Convert<T>() Returns Type Description AsyncOperationHandle <T> A new handle that is typed. Type Parameters Name Description T The type of the handle. Equals(AsyncOperationHandle) Provide equality for this struct. Declaration public bool Equals(AsyncOperationHandle other) Parameters Type Name Description AsyncOperationHandle other The operation to compare to. Returns Type Description Boolean True if the the operation handles reference the same AsyncOperation and the version is the same. GetDependencies(List<AsyncOperationHandle>) Get dependency operations. Declaration public void GetDependencies(List<AsyncOperationHandle> deps) Parameters Type Name Description List < AsyncOperationHandle > deps GetDownloadStatus() Return the current download status for this operation and its dependencies. In some instances, the information will not be available. This can happen if the operation is dependent on the initialization operation for addressables. Once the initialization operation completes, the information returned will be accurate. Declaration public DownloadStatus GetDownloadStatus() Returns Type Description DownloadStatus The download status. GetHashCode() Get hash code of this struct. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides ValueType.GetHashCode() IsValid() Check if the internal operation is not null and has the same version of this handle. Declaration public bool IsValid() Returns Type Description Boolean True if valid. WaitForCompletion() Synchronously complete the async operation. Declaration public object WaitForCompletion() Returns Type Description Object The result of the operation or null. Events Completed Completion event for the internal operation. If this is assigned on a completed operation, the callback is deferred until the LateUpdate of the current frame. Declaration public event Action<AsyncOperationHandle> Completed Event Type Type Description Action < AsyncOperationHandle > Destroyed Event for handling the destruction of the operation. Declaration public event Action<AsyncOperationHandle> Destroyed Event Type Type Description Action < AsyncOperationHandle > Explicit Interface Implementations IEnumerator.Current Declaration object IEnumerator.Current { get; } Returns Type Description Object Implements IEnumerator.Current IEnumerator.MoveNext() Overload for MoveNext() . Declaration bool IEnumerator.MoveNext() Returns Type Description Boolean Returns true if the enumerator can advance to the next element in the collectin. Returns false otherwise. Implements IEnumerator.MoveNext() IEnumerator.Reset() Overload for Reset() . Declaration void IEnumerator.Reset() Implements IEnumerator.Reset()"
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle-1.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle-1.html",
    "title": "Struct AsyncOperationHandle<TObject> | Addressables | 1.17.6-preview",
    "keywords": "Struct AsyncOperationHandle<TObject> Handle for internal operations. This allows for reference counting and checking for valid references. Inherited Members ValueType.Equals(Object) ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.AsyncOperations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct AsyncOperationHandle<TObject> : IEnumerator, IEquatable<AsyncOperationHandle<TObject>> Type Parameters Name Description TObject The object type of the underlying operation. Properties DebugName Debug name of the operation. Declaration public string DebugName { get; } Property Value Type Description String IsDone True if the operation is complete. Declaration public bool IsDone { get; } Property Value Type Description Boolean OperationException The exception for a failed operation. This will be null unless Status is failed. Declaration public Exception OperationException { get; } Property Value Type Description Exception PercentComplete The progress of the internal operation. This is evenly weighted between all sub-operations. For example, a LoadAssetAsync call could potentially be chained with InitializeAsync and have multiple dependent operations that download and load content. In that scenario, PercentComplete would reflect how far the overal operation was, and would not accurately represent just percent downloaded or percent loaded into memory. For accurate download percentages, use GetDownloadStatus(). Declaration public float PercentComplete { get; } Property Value Type Description Single Result The result object of the operations. Declaration public TObject Result { get; } Property Value Type Description TObject Status The status of the internal operation. Declaration public AsyncOperationStatus Status { get; } Property Value Type Description AsyncOperationStatus Task Return a Task object to wait on when using async await. Declaration public Task<TObject> Task { get; } Property Value Type Description Task <TObject> Methods Equals(AsyncOperationHandle<TObject>) Provide equality for this struct. Declaration public bool Equals(AsyncOperationHandle<TObject> other) Parameters Type Name Description AsyncOperationHandle <TObject> other The operation to compare to. Returns Type Description Boolean True if the the operation handles reference the same AsyncOperation and the version is the same. Implements IEquatable<T>.Equals(T) GetDownloadStatus() Return the current download status for this operation and its dependencies. Declaration public DownloadStatus GetDownloadStatus() Returns Type Description DownloadStatus The download status. GetHashCode() Get hash code of this struct. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides ValueType.GetHashCode() IsValid() Check if the handle references an internal operation. Declaration public bool IsValid() Returns Type Description Boolean True if valid. WaitForCompletion() Synchronously complete the async operation. Declaration public TObject WaitForCompletion() Returns Type Description TObject The result of the operation or null. Events Completed Completion event for the internal operation. If this is assigned on a completed operation, the callback is deferred until the LateUpdate of the current frame. Declaration public event Action<AsyncOperationHandle<TObject>> Completed Event Type Type Description Action < AsyncOperationHandle <TObject>> CompletedTypeless Completion event for non-typed callback handlers. If this is assigned on a completed operation, the callback is deferred until the LateUpdate of the current frame. Declaration public event Action<AsyncOperationHandle> CompletedTypeless Event Type Type Description Action < AsyncOperationHandle > Destroyed Event for handling the destruction of the operation. Declaration public event Action<AsyncOperationHandle> Destroyed Event Type Type Description Action < AsyncOperationHandle > Operators Implicit(AsyncOperationHandle<TObject> to AsyncOperationHandle) Conversion from typed to non typed handles. This does not increment the reference count. To convert from non-typed back, use AsyncOperationHandle.Convert<T>() Declaration public static implicit operator AsyncOperationHandle(AsyncOperationHandle<TObject> obj) Parameters Type Name Description AsyncOperationHandle <TObject> obj The typed handle to convert. Returns Type Description AsyncOperationHandle Returns the converted operation handle. Explicit Interface Implementations IEnumerator.Current Declaration object IEnumerator.Current { get; } Returns Type Description Object Implements IEnumerator.Current IEnumerator.MoveNext() Overload for MoveNext() . Declaration bool IEnumerator.MoveNext() Returns Type Description Boolean Returns true if the enumerator can advance to the next element in the collectin. Returns false otherwise. Implements IEnumerator.MoveNext() IEnumerator.Reset() Overload for Reset() . Declaration void IEnumerator.Reset() Implements IEnumerator.Reset()"
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.html",
    "title": "Enum AsyncOperationStatus | Addressables | 1.17.6-preview",
    "keywords": "Enum AsyncOperationStatus Options for IAsyncOperations status values Namespace : UnityEngine.ResourceManagement.AsyncOperations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum AsyncOperationStatus Fields Name Description Value None Use to indicate that the operation is still in progress. 0 Succeeded Use to indicate that the operation succeeded. 1 Failed Use to indicate that the operation failed. 2"
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.DownloadStatus.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.DownloadStatus.html",
    "title": "Struct DownloadStatus | Addressables | 1.17.6-preview",
    "keywords": "Struct DownloadStatus Contains download information for async operations. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.AsyncOperations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct DownloadStatus Fields DownloadedBytes The total number of bytes needed to download by the operation and dependencies. Declaration public long DownloadedBytes Field Value Type Description Int64 IsDone Is the operation completed. This is used to determine if the computed Percent should be 0 or 1 when TotalBytes is 0. Declaration public bool IsDone Field Value Type Description Boolean TotalBytes The number of bytes downloaded by the operation and all of its dependencies. Declaration public long TotalBytes Field Value Type Description Int64 Properties Percent Returns the computed percent complete as a float value between 0 & 1. If TotalBytes == 0, 1 is returned. Declaration public float Percent { get; } Property Value Type Description Single"
  },
  "api/UnityEngine.ResourceManagement.AsyncOperations.html": {
    "href": "api/UnityEngine.ResourceManagement.AsyncOperations.html",
    "title": "Namespace UnityEngine.ResourceManagement.AsyncOperations | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.AsyncOperations Classes AsyncOperationBase<TObject> base class for implemented AsyncOperations, implements the needed interfaces and consolidates redundant code Structs AsyncOperationHandle Non typed operation handle. This allows for reference counting and checking for valid references. AsyncOperationHandle<TObject> Handle for internal operations. This allows for reference counting and checking for valid references. DownloadStatus Contains download information for async operations. Enums AsyncOperationStatus Options for IAsyncOperations status values"
  },
  "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEvent.html": {
    "href": "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEvent.html",
    "title": "Struct DiagnosticEvent | Addressables | 1.17.6-preview",
    "keywords": "Struct DiagnosticEvent Diagnostic event data. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.Diagnostics <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public struct DiagnosticEvent Constructors DiagnosticEvent(String, String, Int32, Int32, Int32, Int32, Int32[]) DiagnosticEvent constructor Declaration public DiagnosticEvent(string graph, string name, int id, int stream, int frame, int value, int[] deps) Parameters Type Name Description String graph Graph id. String name Event name. Int32 id Event id. Int32 stream Stream index. Int32 frame Frame number. Int32 value Event value. Int32 [] deps Array of dependency event ids. Properties Dependencies Array of object identifiers that are dependencies for this event Declaration public int[] Dependencies { get; } Property Value Type Description Int32 [] DisplayName Display name for event Declaration public string DisplayName { get; } Property Value Type Description String Frame The frame that the event occurred Declaration public int Frame { get; } Property Value Type Description Int32 Frame number Graph Gets the graph id that this event is intended for Declaration public string Graph { get; } Property Value Type Description String The graph Id ObjectId Unique object identifier for this event Declaration public int ObjectId { get; } Property Value Type Description Int32 Stream The stream id for the event. Each graph may display multiple streams of data for the same event Id Declaration public int Stream { get; } Property Value Type Description Int32 Stream Id Value The value of the event. This value depends on the event type Declaration public int Value { get; } Property Value Type Description Int32 Event value Methods Deserialize(Byte[]) Deserializes event from a byte array created by the UnityEngine.ResourceManagement.Diagnostics.DiagnosticEvent.Serialize method Declaration public static DiagnosticEvent Deserialize(byte[] data) Parameters Type Name Description Byte [] data Serialized data Returns Type Description DiagnosticEvent Deserialized DiagnosticEvent struct"
  },
  "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEventCollector.html": {
    "href": "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEventCollector.html",
    "title": "Class DiagnosticEventCollector | Addressables | 1.17.6-preview",
    "keywords": "Class DiagnosticEventCollector Collects ResourceManager events and passed them on the registered event handlers. In editor play mode, events are passed directly to the ResourceManager profiler window. In player builds, events are sent to the editor via the EditorConnection API. Inheritance Object Object Component Behaviour MonoBehaviour DiagnosticEventCollector Inherited Members MonoBehaviour.IsInvoking() MonoBehaviour.CancelInvoke() MonoBehaviour.Invoke(String, Single) MonoBehaviour.InvokeRepeating(String, Single, Single) MonoBehaviour.CancelInvoke(String) MonoBehaviour.IsInvoking(String) MonoBehaviour.StartCoroutine(String) MonoBehaviour.StartCoroutine(String, Object) MonoBehaviour.StartCoroutine(IEnumerator) MonoBehaviour.StartCoroutine_Auto(IEnumerator) MonoBehaviour.StopCoroutine(IEnumerator) MonoBehaviour.StopCoroutine(Coroutine) MonoBehaviour.StopCoroutine(String) MonoBehaviour.StopAllCoroutines() MonoBehaviour.print(Object) MonoBehaviour.useGUILayout MonoBehaviour.runInEditMode Behaviour.enabled Behaviour.isActiveAndEnabled Component.GetComponent(Type) Component.GetComponent<T>() Component.TryGetComponent(Type, Component) Component.TryGetComponent<T>(T) Component.GetComponent(String) Component.GetComponentInChildren(Type, Boolean) Component.GetComponentInChildren(Type) Component.GetComponentInChildren<T>(Boolean) Component.GetComponentInChildren<T>() Component.GetComponentsInChildren(Type, Boolean) Component.GetComponentsInChildren(Type) Component.GetComponentsInChildren<T>(Boolean) Component.GetComponentsInChildren<T>(Boolean, List<T>) Component.GetComponentsInChildren<T>() Component.GetComponentsInChildren<T>(List<T>) Component.GetComponentInParent(Type) Component.GetComponentInParent<T>() Component.GetComponentsInParent(Type, Boolean) Component.GetComponentsInParent(Type) Component.GetComponentsInParent<T>(Boolean) Component.GetComponentsInParent<T>(Boolean, List<T>) Component.GetComponentsInParent<T>() Component.GetComponents(Type) Component.GetComponents(Type, List<Component>) Component.GetComponents<T>(List<T>) Component.GetComponents<T>() Component.CompareTag(String) Component.SendMessageUpwards(String, Object, SendMessageOptions) Component.SendMessageUpwards(String, Object) Component.SendMessageUpwards(String) Component.SendMessageUpwards(String, SendMessageOptions) Component.SendMessage(String, Object) Component.SendMessage(String) Component.SendMessage(String, Object, SendMessageOptions) Component.SendMessage(String, SendMessageOptions) Component.BroadcastMessage(String, Object, SendMessageOptions) Component.BroadcastMessage(String, Object) Component.BroadcastMessage(String) Component.BroadcastMessage(String, SendMessageOptions) Component.transform Component.gameObject Component.tag Component.rigidbody Component.rigidbody2D Component.camera Component.light Component.animation Component.constantForce Component.renderer Component.audio Component.networkView Component.collider Component.collider2D Component.hingeJoint Component.particleSystem Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Diagnostics <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class DiagnosticEventCollector : MonoBehaviour Properties PlayerConnectionGuid The guid used for the PlayerConnect messaging system. Declaration public static Guid PlayerConnectionGuid { get; } Property Value Type Description Guid Methods FindOrCreateGlobalInstance() Retrieves the global event collector. A new one is created if needed. Declaration public static DiagnosticEventCollector FindOrCreateGlobalInstance() Returns Type Description DiagnosticEventCollector The event collector global instance. PostEvent(DiagnosticEvent) Send a DiagnosticEvent event to all registered handlers Declaration public void PostEvent(DiagnosticEvent diagnosticEvent) Parameters Type Name Description DiagnosticEvent diagnosticEvent The event to send RegisterEventHandler(Action<DiagnosticEvent>, Boolean, Boolean) Register for diagnostic events. If there is no collector, this will fail and return false. Declaration public static bool RegisterEventHandler(Action<DiagnosticEvent> handler, bool register, bool create) Parameters Type Name Description Action < DiagnosticEvent > handler The handler method action. Boolean register Register or unregister. Boolean create If true, the event collector will be created if needed. Returns Type Description Boolean True if registered, false if not. UnregisterEventHandler(Action<DiagnosticEvent>) Unregister event hander Declaration public void UnregisterEventHandler(Action<DiagnosticEvent> handler) Parameters Type Name Description Action < DiagnosticEvent > handler Method or delegate that will handle the events"
  },
  "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEventCollectorSingleton.html": {
    "href": "api/UnityEngine.ResourceManagement.Diagnostics.DiagnosticEventCollectorSingleton.html",
    "title": "Class DiagnosticEventCollectorSingleton | Addressables | 1.17.6-preview",
    "keywords": "Class DiagnosticEventCollectorSingleton Collects ResourceManager events and passed them on the registered event handlers. In editor play mode, events are passed directly to the ResourceManager profiler window. In player builds, events are sent to the editor via the EditorConnection API. Inheritance Object Object Component Behaviour MonoBehaviour ComponentSingleton < DiagnosticEventCollectorSingleton > DiagnosticEventCollectorSingleton Inherited Members ComponentSingleton<DiagnosticEventCollectorSingleton>.Exists ComponentSingleton<DiagnosticEventCollectorSingleton>.Instance ComponentSingleton<DiagnosticEventCollectorSingleton>.DestroySingleton() MonoBehaviour.IsInvoking() MonoBehaviour.CancelInvoke() MonoBehaviour.Invoke(String, Single) MonoBehaviour.InvokeRepeating(String, Single, Single) MonoBehaviour.CancelInvoke(String) MonoBehaviour.IsInvoking(String) MonoBehaviour.StartCoroutine(String) MonoBehaviour.StartCoroutine(String, Object) MonoBehaviour.StartCoroutine(IEnumerator) MonoBehaviour.StartCoroutine_Auto(IEnumerator) MonoBehaviour.StopCoroutine(IEnumerator) MonoBehaviour.StopCoroutine(Coroutine) MonoBehaviour.StopCoroutine(String) MonoBehaviour.StopAllCoroutines() MonoBehaviour.print(Object) MonoBehaviour.useGUILayout MonoBehaviour.runInEditMode Behaviour.enabled Behaviour.isActiveAndEnabled Component.GetComponent(Type) Component.GetComponent<T>() Component.TryGetComponent(Type, Component) Component.TryGetComponent<T>(T) Component.GetComponent(String) Component.GetComponentInChildren(Type, Boolean) Component.GetComponentInChildren(Type) Component.GetComponentInChildren<T>(Boolean) Component.GetComponentInChildren<T>() Component.GetComponentsInChildren(Type, Boolean) Component.GetComponentsInChildren(Type) Component.GetComponentsInChildren<T>(Boolean) Component.GetComponentsInChildren<T>(Boolean, List<T>) Component.GetComponentsInChildren<T>() Component.GetComponentsInChildren<T>(List<T>) Component.GetComponentInParent(Type) Component.GetComponentInParent<T>() Component.GetComponentsInParent(Type, Boolean) Component.GetComponentsInParent(Type) Component.GetComponentsInParent<T>(Boolean) Component.GetComponentsInParent<T>(Boolean, List<T>) Component.GetComponentsInParent<T>() Component.GetComponents(Type) Component.GetComponents(Type, List<Component>) Component.GetComponents<T>(List<T>) Component.GetComponents<T>() Component.CompareTag(String) Component.SendMessageUpwards(String, Object, SendMessageOptions) Component.SendMessageUpwards(String, Object) Component.SendMessageUpwards(String) Component.SendMessageUpwards(String, SendMessageOptions) Component.SendMessage(String, Object) Component.SendMessage(String) Component.SendMessage(String, Object, SendMessageOptions) Component.SendMessage(String, SendMessageOptions) Component.BroadcastMessage(String, Object, SendMessageOptions) Component.BroadcastMessage(String, Object) Component.BroadcastMessage(String) Component.BroadcastMessage(String, SendMessageOptions) Component.transform Component.gameObject Component.tag Component.rigidbody Component.rigidbody2D Component.camera Component.light Component.animation Component.constantForce Component.renderer Component.audio Component.networkView Component.collider Component.collider2D Component.hingeJoint Component.particleSystem Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Diagnostics <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class DiagnosticEventCollectorSingleton : ComponentSingleton<DiagnosticEventCollectorSingleton> Properties PlayerConnectionGuid The guid used for the PlayerConnect messaging system. Declaration public static Guid PlayerConnectionGuid { get; } Property Value Type Description Guid Methods GetGameObjectName() Retrieves the name of the object. Declaration protected override string GetGameObjectName() Returns Type Description String Returns the name of the object. Overrides UnityEngine.ResourceManagement.Util.ComponentSingleton<UnityEngine.ResourceManagement.Diagnostics.DiagnosticEventCollectorSingleton>.GetGameObjectName() PostEvent(DiagnosticEvent) Send a DiagnosticEvent event to all registered handlers Declaration public void PostEvent(DiagnosticEvent diagnosticEvent) Parameters Type Name Description DiagnosticEvent diagnosticEvent The event to send RegisterEventHandler(Action<DiagnosticEvent>, Boolean, Boolean) Register for diagnostic events. If there is no collector, this will fail and return false. Declaration public static bool RegisterEventHandler(Action<DiagnosticEvent> handler, bool register, bool create) Parameters Type Name Description Action < DiagnosticEvent > handler The handler method action. Boolean register Register or unregister. Boolean create If true, the event collector will be created if needed. Returns Type Description Boolean True if registered, false if not. UnregisterEventHandler(Action<DiagnosticEvent>) Unregister event hander Declaration public void UnregisterEventHandler(Action<DiagnosticEvent> handler) Parameters Type Name Description Action < DiagnosticEvent > handler Method or delegate that will handle the events"
  },
  "api/UnityEngine.ResourceManagement.Diagnostics.html": {
    "href": "api/UnityEngine.ResourceManagement.Diagnostics.html",
    "title": "Namespace UnityEngine.ResourceManagement.Diagnostics | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.Diagnostics Classes DiagnosticEventCollector Collects ResourceManager events and passed them on the registered event handlers. In editor play mode, events are passed directly to the ResourceManager profiler window. In player builds, events are sent to the editor via the EditorConnection API. DiagnosticEventCollectorSingleton Collects ResourceManager events and passed them on the registered event handlers. In editor play mode, events are passed directly to the ResourceManager profiler window. In player builds, events are sent to the editor via the EditorConnection API. Structs DiagnosticEvent Diagnostic event data."
  },
  "api/UnityEngine.ResourceManagement.Exceptions.html": {
    "href": "api/UnityEngine.ResourceManagement.Exceptions.html",
    "title": "Namespace UnityEngine.ResourceManagement.Exceptions | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.Exceptions Classes ResourceManagerException Base class for all ResourceManager related exceptions. UnknownResourceProviderException Exception returned when the IResourceProvider is not found for a location."
  },
  "api/UnityEngine.ResourceManagement.Exceptions.ResourceManagerException.html": {
    "href": "api/UnityEngine.ResourceManagement.Exceptions.ResourceManagerException.html",
    "title": "Class ResourceManagerException | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceManagerException Base class for all ResourceManager related exceptions. Inheritance Object Exception ResourceManagerException UnknownResourceProviderException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Message Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Exceptions <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ResourceManagerException : Exception, ISerializable, _Exception Constructors ResourceManagerException() Construct a new ResourceManagerException. Declaration public ResourceManagerException() ResourceManagerException(SerializationInfo, StreamingContext) Construct a new ResourceManagerException. Declaration protected ResourceManagerException(SerializationInfo message, StreamingContext context) Parameters Type Name Description SerializationInfo message Message to describe the exception. StreamingContext context Context related to the exception. ResourceManagerException(String) Construct a new ResourceManagerException. Declaration public ResourceManagerException(string message) Parameters Type Name Description String message Message to describe the exception. ResourceManagerException(String, Exception) Construct a new ResourceManagerException. Declaration public ResourceManagerException(string message, Exception innerException) Parameters Type Name Description String message Message to describe the exception. Exception innerException Inner exception that caused this exception."
  },
  "api/UnityEngine.ResourceManagement.Exceptions.UnknownResourceProviderException.html": {
    "href": "api/UnityEngine.ResourceManagement.Exceptions.UnknownResourceProviderException.html",
    "title": "Class UnknownResourceProviderException | Addressables | 1.17.6-preview",
    "keywords": "Class UnknownResourceProviderException Exception returned when the IResourceProvider is not found for a location. Inheritance Object Exception ResourceManagerException UnknownResourceProviderException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Exceptions <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class UnknownResourceProviderException : ResourceManagerException, ISerializable, _Exception Constructors UnknownResourceProviderException() Construct a new UnknownResourceProviderException Declaration public UnknownResourceProviderException() UnknownResourceProviderException(SerializationInfo, StreamingContext) Construct a new UnknownResourceProviderException Declaration protected UnknownResourceProviderException(SerializationInfo message, StreamingContext context) Parameters Type Name Description SerializationInfo message Message to describe the exception. StreamingContext context Context related to the exception. UnknownResourceProviderException(String) Construct a new UnknownResourceProviderException Declaration public UnknownResourceProviderException(string message) Parameters Type Name Description String message Message to describe the exception. UnknownResourceProviderException(String, Exception) Construct a new UnknownResourceProviderException Declaration public UnknownResourceProviderException(string message, Exception innerException) Parameters Type Name Description String message Message to describe the exception. Exception innerException Inner exception that caused this exception. UnknownResourceProviderException(IResourceLocation) Construct a new UnknownResourceProviderException Declaration public UnknownResourceProviderException(IResourceLocation location) Parameters Type Name Description IResourceLocation location The location that caused the exception to be created. Properties Location The location that contains the provider id that was not found. Declaration public IResourceLocation Location { get; } Property Value Type Description IResourceLocation Message Returns a string describing this exception Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message Methods ToString() Returns string representation of exception. Declaration public override string ToString() Returns Type Description String String representation of exception. Overrides Exception.ToString()"
  },
  "api/UnityEngine.ResourceManagement.html": {
    "href": "api/UnityEngine.ResourceManagement.html",
    "title": "Namespace UnityEngine.ResourceManagement | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement Classes ResourceManager Entry point for ResourceManager API Structs ResourceManager.DiagnosticEventContext Container for information associated with a Diagnostics event. Interfaces IUpdateReceiver Providers that implement this interface will received Update calls from the ResourceManager each frame Enums ResourceManager.DiagnosticEventType Options for event types that will be sent by the ResourceManager"
  },
  "api/UnityEngine.ResourceManagement.IUpdateReceiver.html": {
    "href": "api/UnityEngine.ResourceManagement.IUpdateReceiver.html",
    "title": "Interface IUpdateReceiver | Addressables | 1.17.6-preview",
    "keywords": "Interface IUpdateReceiver Providers that implement this interface will received Update calls from the ResourceManager each frame Namespace : UnityEngine.ResourceManagement <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IUpdateReceiver Methods Update(Single) This will be called once per frame by the ResourceManager Declaration void Update(float unscaledDeltaTime) Parameters Type Name Description Single unscaledDeltaTime The unscaled delta time since the last invocation of this function"
  },
  "api/UnityEngine.ResourceManagement.ResourceLocations.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceLocations.html",
    "title": "Namespace UnityEngine.ResourceManagement.ResourceLocations | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.ResourceLocations Classes ResourceLocationBase Basic implementation of IResourceLocation Interfaces ILocationSizeData Interface for computing size of loading a location. IResourceLocation Contains enough information to load an asset (what/where/how/dependencies)"
  },
  "api/UnityEngine.ResourceManagement.ResourceLocations.ILocationSizeData.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceLocations.ILocationSizeData.html",
    "title": "Interface ILocationSizeData | Addressables | 1.17.6-preview",
    "keywords": "Interface ILocationSizeData Interface for computing size of loading a location. Namespace : UnityEngine.ResourceManagement.ResourceLocations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface ILocationSizeData Methods ComputeSize(IResourceLocation, ResourceManager) Compute the numder of bytes need to download for the specified location. Declaration long ComputeSize(IResourceLocation location, ResourceManager resourceManager) Parameters Type Name Description IResourceLocation location The location to compute the size for. ResourceManager resourceManager The object that contains all the resource locations. Returns Type Description Int64 The size in bytes of the data needed to be downloaded."
  },
  "api/UnityEngine.ResourceManagement.ResourceLocations.IResourceLocation.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceLocations.IResourceLocation.html",
    "title": "Interface IResourceLocation | Addressables | 1.17.6-preview",
    "keywords": "Interface IResourceLocation Contains enough information to load an asset (what/where/how/dependencies) Namespace : UnityEngine.ResourceManagement.ResourceLocations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IResourceLocation Properties Data Gets any data object associated with this locations Declaration object Data { get; } Property Value Type Description Object The object. Dependencies Gets the dependencies to other IResourceLocations Declaration IList<IResourceLocation> Dependencies { get; } Property Value Type Description IList < IResourceLocation > The dependencies. DependencyHashCode The precomputed hash code of the dependencies. Declaration int DependencyHashCode { get; } Property Value Type Description Int32 HasDependencies Gets the dependencies to other IResourceLocations Declaration bool HasDependencies { get; } Property Value Type Description Boolean The dependencies. InternalId Internal name used by the provider to load this location Declaration string InternalId { get; } Property Value Type Description String The identifier. PrimaryKey Primary address for this location. Declaration string PrimaryKey { get; } Property Value Type Description String ProviderId Matches the provider used to provide/load this location Declaration string ProviderId { get; } Property Value Type Description String The provider id. ResourceType The type of the resource for th location. Declaration Type ResourceType { get; } Property Value Type Description Type Methods Hash(Type) The hash of this location combined with the specified type. Declaration int Hash(Type resultType) Parameters Type Name Description Type resultType The type of the result. Returns Type Description Int32 The combined hash of the location and the type."
  },
  "api/UnityEngine.ResourceManagement.ResourceLocations.ResourceLocationBase.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceLocations.ResourceLocationBase.html",
    "title": "Class ResourceLocationBase | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceLocationBase Basic implementation of IResourceLocation Inheritance Object ResourceLocationBase Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceLocations <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ResourceLocationBase : IResourceLocation Constructors ResourceLocationBase(String, String, String, Type, IResourceLocation[]) Construct a new ResourceLocationBase. Declaration public ResourceLocationBase(string name, string id, string providerId, Type t, params IResourceLocation[] dependencies) Parameters Type Name Description String name The name of the location. This is usually set to the primary key, or \"address\" of the location. String id The internal id of the location. This is used by the IResourceProvider to identify the object to provide. For example this may contain the file path or url of an asset. String providerId The provider id. This is set to the FullName of the type of the provder class. Type t The type of the object to provide. IResourceLocation [] dependencies Locations for the dependencies of this location. Properties Data Data that is intended for the provider. Objects can be serialized during the build process to be used by the provider. An example of usage is cache usage data for AssetBundleProvider. Declaration public object Data { get; set; } Property Value Type Description Object Implements IResourceLocation.Data Dependencies List of dependencies that must be loaded before this location. This value may be null. Declaration public IList<IResourceLocation> Dependencies { get; } Property Value Type Description IList < IResourceLocation > Implements IResourceLocation.Dependencies DependencyHashCode Precomputed hash code of dependencies. Declaration public int DependencyHashCode { get; } Property Value Type Description Int32 Implements IResourceLocation.DependencyHashCode HasDependencies Convenience method to see if there are any dependencies. Declaration public bool HasDependencies { get; } Property Value Type Description Boolean Implements IResourceLocation.HasDependencies InternalId Internal id. Declaration public string InternalId { get; } Property Value Type Description String Implements IResourceLocation.InternalId PrimaryKey Primary address for this location. Declaration public string PrimaryKey { get; set; } Property Value Type Description String Implements IResourceLocation.PrimaryKey ProviderId Provider Id. This is usually set to the FullName property of the type of the provider class. Declaration public string ProviderId { get; } Property Value Type Description String Implements IResourceLocation.ProviderId ResourceType The type of the resource for th location. Declaration public Type ResourceType { get; } Property Value Type Description Type Implements IResourceLocation.ResourceType Methods ComputeDependencyHash() Compute the dependency hash for this location Declaration public void ComputeDependencyHash() Hash(Type) Compute the hash of this location for the specified type. Declaration public int Hash(Type t) Parameters Type Name Description Type t The type to hash with. Returns Type Description Int32 The combined hash code of the location and type. Implements IResourceLocation.Hash(Type) ToString() Returns the Internal name used by the provider to load this location Declaration public override string ToString() Returns Type Description String Overrides Object.ToString()"
  },
  "api/UnityEngine.ResourceManagement.ResourceManager.DiagnosticEventContext.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceManager.DiagnosticEventContext.html",
    "title": "Struct ResourceManager.DiagnosticEventContext | Addressables | 1.17.6-preview",
    "keywords": "Struct ResourceManager.DiagnosticEventContext Container for information associated with a Diagnostics event. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct DiagnosticEventContext Constructors DiagnosticEventContext(AsyncOperationHandle, ResourceManager.DiagnosticEventType, Int32, String, Object) Construct a new DiagnosticEventContext. Declaration public DiagnosticEventContext(AsyncOperationHandle op, ResourceManager.DiagnosticEventType type, int eventValue = 0, string error = null, object context = null) Parameters Type Name Description AsyncOperationHandle op Operation handle for the event. ResourceManager.DiagnosticEventType type The type of diagnostic event. Int32 eventValue The value for this event. String error Any error that occured. Object context Additional context data. Properties Context Addition data included with this event. Declaration public object Context { get; } Property Value Type Description Object Error Any error that occured. Declaration public string Error { get; } Property Value Type Description String EventValue The value for this event. Declaration public int EventValue { get; } Property Value Type Description Int32 Location The IResourceLocation being provided by the operation triggering this event. This value is null if the event is not while providing a resource. Declaration public IResourceLocation Location { get; } Property Value Type Description IResourceLocation OperationHandle Operation handle for the event. Declaration public AsyncOperationHandle OperationHandle { get; } Property Value Type Description AsyncOperationHandle Type The type of diagnostic event. Declaration public ResourceManager.DiagnosticEventType Type { get; } Property Value Type Description ResourceManager.DiagnosticEventType"
  },
  "api/UnityEngine.ResourceManagement.ResourceManager.DiagnosticEventType.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceManager.DiagnosticEventType.html",
    "title": "Enum ResourceManager.DiagnosticEventType | Addressables | 1.17.6-preview",
    "keywords": "Enum ResourceManager.DiagnosticEventType Options for event types that will be sent by the ResourceManager Namespace : UnityEngine.ResourceManagement <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum DiagnosticEventType Fields Name Description Value AsyncOperationFail Use to indicate that an operation failed. 0 AsyncOperationCreate Use to indicate that an operation was created. 1 AsyncOperationPercentComplete Use to indicate the percentage of completion for an operation was updated. 2 AsyncOperationComplete Use to indicate that an operation has completed. 3 AsyncOperationReferenceCount Use to indicate that the reference count of an operation was modified. 4 AsyncOperationDestroy Use to indicate that an operation was destroyed. 5"
  },
  "api/UnityEngine.ResourceManagement.ResourceManager.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceManager.html",
    "title": "Class ResourceManager | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceManager Entry point for ResourceManager API Inheritance Object ResourceManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class ResourceManager : IDisposable Constructors ResourceManager(IAllocationStrategy) Constructor for the resource manager. Declaration public ResourceManager(IAllocationStrategy alloc = null) Parameters Type Name Description IAllocationStrategy alloc The allocation strategy to use. Properties Allocator The allocation strategy object. Declaration public IAllocationStrategy Allocator { get; set; } Property Value Type Description IAllocationStrategy CertificateHandlerInstance The CertificateHandler instance object. Declaration public CertificateHandler CertificateHandlerInstance { get; set; } Property Value Type Description CertificateHandler ExceptionHandler Global exception handler. This will be called whenever an IAsyncOperation.OperationException is set to a non-null value. See the ResourceManager.ExceptionHandler documentation for more details. Declaration public static Action<AsyncOperationHandle, Exception> ExceptionHandler { get; set; } Property Value Type Description Action < AsyncOperationHandle , Exception > InternalIdTransformFunc Functor to transform internal ids before being used by the providers. See the TransformInternalId documentation for more details. Declaration public Func<IResourceLocation, string> InternalIdTransformFunc { get; set; } Property Value Type Description Func < IResourceLocation , String > ResourceProviders Gets the list of configured IResourceProvider objects. Resource Providers handle load and release operations for IResourceLocation objects. Declaration public IList<IResourceProvider> ResourceProviders { get; } Property Value Type Description IList < IResourceProvider > The resource providers list. Methods Acquire(AsyncOperationHandle) Increment reference count of operation handle. Declaration public void Acquire(AsyncOperationHandle handle) Parameters Type Name Description AsyncOperationHandle handle The handle to the resource to increment the reference count for. AddUpdateReceiver(IUpdateReceiver) Add an update reveiver. Declaration public void AddUpdateReceiver(IUpdateReceiver receiver) Parameters Type Name Description IUpdateReceiver receiver The object to add. The Update method will be called until the object is removed. CleanupSceneInstances(Scene) Releases all instances the given scence. Declaration public void CleanupSceneInstances(Scene scene) Parameters Type Name Description Scene scene The scene whose instances should be released. ClearDiagnosticCallbacks() Clears out the diagnostics callbacks handler. Declaration public void ClearDiagnosticCallbacks() ClearDiagnosticsCallback() Clears out the diagnostics callback handler. Declaration [Obsolete(\"ClearDiagnosticsCallback is Obsolete, use ClearDiagnosticCallbacks instead.\")] public void ClearDiagnosticsCallback() CreateChainOperation<TObject>(AsyncOperationHandle, Func<AsyncOperationHandle, AsyncOperationHandle<TObject>>) Create a chain operation to handle dependencies. Declaration public AsyncOperationHandle<TObject> CreateChainOperation<TObject>(AsyncOperationHandle dependentOp, Func<AsyncOperationHandle, AsyncOperationHandle<TObject>> callback) Parameters Type Name Description AsyncOperationHandle dependentOp The dependency operation. Func < AsyncOperationHandle , AsyncOperationHandle <TObject>> callback The callback method that will create the dependent operation from the dependency operation. Returns Type Description AsyncOperationHandle <TObject> The operation handle. Type Parameters Name Description TObject The type of operation handle to return. CreateChainOperation<TObject>(AsyncOperationHandle, Func<AsyncOperationHandle, AsyncOperationHandle<TObject>>, Boolean) Create a chain operation to handle dependencies. Declaration public AsyncOperationHandle<TObject> CreateChainOperation<TObject>(AsyncOperationHandle dependentOp, Func<AsyncOperationHandle, AsyncOperationHandle<TObject>> callback, bool releaseDependenciesOnFailure = true) Parameters Type Name Description AsyncOperationHandle dependentOp The dependency operation. Func < AsyncOperationHandle , AsyncOperationHandle <TObject>> callback The callback method that will create the dependent operation from the dependency operation. Boolean releaseDependenciesOnFailure Whether to release dependencies if the created operation has failed. Returns Type Description AsyncOperationHandle <TObject> The operation handle. Type Parameters Name Description TObject The type of operation handle to return. CreateChainOperation<TObject, TObjectDependency>(AsyncOperationHandle<TObjectDependency>, Func<AsyncOperationHandle<TObjectDependency>, AsyncOperationHandle<TObject>>) Create a chain operation to handle dependencies. Declaration public AsyncOperationHandle<TObject> CreateChainOperation<TObject, TObjectDependency>(AsyncOperationHandle<TObjectDependency> dependentOp, Func<AsyncOperationHandle<TObjectDependency>, AsyncOperationHandle<TObject>> callback) Parameters Type Name Description AsyncOperationHandle <TObjectDependency> dependentOp The dependency operation. Func < AsyncOperationHandle <TObjectDependency>, AsyncOperationHandle <TObject>> callback The callback method that will create the dependent operation from the dependency operation. Returns Type Description AsyncOperationHandle <TObject> The operation handle. Type Parameters Name Description TObject The type of operation handle to return. TObjectDependency The type of the dependency operation. CreateChainOperation<TObject, TObjectDependency>(AsyncOperationHandle<TObjectDependency>, Func<AsyncOperationHandle<TObjectDependency>, AsyncOperationHandle<TObject>>, Boolean) Create a chain operation to handle dependencies. Declaration public AsyncOperationHandle<TObject> CreateChainOperation<TObject, TObjectDependency>(AsyncOperationHandle<TObjectDependency> dependentOp, Func<AsyncOperationHandle<TObjectDependency>, AsyncOperationHandle<TObject>> callback, bool releaseDependenciesOnFailure = true) Parameters Type Name Description AsyncOperationHandle <TObjectDependency> dependentOp The dependency operation. Func < AsyncOperationHandle <TObjectDependency>, AsyncOperationHandle <TObject>> callback The callback method that will create the dependent operation from the dependency operation. Boolean releaseDependenciesOnFailure Whether to release dependencies if the created operation has failed. Returns Type Description AsyncOperationHandle <TObject> The operation handle. Type Parameters Name Description TObject The type of operation handle to return. TObjectDependency The type of the dependency operation. CreateCompletedOperation<TObject>(TObject, String) Creates an operation that has already completed with a specified result and error message./>. Declaration public AsyncOperationHandle<TObject> CreateCompletedOperation<TObject>(TObject result, string errorMsg) Parameters Type Name Description TObject result The result that the operation will provide. String errorMsg The error message if the operation should be in the failed state. Otherwise null or empty string. Returns Type Description AsyncOperationHandle <TObject> The operation handle used for the completed operation. Type Parameters Name Description TObject Object type. CreateGenericGroupOperation(List<AsyncOperationHandle>, Boolean) Create a group operation for a set of AsyncOperationHandles Declaration public AsyncOperationHandle<IList<AsyncOperationHandle>> CreateGenericGroupOperation(List<AsyncOperationHandle> operations, bool releasedCachedOpOnComplete = false) Parameters Type Name Description List < AsyncOperationHandle > operations The list of operations that need to complete. Boolean releasedCachedOpOnComplete Determine if the cached operation should be released or not. Returns Type Description AsyncOperationHandle < IList < AsyncOperationHandle >> The operation for the entire group CreateGroupOperation<T>(IList<IResourceLocation>) Create a group operation for a set of locations. Declaration public AsyncOperationHandle<IList<AsyncOperationHandle>> CreateGroupOperation<T>(IList<IResourceLocation> locations) Parameters Type Name Description IList < IResourceLocation > locations The list of locations to load. Returns Type Description AsyncOperationHandle < IList < AsyncOperationHandle >> The operation for the entire group. Type Parameters Name Description T The expected object type for the operations. Dispose() Disposes internal resources used by the resource manager Declaration public void Dispose() Implements IDisposable.Dispose() GetResourceProvider(Type, IResourceLocation) Gets the appropriate IResourceProvider for the given location and type . Declaration public IResourceProvider GetResourceProvider(Type t, IResourceLocation location) Parameters Type Name Description Type t The desired object type to be loaded from the provider. IResourceLocation location The resource location. Returns Type Description IResourceProvider The resource provider. Or null if an appropriate provider cannot be found ProvideInstance(IInstanceProvider, IResourceLocation, InstantiationParameters) Asynchronously instantiate a prefab (GameObject) at the specified location . Declaration public AsyncOperationHandle<GameObject> ProvideInstance(IInstanceProvider provider, IResourceLocation location, InstantiationParameters instantiateParameters) Parameters Type Name Description IInstanceProvider provider An implementation of IInstanceProvider that will be used to instantiate and destroy the GameObject. IResourceLocation location Location of the prefab. InstantiationParameters instantiateParameters A struct containing the parameters to pass the the Instantiation call. Returns Type Description AsyncOperationHandle < GameObject > Async operation that will complete when the prefab is instantiated. ProvideResource<TObject>(IResourceLocation) Load the TObject at the specified location . Declaration public AsyncOperationHandle<TObject> ProvideResource<TObject>(IResourceLocation location) Parameters Type Name Description IResourceLocation location Location to load. Returns Type Description AsyncOperationHandle <TObject> An async operation. Type Parameters Name Description TObject Object type to load. ProvideResources<TObject>(IList<IResourceLocation>, Action<TObject>) Asynchronously load all objects in the given collection of locations . If any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. Declaration public AsyncOperationHandle<IList<TObject>> ProvideResources<TObject>(IList<IResourceLocation> locations, Action<TObject> callback = null) Parameters Type Name Description IList < IResourceLocation > locations locations to load. Action <TObject> callback This callback will be invoked once for each object that is loaded. Returns Type Description AsyncOperationHandle < IList <TObject>> An async operation that will complete when all individual async load operations are complete. Type Parameters Name Description TObject Object type to load. ProvideResources<TObject>(IList<IResourceLocation>, Boolean, Action<TObject>) Asynchronously load all objects in the given collection of locations . Declaration public AsyncOperationHandle<IList<TObject>> ProvideResources<TObject>(IList<IResourceLocation> locations, bool releaseDependenciesOnFailure, Action<TObject> callback = null) Parameters Type Name Description IList < IResourceLocation > locations locations to load. Boolean releaseDependenciesOnFailure If all matching locations succeed, this parameter is ignored. When true, if any matching location fails, all loads and dependencies will be released. The returned .Result will be null, and .Status will be Failed. When false, if any matching location fails, the returned .Result will be an IList of size equal to the number of locations attempted. Any failed location will correlate to a null in the IList, while successful loads will correlate to a TObject in the list. The .Status will still be Failed. When true, op does not need to be released if anything fails, when false, it must always be released. Action <TObject> callback This callback will be invoked once for each object that is loaded. Returns Type Description AsyncOperationHandle < IList <TObject>> An async operation that will complete when all individual async load operations are complete. Type Parameters Name Description TObject Object type to load. ProvideScene(ISceneProvider, IResourceLocation, LoadSceneMode, Boolean, Int32) Load a scene at a specificed resource location. Declaration public AsyncOperationHandle<SceneInstance> ProvideScene(ISceneProvider sceneProvider, IResourceLocation location, LoadSceneMode loadMode, bool activateOnLoad, int priority) Parameters Type Name Description ISceneProvider sceneProvider The scene provider instance. IResourceLocation location The location of the scene. LoadSceneMode loadMode The load mode for the scene. Boolean activateOnLoad If false, the scene will be loaded in the background and not activated when complete. Int32 priority The priority for the load operation. Returns Type Description AsyncOperationHandle < SceneInstance > Async operation handle that will complete when the scene is loaded. If activateOnLoad is false, then Activate() will need to be called on the SceneInstance returned. RegisterDiagnosticCallback(Action<AsyncOperationHandle, ResourceManager.DiagnosticEventType, Int32, Object>) Register a handler for diagnostic events. Declaration [Obsolete] public void RegisterDiagnosticCallback(Action<AsyncOperationHandle, ResourceManager.DiagnosticEventType, int, object> func) Parameters Type Name Description Action < AsyncOperationHandle , ResourceManager.DiagnosticEventType , Int32 , Object > func The event handler function. RegisterDiagnosticCallback(Action<ResourceManager.DiagnosticEventContext>) Register a handler for diagnostic events. Declaration public void RegisterDiagnosticCallback(Action<ResourceManager.DiagnosticEventContext> func) Parameters Type Name Description Action < ResourceManager.DiagnosticEventContext > func The event handler function. Release(AsyncOperationHandle) Release the operation associated with the specified handle Declaration public void Release(AsyncOperationHandle handle) Parameters Type Name Description AsyncOperationHandle handle The handle to release. ReleaseScene(ISceneProvider, AsyncOperationHandle<SceneInstance>) Release a scene. Declaration public AsyncOperationHandle<SceneInstance> ReleaseScene(ISceneProvider sceneProvider, AsyncOperationHandle<SceneInstance> sceneLoadHandle) Parameters Type Name Description ISceneProvider sceneProvider The scene provider. AsyncOperationHandle < SceneInstance > sceneLoadHandle The operation handle used to load the scene. Returns Type Description AsyncOperationHandle < SceneInstance > An operation handle for the unload. RemoveUpdateReciever(IUpdateReceiver) Remove update receiver. Declaration public void RemoveUpdateReciever(IUpdateReceiver receiver) Parameters Type Name Description IUpdateReceiver receiver The object to remove. StartOperation<TObject>(AsyncOperationBase<TObject>, AsyncOperationHandle) Registers an operation with the ResourceManager. The operation will be executed when the dependency completes. This should only be used when creating custom operations. Declaration public AsyncOperationHandle<TObject> StartOperation<TObject>(AsyncOperationBase<TObject> operation, AsyncOperationHandle dependency) Parameters Type Name Description AsyncOperationBase <TObject> operation The custom AsyncOperationBase object AsyncOperationHandle dependency Execution of the operation will not occur until this handle completes. A default handle can be passed if no dependency is required. Returns Type Description AsyncOperationHandle <TObject> The AsyncOperationHandle used to access the result and status of the operation. Type Parameters Name Description TObject Object type associated with this operation. TransformInternalId(IResourceLocation) Checks for an internal id transform function and uses it to modify the internal id value. Declaration public string TransformInternalId(IResourceLocation location) Parameters Type Name Description IResourceLocation location The location to transform the internal id of. Returns Type Description String If a transform func is set, use it to pull the local id. otheriwse the InternalId property of the location is used. UnregisterDiagnosticCallback(Action<ResourceManager.DiagnosticEventContext>) Unregister a handler for diagnostic events. Declaration public void UnregisterDiagnosticCallback(Action<ResourceManager.DiagnosticEventContext> func) Parameters Type Name Description Action < ResourceManager.DiagnosticEventContext > func The event handler function."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider.html",
    "title": "Class AssetBundleProvider | Addressables | 1.17.6-preview",
    "keywords": "Class AssetBundleProvider IResourceProvider for asset bundles. Loads bundles via UnityWebRequestAssetBundle API if the internalId starts with \"http\". If not, it will load the bundle via AssetBundle.LoadFromFileAsync. Inheritance Object ResourceProviderBase AssetBundleProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AssetBundleProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Methods GetDefaultType(IResourceLocation) Get the default type of object that this provider can provide. Declaration public override Type GetDefaultType(IResourceLocation location) Parameters Type Name Description IResourceLocation location Returns Type Description Type Overrides ResourceProviderBase.GetDefaultType(IResourceLocation) Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public override void Provide(ProvideHandle providerInterface) Parameters Type Name Description ProvideHandle providerInterface Overrides ResourceProviderBase.Provide(ProvideHandle) Release(IResourceLocation, Object) Releases the asset bundle via AssetBundle.Unload(true). Declaration public override void Release(IResourceLocation location, object asset) Parameters Type Name Description IResourceLocation location The location of the asset to release Object asset The asset in question Overrides ResourceProviderBase.Release(IResourceLocation, Object)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.AssetBundleRequestOptions.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.AssetBundleRequestOptions.html",
    "title": "Class AssetBundleRequestOptions | Addressables | 1.17.6-preview",
    "keywords": "Class AssetBundleRequestOptions Contains cache information to be used by the AssetBundleProvider Inheritance Object AssetBundleRequestOptions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public class AssetBundleRequestOptions : ILocationSizeData Properties BundleName The name of the original bundle. This does not contain the appended hash. Declaration public string BundleName { get; set; } Property Value Type Description String BundleSize The size of the bundle, in bytes. Declaration public long BundleSize { get; set; } Property Value Type Description Int64 ChunkedTransfer Indicates whether the UnityWebRequest system should employ the HTTP/1.1 chunked-transfer encoding method. Declaration public bool ChunkedTransfer { get; set; } Property Value Type Description Boolean ClearOtherCachedVersionsWhenLoaded If false, the CRC will not be used when loading bundles from the cache. Declaration public bool ClearOtherCachedVersionsWhenLoaded { get; set; } Property Value Type Description Boolean Crc CRC value of the bundle. Declaration public uint Crc { get; set; } Property Value Type Description UInt32 Hash Hash value of the asset bundle. Declaration public string Hash { get; set; } Property Value Type Description String RedirectLimit Indicates the number of redirects which this UnityWebRequest will follow before halting with a “Redirect Limit Exceeded” system error. Declaration public int RedirectLimit { get; set; } Property Value Type Description Int32 RetryCount Indicates the number of times the request will be retried. Declaration public int RetryCount { get; set; } Property Value Type Description Int32 Timeout Sets UnityWebRequest to attempt to abort after the number of seconds in timeout have passed. Declaration public int Timeout { get; set; } Property Value Type Description Int32 UseCrcForCachedBundle If false, the CRC will not be used when loading bundles from the cache. Declaration public bool UseCrcForCachedBundle { get; set; } Property Value Type Description Boolean Methods ComputeSize(IResourceLocation, ResourceManager) Computes the amount of data needed to be downloaded for this bundle. Declaration public virtual long ComputeSize(IResourceLocation location, ResourceManager resourceManager) Parameters Type Name Description IResourceLocation location The location of the bundle. ResourceManager resourceManager The object that contains all the resource locations. Returns Type Description Int64 The size in bytes of the bundle that is needed to be downloaded. If the local cache contains the bundle or it is a local bundle, 0 will be returned. Implements ILocationSizeData.ComputeSize(IResourceLocation, ResourceManager)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.AtlasSpriteProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.AtlasSpriteProvider.html",
    "title": "Class AtlasSpriteProvider | Addressables | 1.17.6-preview",
    "keywords": "Class AtlasSpriteProvider Provides sprites from atlases Inheritance Object ResourceProviderBase AtlasSpriteProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.Release(IResourceLocation, Object) ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class AtlasSpriteProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Methods Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public override void Provide(ProvideHandle providerInterface) Parameters Type Name Description ProvideHandle providerInterface Overrides ResourceProviderBase.Provide(ProvideHandle)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider.html",
    "title": "Class BundledAssetProvider | Addressables | 1.17.6-preview",
    "keywords": "Class BundledAssetProvider Provides assets stored in an asset bundle. Inheritance Object ResourceProviderBase BundledAssetProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.Release(IResourceLocation, Object) ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class BundledAssetProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Methods Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public override void Provide(ProvideHandle provideHandle) Parameters Type Name Description ProvideHandle provideHandle Contains all data needed to provide the requested object. Overrides ResourceProviderBase.Provide(ProvideHandle)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.html",
    "title": "Namespace UnityEngine.ResourceManagement.ResourceProviders | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.ResourceProviders Classes AssetBundleProvider IResourceProvider for asset bundles. Loads bundles via UnityWebRequestAssetBundle API if the internalId starts with \"http\". If not, it will load the bundle via AssetBundle.LoadFromFileAsync. AssetBundleRequestOptions Contains cache information to be used by the AssetBundleProvider AtlasSpriteProvider Provides sprites from atlases BundledAssetProvider Provides assets stored in an asset bundle. InstanceProvider Basic implementation of IInstanceProvider. JsonAssetProvider Converts JSON serialized text into the requested object. LegacyResourcesProvider Provides assets loaded via Resources.LoadAsync API. ResourceProviderBase Base class for IResourceProvider. SceneProvider Implementation if ISceneProvider TextDataProvider Provides raw text from a local or remote URL. Structs InstantiationParameters Class that contains properties to apply to instantiated objects. ProvideHandle Container for all data need by providers to fulfill requests. SceneInstance Wrapper for scenes. This is used to allow access to the AsyncOperation and delayed activation. Interfaces IAssetBundleResource Wrapper for asset bundles. IInstanceProvider Interface that provides instances of objects. This is used in ResourceManager.Instantiate* calls. IResourceProvider Resoure Providers handle loading (Provide) and unloading (Release) of objects ISceneProvider Interface for scene providers. Enums ProviderBehaviourFlags Options for resource provider behavior."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.IAssetBundleResource.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.IAssetBundleResource.html",
    "title": "Interface IAssetBundleResource | Addressables | 1.17.6-preview",
    "keywords": "Interface IAssetBundleResource Wrapper for asset bundles. Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IAssetBundleResource Methods GetAssetBundle() Retrieves the asset bundle. Declaration AssetBundle GetAssetBundle() Returns Type Description AssetBundle Returns the asset bundle."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.IInstanceProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.IInstanceProvider.html",
    "title": "Interface IInstanceProvider | Addressables | 1.17.6-preview",
    "keywords": "Interface IInstanceProvider Interface that provides instances of objects. This is used in ResourceManager.Instantiate* calls. Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IInstanceProvider Methods ProvideInstance(ResourceManager, AsyncOperationHandle<GameObject>, InstantiationParameters) Provide an instance of the gameobject contained in the prefabHandle. Declaration GameObject ProvideInstance(ResourceManager resourceManager, AsyncOperationHandle<GameObject> prefabHandle, InstantiationParameters instantiateParameters) Parameters Type Name Description ResourceManager resourceManager The object that contains all the resource locations. AsyncOperationHandle < GameObject > prefabHandle The operation handle for the prefab to instantiate. InstantiationParameters instantiateParameters The parameters to use for instantation. Returns Type Description GameObject The instantiated object. ReleaseInstance(ResourceManager, GameObject) Release an instance. Declaration void ReleaseInstance(ResourceManager resourceManager, GameObject instance) Parameters Type Name Description ResourceManager resourceManager The object that contains all the resource locations. GameObject instance The instance to release."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.InstanceProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.InstanceProvider.html",
    "title": "Class InstanceProvider | Addressables | 1.17.6-preview",
    "keywords": "Class InstanceProvider Basic implementation of IInstanceProvider. Inheritance Object InstanceProvider Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class InstanceProvider : IInstanceProvider Methods ProvideInstance(ResourceManager, AsyncOperationHandle<GameObject>, InstantiationParameters) Provide an instance of the gameobject contained in the prefabHandle. Declaration public GameObject ProvideInstance(ResourceManager resourceManager, AsyncOperationHandle<GameObject> prefabHandle, InstantiationParameters instantiateParameters) Parameters Type Name Description ResourceManager resourceManager The object that contains all the resource locations. AsyncOperationHandle < GameObject > prefabHandle The operation handle for the prefab to instantiate. InstantiationParameters instantiateParameters The parameters to use for instantation. Returns Type Description GameObject The instantiated object. Implements IInstanceProvider.ProvideInstance(ResourceManager, AsyncOperationHandle<GameObject>, InstantiationParameters) ReleaseInstance(ResourceManager, GameObject) Release an instance. Declaration public void ReleaseInstance(ResourceManager resourceManager, GameObject instance) Parameters Type Name Description ResourceManager resourceManager The object that contains all the resource locations. GameObject instance The instance to release. Implements IInstanceProvider.ReleaseInstance(ResourceManager, GameObject)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.InstantiationParameters.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.InstantiationParameters.html",
    "title": "Struct InstantiationParameters | Addressables | 1.17.6-preview",
    "keywords": "Struct InstantiationParameters Class that contains properties to apply to instantiated objects. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct InstantiationParameters Constructors InstantiationParameters(Transform, Boolean) Create a new InstantationParameters class that will set the parent transform and use the prefab transform. Declaration public InstantiationParameters(Transform parent, bool instantiateInWorldSpace) Parameters Type Name Description Transform parent Transform to set as the parent of the instantiated object. Boolean instantiateInWorldSpace Flag to tell the IInstanceProvider whether to set the position and rotation on new instances. InstantiationParameters(Vector3, Quaternion, Transform) Create a new InstantationParameters class that will set the position, rotation, and Transform parent of the instance. Declaration public InstantiationParameters(Vector3 position, Quaternion rotation, Transform parent) Parameters Type Name Description Vector3 position Position relative to the parent to set on the instance. Quaternion rotation Rotation relative to the parent to set on the instance. Transform parent Transform to set as the parent of the instantiated object. Properties InstantiateInWorldPosition When setting the parent Transform, this sets whether to preserve instance transform relative to world space or relative to the parent. Declaration public bool InstantiateInWorldPosition { get; } Property Value Type Description Boolean Parent Transform to set as the parent of the instantiated object. Declaration public Transform Parent { get; } Property Value Type Description Transform Position Position in world space to instantiate object. Declaration public Vector3 Position { get; } Property Value Type Description Vector3 Rotation Rotation in world space to instantiate object. Declaration public Quaternion Rotation { get; } Property Value Type Description Quaternion SetPositionRotation Flag to tell the IInstanceProvider whether to set the position and rotation on new instances. Declaration public bool SetPositionRotation { get; } Property Value Type Description Boolean Methods Instantiate<TObject>(TObject) Instantiate an object with the parameters of this object. Declaration public TObject Instantiate<TObject>(TObject source) where TObject : Object Parameters Type Name Description TObject source Object to instantiate. Returns Type Description TObject Returns the instantiated object. Type Parameters Name Description TObject Object type. This type must be of type UnityEngine.Object."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.IResourceProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.IResourceProvider.html",
    "title": "Interface IResourceProvider | Addressables | 1.17.6-preview",
    "keywords": "Interface IResourceProvider Resoure Providers handle loading (Provide) and unloading (Release) of objects Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IResourceProvider Properties BehaviourFlags Custom flags for the provider. Declaration ProviderBehaviourFlags BehaviourFlags { get; } Property Value Type Description ProviderBehaviourFlags ProviderId Unique identifier for this provider, used by Resource Locations to find a suitable Provider Declaration string ProviderId { get; } Property Value Type Description String The provider identifier. Methods CanProvide(Type, IResourceLocation) Determine if this provider can provide the specified object type from the specified location. Declaration bool CanProvide(Type type, IResourceLocation location) Parameters Type Name Description Type type The type of object. IResourceLocation location The resource location of the object. Returns Type Description Boolean True if this provider can create the specified object. GetDefaultType(IResourceLocation) The default type of object that this provider can provide. Declaration Type GetDefaultType(IResourceLocation location) Parameters Type Name Description IResourceLocation location The location that can be used to determine the type. Returns Type Description Type The type of object that can be provided. Provide(ProvideHandle) Tells the provide that it needs to provide a resource and report the results through the passed provideHandle. When this is called, all dependencies have completed and are available through the provideHandle. Declaration void Provide(ProvideHandle provideHandle) Parameters Type Name Description ProvideHandle provideHandle A handle used to update the operation. Release(IResourceLocation, Object) Release and/or unload the given resource location and asset Declaration void Release(IResourceLocation location, object asset) Parameters Type Name Description IResourceLocation location Location to release. Object asset Asset to unload."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.ISceneProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.ISceneProvider.html",
    "title": "Interface ISceneProvider | Addressables | 1.17.6-preview",
    "keywords": "Interface ISceneProvider Interface for scene providers. Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface ISceneProvider Methods ProvideScene(ResourceManager, IResourceLocation, LoadSceneMode, Boolean, Int32) Load a scene at a specified resource location. Declaration AsyncOperationHandle<SceneInstance> ProvideScene(ResourceManager resourceManager, IResourceLocation location, LoadSceneMode loadMode, bool activateOnLoad, int priority) Parameters Type Name Description ResourceManager resourceManager The resource manager to use for loading dependencies. IResourceLocation location The location of the scene. LoadSceneMode loadMode Load mode for the scene. Boolean activateOnLoad If true, the scene is activated as soon as it finished loading. Otherwise it needs to be activated via the returned SceneInstance object. Int32 priority The loading priority for the load. Returns Type Description AsyncOperationHandle < SceneInstance > An operation handle for the loading of the scene. The scene is wrapped in a SceneInstance object to support delayed activation. ReleaseScene(ResourceManager, AsyncOperationHandle<SceneInstance>) Release a scene. Declaration AsyncOperationHandle<SceneInstance> ReleaseScene(ResourceManager resourceManager, AsyncOperationHandle<SceneInstance> sceneLoadHandle) Parameters Type Name Description ResourceManager resourceManager The resource manager to use for loading dependencies. AsyncOperationHandle < SceneInstance > sceneLoadHandle The operation handle used to load the scene. Returns Type Description AsyncOperationHandle < SceneInstance > An operation handle for the unload."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.JsonAssetProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.JsonAssetProvider.html",
    "title": "Class JsonAssetProvider | Addressables | 1.17.6-preview",
    "keywords": "Class JsonAssetProvider Converts JSON serialized text into the requested object. Inheritance Object ResourceProviderBase TextDataProvider JsonAssetProvider Inherited Members TextDataProvider.IgnoreFailures TextDataProvider.Provide(ProvideHandle) ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.Release(IResourceLocation, Object) ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class JsonAssetProvider : TextDataProvider, IResourceProvider, IInitializableObject Methods Convert(Type, String) Converts raw text into requested object type via JSONUtility.FromJson. Declaration public override object Convert(Type type, string text) Parameters Type Name Description Type type The object type the text is converted to. String text The text to convert. Returns Type Description Object Returns the converted object. Overrides TextDataProvider.Convert(Type, String)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider.html",
    "title": "Class LegacyResourcesProvider | Addressables | 1.17.6-preview",
    "keywords": "Class LegacyResourcesProvider Provides assets loaded via Resources.LoadAsync API. Inheritance Object ResourceProviderBase LegacyResourcesProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class LegacyResourcesProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Methods Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public override void Provide(ProvideHandle pi) Parameters Type Name Description ProvideHandle pi Overrides ResourceProviderBase.Provide(ProvideHandle) Release(IResourceLocation, Object) Release the specified object that was created from the specified location. Declaration public override void Release(IResourceLocation location, object asset) Parameters Type Name Description IResourceLocation location The location of the object Object asset Overrides ResourceProviderBase.Release(IResourceLocation, Object)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.ProvideHandle.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.ProvideHandle.html",
    "title": "Struct ProvideHandle | Addressables | 1.17.6-preview",
    "keywords": "Struct ProvideHandle Container for all data need by providers to fulfill requests. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct ProvideHandle Properties DependencyCount Number of dependencies. Declaration public int DependencyCount { get; } Property Value Type Description Int32 Location The location for the request. Declaration public IResourceLocation Location { get; } Property Value Type Description IResourceLocation ResourceManager The ResourceManager used to create the operation. Declaration public ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager Type The requested object type. Declaration public Type Type { get; } Property Value Type Description Type Methods Complete<T>(T, Boolean, Exception) Called to complete the operation. Declaration public void Complete<T>(T result, bool status, Exception exception) Parameters Type Name Description T result The result object. Boolean status True if the operation was successful, false otherwise. Exception exception The exception if the operation failed. Type Parameters Name Description T The type of object requested. GetDependencies(IList<Object>) Get the depedency objects. Declaration public void GetDependencies(IList<object> list) Parameters Type Name Description IList < Object > list The list of dependecies to fill in. GetDependency<TDepObject>(Int32) Get a specific dependency object. Declaration public TDepObject GetDependency<TDepObject>(int index) Parameters Type Name Description Int32 index The index of the dependency. Returns Type Description TDepObject The dependency object. Type Parameters Name Description TDepObject The dependency type. SetDownloadProgressCallbacks(Func<DownloadStatus>) Set the func for handling download progress requests. Declaration public void SetDownloadProgressCallbacks(Func<DownloadStatus> callback) Parameters Type Name Description Func < DownloadStatus > callback The callback function. SetProgressCallback(Func<Single>) Set the func for handling progress requests. Declaration public void SetProgressCallback(Func<float> callback) Parameters Type Name Description Func < Single > callback The callback function. SetWaitForCompletionCallback(Func<Boolean>) Set the func for handling a request to wait for the completion of the operation Declaration public void SetWaitForCompletionCallback(Func<bool> callback) Parameters Type Name Description Func < Boolean > callback The callback function."
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.ProviderBehaviourFlags.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.ProviderBehaviourFlags.html",
    "title": "Enum ProviderBehaviourFlags | Addressables | 1.17.6-preview",
    "keywords": "Enum ProviderBehaviourFlags Options for resource provider behavior. Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public enum ProviderBehaviourFlags Fields Name Description Value None Indicates that the provider does not have extra specified behavior. 0 CanProvideWithFailedDependencies Indicates that the provider will still fulfill requests even with failed dependencies. 1"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.ResourceProviderBase.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.ResourceProviderBase.html",
    "title": "Class ResourceProviderBase | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceProviderBase Base class for IResourceProvider. Inheritance Object ResourceProviderBase ContentCatalogProvider AssetBundleProvider AtlasSpriteProvider BundledAssetProvider LegacyResourcesProvider TextDataProvider Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public abstract class ResourceProviderBase : IResourceProvider, IInitializableObject Fields m_BehaviourFlags The extra behavior of the provider. Declaration protected ProviderBehaviourFlags m_BehaviourFlags Field Value Type Description ProviderBehaviourFlags m_ProviderId The unique identifier of the provider. Declaration protected string m_ProviderId Field Value Type Description String Properties ProviderId Unique identifier for this provider, used by Resource Locations to find a suitable Provider Declaration public virtual string ProviderId { get; } Property Value Type Description String The provider identifier. Implements IResourceProvider.ProviderId Methods CanProvide(Type, IResourceLocation) Determine if this provider can provide the specified object type from the specified location. Declaration public virtual bool CanProvide(Type t, IResourceLocation location) Parameters Type Name Description Type t IResourceLocation location The resource location of the object. Returns Type Description Boolean True if this provider can create the specified object. Implements IResourceProvider.CanProvide(Type, IResourceLocation) GetDefaultType(IResourceLocation) Get the default type of object that this provider can provide. Declaration public virtual Type GetDefaultType(IResourceLocation location) Parameters Type Name Description IResourceLocation location Returns Type Description Type Implements IResourceProvider.GetDefaultType(IResourceLocation) Initialize(String, String) Initialize a constructed object. Declaration public virtual bool Initialize(string id, string data) Parameters Type Name Description String id The id of the object. String data Serialized data for the object. Returns Type Description Boolean The result of the initialization. Implements IInitializableObject.Initialize(String, String) InitializeAsync(ResourceManager, String, String) Async operation for initializing a constructed object. Declaration public virtual AsyncOperationHandle<bool> InitializeAsync(ResourceManager rm, string id, string data) Parameters Type Name Description ResourceManager rm The current instance of Resource Manager. String id The id of the object. String data Serialized data for the object. Returns Type Description AsyncOperationHandle < Boolean > Async operation Implements IInitializableObject.InitializeAsync(ResourceManager, String, String) Provide(ProvideHandle) Provide the object specified in the provideHandle. Declaration public abstract void Provide(ProvideHandle provideHandle) Parameters Type Name Description ProvideHandle provideHandle Contains all data needed to provide the requested object. Implements IResourceProvider.Provide(ProvideHandle) Release(IResourceLocation, Object) Release the specified object that was created from the specified location. Declaration public virtual void Release(IResourceLocation location, object obj) Parameters Type Name Description IResourceLocation location The location of the object Object obj The object to release. Implements IResourceProvider.Release(IResourceLocation, Object) ToString() Converts information about the resource provider to a formatted string. Declaration public override string ToString() Returns Type Description String Returns information about the resource provider. Overrides Object.ToString() Explicit Interface Implementations IResourceProvider.BehaviourFlags Declaration ProviderBehaviourFlags IResourceProvider.BehaviourFlags { get; } Returns Type Description ProviderBehaviourFlags Implements IResourceProvider.BehaviourFlags"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.SceneInstance.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.SceneInstance.html",
    "title": "Struct SceneInstance | Addressables | 1.17.6-preview",
    "keywords": "Struct SceneInstance Wrapper for scenes. This is used to allow access to the AsyncOperation and delayed activation. Inherited Members ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public struct SceneInstance Properties Scene The scene instance. Declaration public Scene Scene { get; } Property Value Type Description Scene Methods Activate() Activate the scene via the AsyncOperation. Declaration [Obsolete(\"Activate() has been deprecated. Please use ActivateAsync().\")] public void Activate() ActivateAsync() Activate the scene via the AsyncOperation. This is the scene loading AsyncOperation provided by the engine. The documentation for AsyncOperation can be found here: https://docs.unity3d.com/ScriptReference/AsyncOperation.html Declaration public AsyncOperation ActivateAsync() Returns Type Description AsyncOperation The scene load operation. Equals(Object) The scene instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj Returns Type Description Boolean Overrides ValueType.Equals(Object) GetHashCode() The scene instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides ValueType.GetHashCode()"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.SceneProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.SceneProvider.html",
    "title": "Class SceneProvider | Addressables | 1.17.6-preview",
    "keywords": "Class SceneProvider Implementation if ISceneProvider Inheritance Object SceneProvider Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class SceneProvider : ISceneProvider Methods ProvideScene(ResourceManager, IResourceLocation, LoadSceneMode, Boolean, Int32) Load a scene at a specified resource location. Declaration public AsyncOperationHandle<SceneInstance> ProvideScene(ResourceManager resourceManager, IResourceLocation location, LoadSceneMode loadMode, bool activateOnLoad, int priority) Parameters Type Name Description ResourceManager resourceManager The resource manager to use for loading dependencies. IResourceLocation location The location of the scene. LoadSceneMode loadMode Load mode for the scene. Boolean activateOnLoad If true, the scene is activated as soon as it finished loading. Otherwise it needs to be activated via the returned SceneInstance object. Int32 priority The loading priority for the load. Returns Type Description AsyncOperationHandle < SceneInstance > An operation handle for the loading of the scene. The scene is wrapped in a SceneInstance object to support delayed activation. Implements ISceneProvider.ProvideScene(ResourceManager, IResourceLocation, LoadSceneMode, Boolean, Int32) ReleaseScene(ResourceManager, AsyncOperationHandle<SceneInstance>) Release a scene. Declaration public AsyncOperationHandle<SceneInstance> ReleaseScene(ResourceManager resourceManager, AsyncOperationHandle<SceneInstance> sceneLoadHandle) Parameters Type Name Description ResourceManager resourceManager The resource manager to use for loading dependencies. AsyncOperationHandle < SceneInstance > sceneLoadHandle The operation handle used to load the scene. Returns Type Description AsyncOperationHandle < SceneInstance > An operation handle for the unload. Implements ISceneProvider.ReleaseScene(ResourceManager, AsyncOperationHandle<SceneInstance>)"
  },
  "api/UnityEngine.ResourceManagement.ResourceProviders.TextDataProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.ResourceProviders.TextDataProvider.html",
    "title": "Class TextDataProvider | Addressables | 1.17.6-preview",
    "keywords": "Class TextDataProvider Provides raw text from a local or remote URL. Inheritance Object ResourceProviderBase TextDataProvider JsonAssetProvider Inherited Members ResourceProviderBase.m_ProviderId ResourceProviderBase.m_BehaviourFlags ResourceProviderBase.ProviderId ResourceProviderBase.Initialize(String, String) ResourceProviderBase.CanProvide(Type, IResourceLocation) ResourceProviderBase.ToString() ResourceProviderBase.Release(IResourceLocation, Object) ResourceProviderBase.GetDefaultType(IResourceLocation) ResourceProviderBase.InitializeAsync(ResourceManager, String, String) ResourceProviderBase.IResourceProvider.BehaviourFlags Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.ResourceProviders <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class TextDataProvider : ResourceProviderBase, IResourceProvider, IInitializableObject Properties IgnoreFailures Controls whether errors are logged - this is disabled when trying to load from the local cache since failures are expected Declaration public bool IgnoreFailures { get; set; } Property Value Type Description Boolean Methods Convert(Type, String) Method to convert the text into the object type requested. Usually the text contains a JSON formatted serialized object. Declaration public virtual object Convert(Type type, string text) Parameters Type Name Description Type type The object type the text is converted to. String text The text to be converted. Returns Type Description Object The converted object. Provide(ProvideHandle) Provides raw text data from the location. Declaration public override void Provide(ProvideHandle provideHandle) Parameters Type Name Description ProvideHandle provideHandle The data needed by the provider to perform the load. Overrides ResourceProviderBase.Provide(ProvideHandle)"
  },
  "api/UnityEngine.ResourceManagement.Util.ComponentSingleton-1.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.ComponentSingleton-1.html",
    "title": "Class ComponentSingleton<T> | Addressables | 1.17.6-preview",
    "keywords": "Class ComponentSingleton<T> Creates a singleton. Inheritance Object Object Component Behaviour MonoBehaviour ComponentSingleton<T> DiagnosticEventCollectorSingleton Inherited Members MonoBehaviour.IsInvoking() MonoBehaviour.CancelInvoke() MonoBehaviour.Invoke(String, Single) MonoBehaviour.InvokeRepeating(String, Single, Single) MonoBehaviour.CancelInvoke(String) MonoBehaviour.IsInvoking(String) MonoBehaviour.StartCoroutine(String) MonoBehaviour.StartCoroutine(String, Object) MonoBehaviour.StartCoroutine(IEnumerator) MonoBehaviour.StartCoroutine_Auto(IEnumerator) MonoBehaviour.StopCoroutine(IEnumerator) MonoBehaviour.StopCoroutine(Coroutine) MonoBehaviour.StopCoroutine(String) MonoBehaviour.StopAllCoroutines() MonoBehaviour.print(Object) MonoBehaviour.useGUILayout MonoBehaviour.runInEditMode Behaviour.enabled Behaviour.isActiveAndEnabled Component.GetComponent(Type) Component.GetComponent<T>() Component.TryGetComponent(Type, Component) Component.TryGetComponent<T>(T) Component.GetComponent(String) Component.GetComponentInChildren(Type, Boolean) Component.GetComponentInChildren(Type) Component.GetComponentInChildren<T>(Boolean) Component.GetComponentInChildren<T>() Component.GetComponentsInChildren(Type, Boolean) Component.GetComponentsInChildren(Type) Component.GetComponentsInChildren<T>(Boolean) Component.GetComponentsInChildren<T>(Boolean, List<T>) Component.GetComponentsInChildren<T>() Component.GetComponentsInChildren<T>(List<T>) Component.GetComponentInParent(Type) Component.GetComponentInParent<T>() Component.GetComponentsInParent(Type, Boolean) Component.GetComponentsInParent(Type) Component.GetComponentsInParent<T>(Boolean) Component.GetComponentsInParent<T>(Boolean, List<T>) Component.GetComponentsInParent<T>() Component.GetComponents(Type) Component.GetComponents(Type, List<Component>) Component.GetComponents<T>(List<T>) Component.GetComponents<T>() Component.CompareTag(String) Component.SendMessageUpwards(String, Object, SendMessageOptions) Component.SendMessageUpwards(String, Object) Component.SendMessageUpwards(String) Component.SendMessageUpwards(String, SendMessageOptions) Component.SendMessage(String, Object) Component.SendMessage(String) Component.SendMessage(String, Object, SendMessageOptions) Component.SendMessage(String, SendMessageOptions) Component.BroadcastMessage(String, Object, SendMessageOptions) Component.BroadcastMessage(String, Object) Component.BroadcastMessage(String) Component.BroadcastMessage(String, SendMessageOptions) Component.transform Component.gameObject Component.tag Component.rigidbody Component.rigidbody2D Component.camera Component.light Component.animation Component.constantForce Component.renderer Component.audio Component.networkView Component.collider Component.collider2D Component.hingeJoint Component.particleSystem Object.GetInstanceID() Object.GetHashCode() Object.Equals(Object) Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, Boolean) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, Boolean) Object.Destroy(Object, Single) Object.Destroy(Object) Object.DestroyImmediate(Object, Boolean) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, Single) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.FindObjectsOfTypeAll(Type) Object.FindObjectOfType(Type) Object.ToString() Object.name Object.hideFlags Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [ExecuteInEditMode] public abstract class ComponentSingleton<T> : MonoBehaviour where T : ComponentSingleton<T> Type Parameters Name Description T The singleton type. Properties Exists Indicates whether or not there is an existing instance of the singleton. Declaration public static bool Exists { get; } Property Value Type Description Boolean Instance Stores the instance of the singleton. Declaration public static T Instance { get; } Property Value Type Description T Methods DestroySingleton() Destroys the singleton. Declaration public static void DestroySingleton() GetGameObjectName() Retrieves the name of the object. Declaration protected virtual string GetGameObjectName() Returns Type Description String Returns the name of the object."
  },
  "api/UnityEngine.ResourceManagement.Util.DefaultAllocationStrategy.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.DefaultAllocationStrategy.html",
    "title": "Class DefaultAllocationStrategy | Addressables | 1.17.6-preview",
    "keywords": "Class DefaultAllocationStrategy Default allocator that relies in garbace collection Inheritance Object DefaultAllocationStrategy Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class DefaultAllocationStrategy : IAllocationStrategy Methods New(Type, Int32) Create a new object of type t. Declaration public object New(Type type, int typeHash) Parameters Type Name Description Type type The type to return. Int32 typeHash The hash code of the type. Returns Type Description Object The new object. Implements IAllocationStrategy.New(Type, Int32) Release(Int32, Object) Release an object. Declaration public void Release(int typeHash, object obj) Parameters Type Name Description Int32 typeHash The hash code of the type. Object obj The object to release. Implements IAllocationStrategy.Release(Int32, Object)"
  },
  "api/UnityEngine.ResourceManagement.Util.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.html",
    "title": "Namespace UnityEngine.ResourceManagement.Util | Addressables | 1.17.6-preview",
    "keywords": "Namespace UnityEngine.ResourceManagement.Util Classes ComponentSingleton<T> Creates a singleton. DefaultAllocationStrategy Default allocator that relies in garbace collection LinkedListNodeCache<T> Cache for nodes of LinkedLists. This can be used to eliminate GC allocations. LRUCacheAllocationStrategy Allocation strategy that uses internal pools of objects to avoid allocations that can trigger GC calls. ResourceManagerConfig Resource Manager Config utility class. SerializedTypeRestrictionAttribute Attribute for restricting which types can be assigned to a SerializedType Structs ObjectInitializationData Contains data used to construct and initialize objects at runtime. SerializedType Wrapper for serializing types for runtime. Interfaces IAllocationStrategy Allocation strategy for managing heap allocations IInitializableObject Interface for objects that support post construction initialization via an id and byte array. IObjectInitializationDataProvider Interface for objects that can create object initialization data."
  },
  "api/UnityEngine.ResourceManagement.Util.IAllocationStrategy.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.IAllocationStrategy.html",
    "title": "Interface IAllocationStrategy | Addressables | 1.17.6-preview",
    "keywords": "Interface IAllocationStrategy Allocation strategy for managing heap allocations Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IAllocationStrategy Methods New(Type, Int32) Create a new object of type t. Declaration object New(Type type, int typeHash) Parameters Type Name Description Type type The type to return. Int32 typeHash The hash code of the type. Returns Type Description Object The new object. Release(Int32, Object) Release an object. Declaration void Release(int typeHash, object obj) Parameters Type Name Description Int32 typeHash The hash code of the type. Object obj The object to release."
  },
  "api/UnityEngine.ResourceManagement.Util.IInitializableObject.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.IInitializableObject.html",
    "title": "Interface IInitializableObject | Addressables | 1.17.6-preview",
    "keywords": "Interface IInitializableObject Interface for objects that support post construction initialization via an id and byte array. Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IInitializableObject Methods Initialize(String, String) Initialize a constructed object. Declaration bool Initialize(string id, string data) Parameters Type Name Description String id The id of the object. String data Serialized data for the object. Returns Type Description Boolean The result of the initialization. InitializeAsync(ResourceManager, String, String) Async operation for initializing a constructed object. Declaration AsyncOperationHandle<bool> InitializeAsync(ResourceManager rm, string id, string data) Parameters Type Name Description ResourceManager rm The current instance of Resource Manager. String id The id of the object. String data Serialized data for the object. Returns Type Description AsyncOperationHandle < Boolean > Async operation"
  },
  "api/UnityEngine.ResourceManagement.Util.IObjectInitializationDataProvider.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.IObjectInitializationDataProvider.html",
    "title": "Interface IObjectInitializationDataProvider | Addressables | 1.17.6-preview",
    "keywords": "Interface IObjectInitializationDataProvider Interface for objects that can create object initialization data. Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public interface IObjectInitializationDataProvider Properties Name The name used in the GUI for this provider Declaration string Name { get; } Property Value Type Description String Methods CreateObjectInitializationData() Construct initialization data for runtime. Declaration ObjectInitializationData CreateObjectInitializationData() Returns Type Description ObjectInitializationData Init data that will be deserialized at runtime."
  },
  "api/UnityEngine.ResourceManagement.Util.LinkedListNodeCache-1.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.LinkedListNodeCache-1.html",
    "title": "Class LinkedListNodeCache<T> | Addressables | 1.17.6-preview",
    "keywords": "Class LinkedListNodeCache<T> Cache for nodes of LinkedLists. This can be used to eliminate GC allocations. Inheritance Object LinkedListNodeCache<T> Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class LinkedListNodeCache<T> Type Parameters Name Description T The type of node. Methods Acquire(T) Creates or returns a LinkedListNode of the requested type and set the value. Declaration public LinkedListNode<T> Acquire(T val) Parameters Type Name Description T val The value to set to returned node to. Returns Type Description LinkedListNode <T> A LinkedListNode with the value set to val. Release(LinkedListNode<T>) Release the linked list node for later use. Declaration public void Release(LinkedListNode<T> node) Parameters Type Name Description LinkedListNode <T> node"
  },
  "api/UnityEngine.ResourceManagement.Util.LRUCacheAllocationStrategy.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.LRUCacheAllocationStrategy.html",
    "title": "Class LRUCacheAllocationStrategy | Addressables | 1.17.6-preview",
    "keywords": "Class LRUCacheAllocationStrategy Allocation strategy that uses internal pools of objects to avoid allocations that can trigger GC calls. Inheritance Object LRUCacheAllocationStrategy Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class LRUCacheAllocationStrategy : IAllocationStrategy Constructors LRUCacheAllocationStrategy(Int32, Int32, Int32, Int32) Create a new LRUAllocationStrategy objct. Declaration public LRUCacheAllocationStrategy(int poolMaxSize, int poolCapacity, int poolCacheMaxSize, int initialPoolCacheCapacity) Parameters Type Name Description Int32 poolMaxSize The max size of each pool. Int32 poolCapacity The initial capacity to create each pool list with. Int32 poolCacheMaxSize The max size of the internal pool cache. Int32 initialPoolCacheCapacity The initial number of pools to create. Methods New(Type, Int32) Create a new object of type t. Declaration public object New(Type type, int typeHash) Parameters Type Name Description Type type The type to return. Int32 typeHash The hash code of the type. Returns Type Description Object The new object. Implements IAllocationStrategy.New(Type, Int32) Release(Int32, Object) Release an object. Declaration public void Release(int typeHash, object obj) Parameters Type Name Description Int32 typeHash The hash code of the type. Object obj The object to release. Implements IAllocationStrategy.Release(Int32, Object)"
  },
  "api/UnityEngine.ResourceManagement.Util.ObjectInitializationData.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.ObjectInitializationData.html",
    "title": "Struct ObjectInitializationData | Addressables | 1.17.6-preview",
    "keywords": "Struct ObjectInitializationData Contains data used to construct and initialize objects at runtime. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public struct ObjectInitializationData Properties Data String representation of the data that will be passed to the IInitializableObject.Initialize method of the created object. This is usually a JSON string of the serialized data object. Declaration public string Data { get; } Property Value Type Description String Id The object id. Declaration public string Id { get; } Property Value Type Description String ObjectType The object type that will be created. Declaration public SerializedType ObjectType { get; } Property Value Type Description SerializedType Methods CreateInstance<TObject>(String) Create an instance of the defined object. Initialize will be called on it with the id and data if it implements the IInitializableObject interface. Declaration public TObject CreateInstance<TObject>(string idOverride = null) Parameters Type Name Description String idOverride Optional id to assign to the created object. This only applies to objects that inherit from IInitializableObject. Returns Type Description TObject Constructed object. This object will already be initialized with its serialized data and id. Type Parameters Name Description TObject The instance type. GetAsyncInitHandle(ResourceManager, String) Create an instance of the defined object. This will get the AsyncOperationHandle for the async Initialization operation if the object implements the IInitializableObject interface. Declaration public AsyncOperationHandle GetAsyncInitHandle(ResourceManager rm, string idOverride = null) Parameters Type Name Description ResourceManager rm The current instance of Resource Manager String idOverride Optional id to assign to the created object. This only applies to objects that inherit from IInitializableObject. Returns Type Description AsyncOperationHandle AsyncOperationHandle for the async initialization operation if the defined type implements IInitializableObject, otherwise returns a default AsyncOperationHandle. ToString() Converts information about the initialization data to a formatted string. Declaration public override string ToString() Returns Type Description String Returns information about the initialization data. Overrides ValueType.ToString()"
  },
  "api/UnityEngine.ResourceManagement.Util.ResourceManagerConfig.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.ResourceManagerConfig.html",
    "title": "Class ResourceManagerConfig | Addressables | 1.17.6-preview",
    "keywords": "Class ResourceManagerConfig Resource Manager Config utility class. Inheritance Object ResourceManagerConfig Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public static class ResourceManagerConfig Methods CreateArrayResult(Type, Object[]) Used to create an operation result that has multiple items. Declaration public static Array CreateArrayResult(Type type, Object[] allAssets) Parameters Type Name Description Type type The type of the result. Object [] allAssets The result objects. Returns Type Description Array Returns Array object with result items. CreateArrayResult<TObject>(Object[]) Used to create an operation result that has multiple items. Declaration public static TObject CreateArrayResult<TObject>(Object[] allAssets) where TObject : class Parameters Type Name Description Object [] allAssets The result objects. Returns Type Description TObject Returns result Array as TObject. Type Parameters Name Description TObject The type of the result. CreateListResult(Type, Object[]) Used to create an operation result that has multiple items. Declaration public static IList CreateListResult(Type type, Object[] allAssets) Parameters Type Name Description Type type The type of the result objects. Object [] allAssets The result objects. Returns Type Description IList An IList of the resulting objects. CreateListResult<TObject>(Object[]) Used to create an operation result that has multiple items. Declaration public static TObject CreateListResult<TObject>(Object[] allAssets) Parameters Type Name Description Object [] allAssets The result objects. Returns Type Description TObject An IList of the resulting objects converted to TObject. Type Parameters Name Description TObject The type of the result. IsInstance<T1, T2>() Check if one type is an instance of another type. Declaration public static bool IsInstance<T1, T2>() Returns Type Description Boolean Returns true if T2 is a base type of T1. Type Parameters Name Description T1 Expected base type. T2 Expected child type. IsPathRemote(String) Check to see if a path is remote or not. Declaration public static bool IsPathRemote(string path) Parameters Type Name Description String path The path to check. Returns Type Description Boolean Returns true if path is remote. ShouldPathUseWebRequest(String) Check if path should use WebRequest. A path should use WebRequest for remote paths and platforms that require WebRequest to load locally. Declaration public static bool ShouldPathUseWebRequest(string path) Parameters Type Name Description String path The path to check. Returns Type Description Boolean Returns true if path should use WebRequest."
  },
  "api/UnityEngine.ResourceManagement.Util.SerializedType.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.SerializedType.html",
    "title": "Struct SerializedType | Addressables | 1.17.6-preview",
    "keywords": "Struct SerializedType Wrapper for serializing types for runtime. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax [Serializable] public struct SerializedType Properties AssemblyName The assembly name of the type. Declaration public string AssemblyName { get; } Property Value Type Description String ClassName The name of the type. Declaration public string ClassName { get; } Property Value Type Description String Value Get and set the serialized type. Declaration public Type Value { get; set; } Property Value Type Description Type ValueChanged Used for multi-object editing. Indicates whether or not property value was changed. Declaration public bool ValueChanged { get; set; } Property Value Type Description Boolean Methods ToString() Converts information about the serialized type to a formatted string. Declaration public override string ToString() Returns Type Description String Returns information about the serialized type. Overrides ValueType.ToString()"
  },
  "api/UnityEngine.ResourceManagement.Util.SerializedTypeRestrictionAttribute.html": {
    "href": "api/UnityEngine.ResourceManagement.Util.SerializedTypeRestrictionAttribute.html",
    "title": "Class SerializedTypeRestrictionAttribute | Addressables | 1.17.6-preview",
    "keywords": "Class SerializedTypeRestrictionAttribute Attribute for restricting which types can be assigned to a SerializedType Inheritance Object Attribute SerializedTypeRestrictionAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.Equals(Object) Attribute.GetHashCode() Attribute.Match(Object) Attribute.IsDefaultAttribute() Attribute._Attribute.GetTypeInfoCount(UInt32) Attribute._Attribute.GetTypeInfo(UInt32, UInt32, IntPtr) Attribute._Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr) Attribute._Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr) Attribute.TypeId Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace : UnityEngine.ResourceManagement.Util <!--h6><strong>Assembly</strong>: solution.dll</h6--> Syntax public class SerializedTypeRestrictionAttribute : Attribute, _Attribute Fields type The type to restrict a serialized type to. Declaration public Type type Field Value Type Description Type"
  },
  "changelog/CHANGELOG.html": {
    "href": "changelog/CHANGELOG.html",
    "title": "Changelog | Addressables | 1.17.6-preview",
    "keywords": "Changelog All notable changes to this package will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . [1.17.6-preview] - 2021-02-23 Fixed issue where OnGlobalModification events would be EntryMoved when adding new Entries instead of EntryAdded. Fixed issue where a previously built player fails to load content after running Content Update with missing local bundles Fixed bug where ClearDependencyCacheAsync was throwing invalid handle exceptions if auto releasing the handle Fixed a bug when SerializeReference entries in link.xml for addressable was causing Unity linker to fail. Added results out parameter to AddressableAssetSettings.BuildPlayerContent. [1.17.5-preview] - 2021-02-08 Fixed performance issue when disabling \"Addressable\" for multiple Assets in the Inspector. Added option to set the build path of addressables_content_state.bin file. The buildlogtep.json file is not generated when building the catalog bundle. Fixed invalid handle exception getting thrown when static AssetReferences were used with domain reload turned off Fixed catalog using invalid load path for Groups built with \"bundle naming mode\" \"Filename\". Added option to set custom prefix on the unitybuiltinshader AssetBundle Added documentation explaining how dependencies affect Content Update Sub-assets with arbitrary main type can now be assigned to an asset reference if types match [1.17.4-preview] - 2021-01-27 Removed unnecessary logging when deleting temporary Addressables build data. Added WaitForCompletion() on AsyncOperationHandles. This allows async operation to be executed synchronously Alphanumeric sorting in the group window can be enabled through a setting in the editor preferences Change to set IgnoreFailures with LoadOptions.IgnoreFailures stored in the IResourceLocation.Data if not null Fixed issue when loading legacy Resources from Addressables using the guid when playmode is set to AssetDatabase. Fixed some compile warnings on 2020.2 Change to use full path for name of cached catalog. [1.17.2-preview] - 2021-01-14 Add silent fail option to providers to get rid of error when cache not found as expected Hierarchy now fully displayed in search results when 'show groups as hierarchy' and 'hierarchical search' options are enabled OnValidate is now called when an AssetReference changes Fixed bugs in Use Asset Database play mode related to multiple folders with matching addresses Made the following APIs public: ResourceManager.CreateChainOperation AddressablesAnalyzeResultData AddressableAssetSettings.OptimizeCatalogSize BundledAssetGroupSchema.AssetNamingMode BundledAssetGroupSchema.IncludeAddressInCatalog BundledAssetGroupSchema.IncludeGUIDInCatalog BundledAssetGroupSchema.IncludeLabelsInCatalog BundledAssetGroupSchema.InternalIdNamingMode BuildScriptBase.Log ResourceManagerRuntimeData.AddressablesVersion ProjectConfigData ProjectConfigData.ShowSubObjectsInGroupView ProjectConfigData.GenerateBuildLayout ProjectConfigData.ActivePlayModeIndex ProjectConfigData.PostProfilerEvents ProjectConfigData.LocalLoadSpeed ProjectConfigData.RemoteLoadSpeed ProjectConfigData.HierarchicalSearch ProjectConfigData.ShowGroupsAsHierarchy BuildLayoutGenerationTask BuildLayoutGenerationTask.BundleNameRemap ExtractDataTask.BuildContext ContentCatalogData.SetData(IList data, bool optimizeSize) ContentCatalogData(string id) constructor ContentUpdateContext ContentUpdateContext.GuidToPreviousAssetStateMap ContentUpdateContext.IdToCatalogDataEntryMap ContentUpdateContext.BundleToInternalBundleIdMap ContentUpdateContext.WriteData ContentUpdateContext.ContentState ContentUpdateContext.Registry ContentUpdateContext.PreviousAssetStateCarryOver RevertUnchangedAssetsToPreviousAssetState RevertUnchangedAssetsToPreviousAssetState.Run AddressableAssetEntry.GetAssetLoadPath(bool isBundled, HashSet otherLoadPaths) AddressableAssetSettings.IgnoreUnsupportedFilesInBuild [1.17.0-preview] - 2020-12-13 Added option to clear other cahced versions of asset bundles when a new version has been loaded. Added options for internal naming of asset bundles. This will allow for deterministic naming to avoid unintended diffs for content updates. The \"Ignore Invalid/Unsupported Files\" option is now saved in the settings Fixed issue where Filename only bundle naming schemas were overwriting old bundles prematurely in content update. [1.16.17] - 2021-02-25 Updated group rename logic to support engine AssetDatabase fix. Change should be transparent to users. [1.16.16] - 2021-01-20 Updated dependency versions for testcase fix [1.16.15] - 2020-12-09 Addressables link.xml should now have it's own folder. Fixed an issue where InvalidKeyException was getting thrown when calling GetDownloadSizeAsync on scenes Resources folders inside Unity packages now get added to the Built In Data group Fixed issue where getting selected subasset would cause an error if any subassets' type was null [1.16.13] - 2020-11-18 Added option to invert the display of CheckBundleDupeDependencies Analyze rule Fix GatherEntryLocations for scenes when parameter type is null Added some API docs for RuntimeBuildLog and AnalyzeResultData that were missing. Updated docs to explain the use of profile variables a little better. Added ability to toggle Check Duplicate Bundle Dependencies analyze rule results to be arranged by Group or Asset Allow assets that are inside a com.unity* package to be marked as addressable [1.16.10] - 2020-11-04 Added internal naming option for the Bundled Asset Group Schema. Instead of using the full path, there are options to use the asset guid or the hashcode of the guid. These values are stable and wont change if the asset path changes, reducing the need to rebuild a bundle if paths change but contents do not. The internal ids stored in the content catalog will generally be shorter than asset paths - 32 bytes for the full guid, 8 bytes for the guid hash. Added option to exclude sub catalog entries by file extension Added options to exclude catalog entries for address, labels, and guids Added option to optimize catalog size by extracting duplicated string in urls and file paths Fixed issue where ResourceLocations were returning null for the ResourceType. Added warning to build when an Addressable Group doesn't have any AddressableAssetGroupSchemas Fixed issue where resource folder search was case sensitive for Mac and Linux Fixed issue where warnings were getting logged incorrectly when marking an asset as Addressable using the checkbox in the inspector. Fixed issue where an AssetReference's cached asset is not reset when the underlying asset re-imports. Fixed issue where we were still checking for CRC when a bundle was cached. Fixed bug when using Play Mode Script \"Use AssetDatabase (fastest)\", and calling Addressables.LoadContentCatalogAsync would fail when it had not been cached. [1.16.7] - 2020-10-21 Fixed issue where InvalidHandle errors were getting thrown if an operation failed with releaseDependenciesOnFailure turned on. Fixed group build and load paths not being saved when editing multiple groups at once Changed Analyze Result data to be cached in the Library. Result data was previously stored in Assets/AddressableAssetsData/AnalyzeData/AnalyzeRuleData.asset. It is now stored in Library/com.unity/addressables/AnalyzeData/AnalyzeRuleData.json. If detected, the Assets - version of the Analyze data will be automatically cleaned up. Fixed line in AsyncOperationHandle documentation that told the wrong API for acquiring a handle Moved the content update documents to their own page. Expanded and clarified information on the update process [1.16.6] - 2020-09-30 Group hierarchy support in groups window by detecting '-' in group name This can be turned on & off in the addressable asset settings inspector: Group Hierarchy with Dashes This only affects the visual display, groups are still stored in the main settings object in a flat list The group name is unaffected. If you name a group \"x-y-z\" that will be it's name, but, with the option on, it will display as if it was in a folder called \"y\" that was inside a folder called \"x\" Fixed fast mode resource locator Keys property to expand all possible keys when accessed. For large projects with many addressable entries and folders, this property may be slow when called for the first time. Added detailed build layout feature. See documentation for details. Fixed issue where assets in Resources weren't show full key in Groups window Fixed issue where loading Addressables from a different project was throwing errors. Fixed WriteSerializedFiles profile event timings when using the detailed build log Selecting multiple Resources and checking \"addressable\" now display a single popup Fixed CreateArrayResult wouldn't work with classes derived from Object, only the base class, so not for ScriptableObject. Also added test Fixed exceptions not handled while loading ContentCatalog Fixed issue where passing false into releaseDependenciesOnFailure was still releasing dependencies on failure Fixed issue where failed operations could over release their dependencies. Changes to an AssetReference rendered by AssetReferenceDrawer now register as a GUI change Added a checkbox in settings to ignore invalid/unsupported files during build empty folders are cleaned-up when moving multiple resources fails fixed bug where an error would occur when moving resources for paths without extensions Fixed issue where AddressableAsset files locked by version control couldn't be modified. [1.16.1] - 2020-09-15 Fixed bug where some files would not be created in the right folder if the user moved its addressables config folder elsewhere Fixed determanism issue where bundles could have different names after Editor restart Added a blurb to the documentation explaining you have to pack an atlas before the sub objects will show up in the groups window Added \"addressable\" checkbox when viewing package assets in the Inspector. Fixed issue where GatherAllAssets would not retrieve assets located in package resources folders. Fixed issue where temporary StreamingAssets folder are recreated due to un-deleted meta files during a player build added Equals implementation for typeless AsyncOperationHandle When AssetReference MainAsset changed, reset SubObject resource manager callback leak fixes Packed Playmode build logs regarding BuildTargets now show up in PlayMode Additional Fast Mode optimizations Fixed issue where a released operation was not properly cleaned-up Fixed issue where renaming an AssetGroup with a name that contained a period led to unusual renaming behavior. Removed Analyze Rule \"Check Sprite Atlas To...\". This check was not actually valid. See \"SpriteAtlas dependencies\" section of \"Memory Management\" page in Addressables documentation for more information. UnloadSceneAsync calls that attempt to unload a scene that is still currently loading are now chained with the load operation and will complete after the load is finished. The MaxConcurrentWebRequests exposed on the AddressableAssetSettings object now gets set during runtime initialization Fix performance issues drawing AssetReferences with subassets caused by earlier changes to AssetReferenceDrawer Fixed bug where Addressables.ClearDepenendcyCache wasn't clearing the cache. AssetReferenceUILabelRestriction attribute now works properly on references in nested classes [1.15.1] - 2020-08-25 Change to not allow the same AssetReference to LoadAssetAsync or LoadSceneAsync twice if current handle is valid, instead log an error with note about how to get the valid handle Fixed issue where disabled asset groups data would be included in the addressables_content_state.bin file for the build. Add ability to use custom ResourceManager exception handlers by not overwriting it in InitializeAsync if it is not null Fixed bug where Content Update would not use asset bundle load options for unchanged static remote bundles. Fixed LoadAssetAsync<IList > to return the same set of objects in all play modes. The main asset is always first and hidden objects are ignored. Changed keys parameter for many Addressables APIs to be IEnumerable instead of IList . This allows for passing collections of AssetReferences or AssetLabelReferences directly instead of requiring them to be copied into a new List . Fix bug where lists of AssetReferenceSprites were not displayed or set right by AssetReferenceDrawer. Also fixed where multiple selected objects in project hierarchy couldn't set all lists of AssetReferences elements. Added better error logging when unrecognized file in build. Added error log when building asset bundles during player build. Added \"Hide Events\" context menu option in Event Viewer Fixed a bug where running the \"Check Scene to Addressable Duplicate Dependencies\" analyze rule multiple times would cause a duplicate key exception The \"Check Scene to Addressable Duplicate Dependencies\" analyze rule now only considers scenes that are enabled in the build settings. Fixed a bug where an error would be thrown when Unity 2019 opens and if the hosting window was previously left open Fixed a bug where changes to a service where not applied in the hosting window Fixed a bug where profile selection in the inspector was incorrectly reverted to the default one on domain reload Added documentation for LoadResourceLocationsAsync Added documentation for ResourceManager.ExceptionHandler Added documentation for AddressableAssetSettings.BuildPlayerContent Added documentation for LoadSceneAsync Added ScriptableBuildPipeline Build Callbacks to Addressables Build Scripts Temporary files made during bundled catalog creation are now properly cleaned up Inspector window now opens if it was closed when inspecting addressable settings Fixed bug where AsyncOperation.PercentComplete was returning 100% when IsDone was false before the operation had started. Progress bar is no longer updated for every entry while running Analyze rules for performance purposes. Fixed loading of scenes from scenes list through Addressables. Clears out an InvalidCastException that occured on init. Fixed issue where AssetReference wasn't able to load Addressable assets in folders during AssetDatabase Mode. [1.14.2] - 2020-08-11 Addressables now logs the package version on initialization. Renamed Build Bundle Layout analyze rule to Bundle Layout Preview Marked RawWriteOperation obsolete. Marked SceneRawWriteOperation obsolete. AsyncOperationHandle ClearDependencyCacheAsync has been added. The new API takes an autoReleaseHandle parameter and returns the AsyncOperationHandle. Made the AsyncOperationHandle in AssetReference public. Fixed loading of items from Resources and the built in ScenesList. Improved the performance of loading local content on Android by using LoadFromFileAsync instead of UnityWebRequest. Please note that the bundle compression mode for all local content (on any platform) should be LZ4 or uncompressed to have optimal load performance. Fixed issue where some Addressables settings were not being saved if they were only serialized properties or textfields like 'Build Remote Catalog' Fixed a bug where DiagnosticEvents would be created even if 'Send Profiler Events' was set to false. Refactored the DebugNames of many of the most common implementations of AsyncOperationHandle to improve readability in the event viewer. Events in the Event viewer should now display more accurately in the case of Repeated loads and unloads of the same object. AddressableAssetEntry now overrides ToString() to return the address of the entry Added support for setting multiple assets and subasset references at a time for field in GameObject script in the AssetReference Inspector Improved performance of the GenerateLocationLists task Refactored DiagnosticEventCollector.RegisterEventHandler so that events are always handled in frame order. Fixed bug where the Event Viewer would not work when connected to a standalone player. Added docs describing the process of connecting the Event Viewer to a standalone player. Fixed exception that was getting thrown on Editor restart regarding accessing EditorSettings.enterPlayModeOptionsEnabled during serialization. Added MaxConcurrentWebRequests option to the AddressableAssetSettings. Added GetDownloadStatus method to AsyncOperationHandle. The DownloadStatus struct returned will contain the total number of bytes needed to be downloaded and the current number of bytes already downloaded. Cached AssetBundles will not be included in the count and if everything is cached, the values in the struct will be zero. Added Documentation for the following: InstantiateAsync DownloadDependenciesAsync LoadContentCatalogAsync UpdateCatalogs [1.13.1] - 2020-07-28 Made AssetReferenceT<TObject> be Serializable. This will only matter if using Unity 2020.1 or later. Added AddressableAssetSettings.ContiguousBundles option, which when enabled will improve asset loading times. In testing, performance improvements varied from 10% improvement over all, with improvements up to 50% for large complex assets such as extensive UI prefabs. Add New Build unclickable No Build Script Available option when no valid builder is found and added line in docs to explain what is needed Fixed bug where dragging a non addressable asset from an addressable folder in project viewer to AssetReference field would mark the asset as addressable and put it in the default group Fixed bug where enumerate exception is being thrown when expanding a group folder containing subfolders in the Addressable Groups window. Changed to only ask to convert legacy bundles when AddressableAssetSettings is first created or when selected from the Tools menu Fixed bug where clicking on an AssetReference property won't ping the referenced asset in the Project window. Fixed bug where GetDownloadSizeAsync was returning non-zero values for cached AssetBundles. Removed Event Viewer Record button because it didn't do anything. Fixed bug where changes made through the AddressableAssetProfileSettings API would not be immediately represented in the Profiles Window. Fixed bug where Instantiation and EventCount events in the Event Viewer would not update as expected. Fixed bug where events that occurred immediately after entering play mode would not be properly represented in the Event Viewer. Fixed bug where Instantiation and EventCount events would not display their most recent value when inspected in the Event Viewer. Added Documentation for the following: LoadAssetAsync LoadAssetsAsync InitializeAsync TransformInternalId Fixed bug where changing the value of \"Optimize Mesh Data\" in PlayerSettings doesn't affect bundle building until the old build cache is deleted. Expanded bundle dependencies so that loaded bundles maintain a reference to all bundle they references. This fixes various bugs when unloading and reloading a bundle that is being referenced by another bundle. [1.12.0] - 2020-07-14 Implemented Undo/Redo capability for the Profiles Window. Fixed bug where the Profiles Window would occasionally throw a NullReferenceException when making a new profile. Added RenameProfile to the AddressableAssetsProfileSettings API Added error messages for failed attempts at renaming a Profile Fixed bug where when there are AssetReferences with the same name but in different Addressable groups only one could be selected in field dropdown Fixed bug surrounding addressable sprites that were also in a SpriteAtlas Fixed bug where loading a scene in a package would only load an empty scene with no contents. Fixed bug where Event Viewer window would always be empty. LinkXmlGenerator moved to the Scriptable Build Pipeline package in the UnityEditor.Build.Pipeline.Utilities namespace. Added documentation to explain how to make packages addressable. Fixed bug where ArgumentException errors are thrown when selecting a prefab from a read-only package. Fixed bug where setting AssetReference property to null wasn't dirtying the asset Fixed a bug where IResourceLocations were returning a false positive on comparison. Added error checking to make sure that an address doesn't have '[]'. [1.11.2] - 2020-06-15 Refactored Play Mode Script for \"Use Asset Database\" to pull data directly from the settings. This reduces the time needed to enter play mode. Added scrollbar to the Label dropdown Fixed misleading dialog box shown to the user when there are unsaved scenes. Fixed bug where DownloadDependenciesAsync always returns an AsyncOperationHandle with a null task. Fixed bug where AddressableAssetSettings.asset is always being written to disk whenever something is changed in OnPostProcessAllAssets, including asset modified, moved, group created or deleted Revamped Profiles window to a two panel layout. Fixed issue with Profiles window where changes would occasionally not be serialized to the settings asset. Fixed bug where an op with some failed dependencies would never release the ones that had succeeded. Added optional parameter \"releaseDependenciesOnFailure\" to LoadAssetsAsync to handle the scenario of partial success. This is when there are multiple locations being loaded, and not all succeed. In the partial success scenario: By default, the new parameter is true, and all successful parts will be released. The .Result on the returned handle will be null and Status will be Failed When false, the returned .Result will be a List of size matching the number of matching locations. Any failed location will correlate to null in the List, while successful locations will correlate to valid objects in the List. Status will still be Failed in this scenario. Bundles that fail to load from the cache are now removed from the Cache and will be redownloaded. Added option to disable CRC checks for cached AssetBundles on BundledAssetGroupSchema under Advanced Options. If null is passed into Addressables.UpdateCatalogs(...) for the list of catalogIds, CheckForCatalogUpdates will be called automatically. Added null reference check when running InitializationObjectsOperation to take failed RuntimeData operations into account. Disabled hitting ENTER on an AssetReference inspector to open popup. The drawer does not know which AssetReference to associate the popup should that MonoBehaviour have more than one. So disabling is unfortunately the only safe option. Fixed issue where assets located in subfolders marked as addressable would be added to build content multiple times. Fixed bug where Groups window hierarchical search was not filtering the group contents. Fixed bug with Groups window flat search not sorting. [1.10.0] - 2020-05-28 Fixed hosting service not working for special characters in addressable asset address Fixed bug where tracked scene instance operation handles weren't matching the handles returned to the user. Fixed bug where Sprite Atlas ResourceProvider wasn't getting added to list of ResourceProviders. Fixed bug where pack separately groups were rebuilding all bundles when an asset was added or removed from the group. [1.9.2] - 2020-05-21 Improved the performance of GenerateLocationLists. Fixed AssetReferenceLabelUIRestriction not working for private fields Fixed AssetReferenceDrawer OnGui changing text of static variable GUIContent.none Updated documentation to explain what's happening when DontDestroyOnLoad GameObjects are having their dependencies removed when the scene they originate in is unloaded. Using a more efficient method of gathering the Addressable entries for the AssetReferenceDropdown UI. Fixed bug surrounding how \"Use AssetDatabase\" build script handles deleted assets. Fixed issue where ContentUpdate was throwing an exception if a dependency wasn't in the previous build. PercentComplete calcluation updates to correctly take progress callbacks on ProviderOperations into account. Added support for Enable Play Mode Options in 2019.3+ Fixed issue where diagnostic events are still being sent to the player regardless of the value of \"Send Profiler Events\". Added error checking to make sure that a group doesn't have both a PlayerDataGroupSchema and a BundledAssetGroupSchema. Fixed issue where InitializationObjects were causing the InitializationOperation to hang. [1.8.4] - 2020-05-20 Taking an updated scriptable build pipeline that reverts a recent hashing change. [1.8.3] - 2020-04-07 Option to disable sprites and subobjects has been added to the Groups window Tools menu. This option is persisted per user, not with the project. Catalog entries for subobjects and sprites are no longer serialized into the catalog. These are generated at runtime with a custom resource locator. Added missing error logs to various failure cases. Fixed subobject parsing to treat anything between the first '[' character and the last ']' as the subobject name instead of the last '[' and the last ']'. Changed the display of AssetReference types in the inspector from a dropdown to look like an object reference. Added the option to compress the local content catalog by packing it in an asset bundle. Added method in settings to retrieve all defined labels. Fixed PercentComplete in ChainOperation Fixed main settings asset getting marked dirty when making builds. Fixed issues with Content Update when entry with dependant entries was modified. Fixed \"Unknown Exception\" issue caused by releasing certain operation handles too many times. Added link to online documentation in the addressable windows menu. Fixed bug where two assets with the same address packed separately was causing an error. Fixed issue where loading a content catalog multiple times was throwing exceptions. Made it so using the LoadContentCatalogAsync API creates a ResourceLocation that allows those catalogs to be updated properly. Fixed bug where the scene in a recycled InstanceOperation wasn't being cleaned. Fixed bug where an invalid location would be created for assets that weren't in a Resources folder, but were part of a group with the PlayerDataGroupShema. Schema asset file name uses group name instead of GUID. For example: GroupName_SchemaName.asset Fixed text that was being cutoff in the CacheIntializationSettings inspector view. During init, if a remote catalog is expected but not present, this will fail silently. Fixed a bug where that silent failure showed up later as an \"unknown error in async operation\". if you wish to see a log for the failed catalog retrieval, enable ADDRESSABLES_LOG_ALL as a scripting define symbol. Fixed bug where renaming a class referenced by an AddressableAssetEntry causes an InvalidKeyException. Fixed performance regression in ContentUpdateScript.SaveContentState Fixed performance regression in BuildScriptPackedMode.PostProcessCatalogEntries Updated to scriptable build pipeline 1.7.2 which includes many build optimizations - see SBP changelog for details [1.7.5] - 2020-03-23 Fixed null key exception when building that happened when an invalid asset type is in a resources folder. [1.7.4] - 2020-03-13 Improved building catalog data speed. Various minor optimizations related to handling sub objects. Added progress bar to the catalog generation part of the build process. Gave initialization objects an asynchronous initialization API. Made it so a CacheInitializationObject waits for engine side Caching.ready to be true before completing. Fixed a bug when accessing AssetReferenceT.editorAsset where the Type does not match the Editor Asset type, Such as a subAsset type. Fixed bug where Use Asset Database and Use Existing Build could return a different number of results in LoadAssetAsync<IList<>> Fixed bug where SceneUnload Operations weren't getting properly released in certain circumstances. Fixed UI performance regression when opening the Addressables Group Editor window. Fixed issue where RuntimeKeyIsValid was give a false negative when checking sub-objects. Updating scripting defines to check if caching is enabled. Changed the display of AssetReference types in the inspector from a dropdown to look like an object reference. Prevent assets from being added to read only Addressable groups through the group editor window. Group names can now be searched through the group editor window. Added ability to set variables in AddressablesRuntimeProperties more than once. Fixed missed null check on drag and drop in Group Editor window. Updated Scriptable Build Pipeline dependency to bring in these changes: Updated CompatibilityAssetBundleManifest so hash version is properly serializable. Renamed \"Build Cache\" options in the Preferences menu to \"Scriptable Build Pipeline\" Improved performance of the Scriptable Build Pipeline's archiving task. [1.6.2] - 2020-02-08 Checking if Profile Events is enabled on the engine side before running the DiagnosticEventCollector Update. Fixed issue where RuntimeKeyIsValid was give a false negative when checking sub-objects. Fixed Update Previous Build workflow that wasn't re-using previously built Asset Bundle paths when necessary. Updated Scriptable Build Pipeline dependency to bring in these changes: Fixed an issue where texture sources for sprites were not being stripped from the build. Fixed an issue where scene changes weren't getting picked up in a content re-build. Fixed an issue where texture sources for non-packed sprites were being stripped incorrectly. Fixed issue where hosting service ports were changing on assets re-import. Fixed issues with Content Update, including groups that are Packed Separately not updating properly. [1.6.0] - 2020-01-11 Fixed bug where unsubscribing to AsyncOperations events could throw if no subscription happened beforehand. Fixed NullReferenceException when displaying Groups window displaying entries with Missing Script References on SubAssets. Moved AnalyzeWindow.RegisterNewRule to AnalyzeSystem.RegisterNewRule so that the API/logic wouldn't live in GUI code. Fixed bug where scenes in a folder containing \"Assets\" in the folder name not loadable in \"Use Asset Database\" mode. InvalidKeyException's message now include the type of the key that caused it, if applicable. Added the ability to select and edit multiple Addressable Groups at the same time. Assigning LocationCount during AddressableAssetBuildResult.CreateResult Fixed issue where groups and schemas were getting deleted on import. Adding dependencies to built in modules to prevent them from being disabled if Addressables is active. Adding scripting define to remove Caching API calls when ENABLE_CACHING is false Added API to get the scene AsyncOperation from ActivateAsync(). Made the previous API, Activate(), obsolete. Fixed bug where the group window wasn't properly refreshed on Analyse fix [1.5.1] - 2020-01-13 Fixed issue where groups and schemas were getting deleted on import. Adding scripting define to remove Caching API calls when ENABLE_CACHING is false [1.5.0] - 2019-12-09 Fixed temporary StreamingAssets files not being removed on a failed player build. Added Bundle Naming option for naming as a hash of the full filename string. Added a delay before unloaded things are removed from Event Viewer graph. Ideally this would track with dependencies, but for now it's simply time based. Fixed ProfileValueReferences not getting set dirty when changed. Added ability for Addressables to handle null references in the Addressables groups list. Null groups should not affect or influence content builds, updates, or Analyze rules. Right clicking on a [Missing Reference] will give you the option to remove all missing references. Fixed issue with Analyze reporting multiple duplicate data for one group. Fixed issue where unloading a scene was throwing an invalid handle error. Added Addressables.ClearDependencyCacheAsync API to clear cached dependent AssetBundles for a given key or list of keys. Added type conversion from AnimatorController to RuntimeAnimatorController. [1.4.0] - 2019-11-13 Added the ability to disable checking for content catalog updates during initialization. Fixed issue where turning off Include in Build in the right circumstances would throw an exception. Made internal classes and members public to support custom build scripts. Exposed Addressables.InstanceProvider to allow for setting up runtime specific data on custom instance providers. Fixed issue with filenames being too long to write to our Temp cache of AssetBundles. Changed ProcessGroup in BuildScriptFastMode to directly create catalog entries from Addressable entries. Added progress bar to Fast Mode when creating content catalog. [1.3.8] - 2019-11-04 Properly suppressing a harmless \"Unknown error in AsyncOperation\" that has been popping up during init. It had to do with not finding a cached catalog before a catalog had been cached (so error shouldn't happen). Fixed issue with asset hash calcluation for internal asset bundle name when building bundles. Adding option \"Unique Bundle IDs\" to the General section of the AddressableAssetSettings Inspector. If set, every content build (original or update) will result in asset bundles with more complex internal names. This may result in more bundles being rebuilt, but safer mid-run updates. See docs for more info. This complex internal naming was added to 1.3.3 to support safter Content Catalog updating, but was forced on. It is now optional as there are some drawbacks. [1.3.5] - 2019-11-01 Added documentation about updating Content Catalog at runtime (outside Init). Uses CheckForCatalogUpdates() and UpdateCatalogs(). [1.3.3] - 2019-10-21 UI and naming changes \"Static true or false\" content is now content with an \"Update Restriction\" of \"Cannot Change Post Release\" or \"Can Change Post Release\" \"Fast Mode\" (play mode) has been renamed \"Use Asset Database (faster)\" \"Virtual Mode\" (play mode) has been renamed \"Simulate Groups (advanced)\" \"Packed Mode\" (play mode) has been renamed \"Use Existing Build (requires built groups)\" There is no longer a current \"Build Script\" (Build Script menu in Addressables window). Instead the script is selected when triggering the build. Schemas have been given display names to be more clear of their intent BundledAssetGroupSchema. BundledAssetGroupSchema displays as \"Content Packing & Loading\" ContentUpdateGroupSchema displays as \"Content Update Restriction\" Bundle and Asset providers within schema settings are named more descriptively Profile management is in its own window (\"Profiles\") Label management is in its own window \"Prepare for Content Update\" is now under the \"Tools\" menu (in Addressables window), and is called \"Check for Content Update Restriction\" \"Build for Content Update\" is \"Update a Previous Build\" (still in \"Build\" menu of Addressables window). \"Profiler\" window has been renamed \"Event Viewer\". It's more accurate, and avoids confusion with \"Profilers\" window. Added additional parameter to AssetReference.LoadSceneAsync method to match Addressables.LoadSceneAsync API Added AssetReference.UnloadScene API Fixed issue with WebGL builds where re-loading the page was causing an exception to get thrown. Fixed Analyze bug where bundle referenced multiple times was flagged as duplicate. Fixed issue with hashing dependencies that led to frequent \"INCORRECT HASH: the same hash (hashCode) for different dependency lists:\" errors. Update AddressableAssetEntry cached path to new modified asset entry paths. Storing the KeyData string from ContentCatalogData on disk instead of keeping it in memory as it can get quite large. Fixed Custom Hosting Service window so it won't close when focus is lost. Fixed issue with AudioMixerGroups not getting the proper runtime type conversion for the build. Fixed invalid location load path when using \"only hash\" bundle naming option in 'content packing and loading' schema. Removed content update hash from final AssetBundle filename. Removed exception in Analyze that was triggering when \"Fix Selected Rules\" was bundling in Un-fixable rules. (SBP) Fixed an edge case where Optimize Mesh would not apply to all meshes in the build. (SBP) Fixed an edge case where Global Usage was not being updated with latest values from Graphics Settings. (SBP) Fixed Scene Bundles not rebuilding when included prefab changes. Added APIs to update content catalog at runtime: CheckForCatalogUpdates() and UpdateCatalogs(). [1.2.4] - 2019-09-13 Further improvement to the % complete calculations. Note that this is an average of dependency operations. Meaning a LoadAssetsAsync call will average the download, and the loading progress. DownloadDependenciesAsync currently has one extra op, so the download will crawl to 50%, then jump to done (we will look into removing that). Similarly any op that is called before Addressables init's will jump to 50% once init is done. [1.2.3] - 2019-09-10 Actually \"Made ContentUpdateScript.GatherModifiedEntries public.\" [1.2.2] - 2019-09-09 Made ContentUpdateScript.GatherModifiedEntries public. Added sub-object support to AssetReference. For example, you can now have an AssetReference to a specific sprite within a sprite atlas. Added sub-object support to addresses via [] notation. For example, sprite atlas \"myAtlas\", would support loading that atlas via that address, or a sprite via \"myAtlas[mySprite]\" Fixed issue with Content Update workflow. Assets that don't change groups during Content Update now remain in the same bundle. Added funtionality to allow multiple diagnostic callbacks to the ResourceManager. Added error and IResourceLocation to the callback. Added default parameter to DownloadDependenciesAsync to allow auto releasing of the the operation handle on completion. Added memory management documentation. Changed OnlyHash naming option to remove folder structure. This is a workaround to Windows long-file-path issues. Made AssetReference interfaces virtual Fixed hash calculations to avoid collisions Added overload for GetDownloadSizeAsync. The overload accepts a list of keys and calculates their total download size. Improved percent complete calculations for async opertions. [1.1.10] - 2019-08-28 Fix for all files showing \"Missing File\" in the addressables window. Fix for waiting on a successfully done Task [1.1.9] - 2019-08-22 Fixed drag and drop NullRef in main addressables window. Fixed AudioMixer type assets getting stripped from bundles. Fixed issue where failed async operations weren't getting released from the async operation cache. Fix unloading of scenes so that the dependencies will wait for the unload operation to complete before unloading. This was causing an occasional 1-frame visual glitch during unload. Fixed scenario where AsyncOperation Task fails to complete when AsyncOperation has already completed. Fixed a missed init-log that was stuck always-logging. Fixed issue around assets losing dependencies when unloaded then reloaded. This would manifest most often as sprites losing their texture or prefabs losing their shader/material/texture. Changed checks for determining if a path is remote or not from looking for \"://\" to looking for starting with \"http\". \"://\" is still used to determine if the asset should be loaded via UnityWebRequest or not. Added Analyze Rule to show entire Asset Bundle layout Added progress bars and some optimizations for calculating analyze rules [1.1.7] - 2019-07-30 Fixed chain operation percent complete calculation. Fixed scenario where deleting assets would also delete groups that have similar names. Fix in bundle caching bug surrounding bundles with '.' in their name Significant improvements to the manual pages Made the many init-logs not log unless ADDRESSABLES_LOG_ALL is defined in player settings (other logs always worked this way, init didn't). Prevented NullReferenceException when attempting to delete entries in the Addressables window. Fix for building by label (Bundle Mode = Pack Together By Label) Removed ability to mark editor-only assets as addressable in GUI Better fix to Editor types being added to the build Made BuiltIn Data group read-only by default. Fixed NullRef caused by an invalid (BuildIn Data) group being default during a build. Fixed path where LoadResourceLocationsAsync could still throw an exception with unknown key. Now it should not, and is a safe way to check for valid keys. If Key does not exist but nothing else goes wrong, it will return an empty list and Success state. Fixed NullRef caused when there was a deleted scene in the scenes list. BuildCompression for Addressables can now be driven from the default group. If necessary WebGL builds will fallback to LZ4Runtime and all other build targets will fallback to LZMA. Added options for bundle naming: AppendHash, NoHash, OnlyHash. As a temporary workaround for updating issues, we recommend setting all groups with StaticContent=true to be NoHash. This will make sure the updated catalog still refers to the correct unchanged bundle. An actual fix will be out in a few releases. [1.1.5] - 2019-07-15 Fixed scenario where scene unload simultaneously destroys objects being instantiated in different scenes. Cleaned up SetDirty logic to remove excessive dirtying of assets. [1.1.4-preview] - 2019-06-19 Fixed an issue where Editor only types were being added to the build. [1.1.3-preview] - 2019-06-17 BREAKING CODE CHANGES ReleaseInstance will now return a bool saying if it successfully destroyed the instance. If an instance is passed in that Addressables is unaware of, this will return false (as of 0.8 and earlier, it would print a log, and still destroy the instance). It will no longer destroy unknown instances. Added PrimaryKey to the IResourceLocation. By default, the PrimaryKey will be the address. This allows you to use LoadResourceLocationsAsync and then map the results back to an address. Added ResourceType to IResourceLocation. This allows you to know the type of a location before loading it. Fixes a problem where calling Load* (key) would load all items that matched the key, then filter based on type. Now it will do the filter before loading (after looking up location matches) This also adds a Type input to LoadResourceLocationsAsync. null input will match all types. Safety check AssetReference.Asset to return null if nothing loaded. New rule added to Analyze window - CheckResourcesDupeDependencies - to check for dependencies between addressables and items in Resources Added group rearranging support to the Addressables window. Improved logging when doing a Prepare for Content Update. Added versions of DownloadDependencies to take a list of IResourceLocations or a list of keys with a MergeMode. Fixed scenario where Task completion wouldn't happen if operation was already in a certain state Made LoadResourceLocations no longer throw an exception if given unknown keys. This method is the best way to check if an address exists. Exposed AnalyzeRule class to support creating custom rules for Addressables analysis. Fixed some issues surrounding loading scenes in build scenes list via Addressables Removed using alias directives defined in global space. Proper disposal of DiagnosticEventCollector and DelayedActionManager when application closes. Added support for loading named sub-objects via an \"address.name\" pattern. So a sprite named \"trees\" with sub-sprites, could be loaded via LoadAssetAsync (\"trees.trees_0\"). Known issue: loading IList from a Texture2D or IList from an fbx will crash the player. The workaround for now is to load items by name as mentioned just above. Engine fix for this is on its way in. [0.8.6-preview] - 2019-05-14 Fix to make UnloadSceneAsync(SceneInstance) actually unload the scene. [0.8.3-preview] - 2019-05-08 BREAKING CODE CHANGES Chagned all asynchronous methods to include the word Async in method name. This fits better with Unity's history and convention. They should auto upgrade without actually breaking your game. Moved AsyncOperationHandle inside namespace UnityEngine.ResourceManagement Addressable Analyze changes: Analyze has been moved into it's own window. CheckSceneDupeDependencies Analyze rule has been added. CheckDupeDependencies has been renamed into CheckBundleDupeDependencies. Analyze Rule operations for individuals or specific sets of Analyze Rules has been added via AnalyzeRule selections. [0.7.4-preview] - 2019-04-19 Removed support for .NET 3.x as it is deprecated for Unity in general. Replaced IAsyncOperation with AsyncOperationHandle. Once the asset is no longer needed, the user can call Addressables.Release, passing in either the handle, or the result the handle provided. Exposed AsyncOperationBase for creating custom operations These operations must be started by ResourceManager.StartOperation Replaced IDataBuilderContext and it's inherited classes with simpler AddressablesDataBuilderInput. This class is fed into all IDataBuilder.BuildData calls. Fixed Nintendo Switch and PlayStation4 support. Simplified the IResourceProvider interface. Refactored build script interface. Made BuildScriptBase and the provided concrete versions easier to inherit from. Removed DelayedActionManager. Removed ISceneProvider. Users can implement custom scene loading using a custom AsyncOperationBase. Removed optional LRU caching of Assets and Bundles. Addressables Profiler now tracks all active async operations AssetBundles targetting StreamingAssets (by using the profile variable [UnityEngine.AddressableAssets.Addressables.BuildPath] now build to the Library instead of StreamingAssets. During the player build, these files are copied into StreamingAssets, then after the build, the copies are deleted. They are also built into platform specific folders (so building for a second platform will not overwrite data from a first build). We recommend deleting anything in Assets/StreamingAssets/aa. The addressables_content_state.bin is built into a platform specific folder within Assets/AddressableAssetsData/. We recommend deleting the addressables_content_state.bin in Assets/AddressableAssetsData to avoid future confusion. ScriptableBuildPipeline now purges stale data from its cache in the background after each build. Disabled Addressables automatic initialization. It will now initialize itself upon the first call into it (such as Load or Instantiate). To Initialize on startup instead of first use, call Addressables.Initialize(). Optimized performance around instantiation and general garbage generation. Added per-group bundle compression settings. Fixes to AssetReference drawers. Improved the group template system for creating better defined asset groups. Fixed bug in bundle caching that caused GetDownloadSize to report incorrectly Cleaned up Load/Release calls to make sure all releases could take either the handle returned by Load, or the handle.Result. Added editor-only analytics (nothing added in runtime). If you have Analytics disabled in your project nothing will be reported. Currently only run when you build addressables, it includes data such as Addressables version and Build Script name. Fixed null ref issue when cleaning all the data builders KNOWN ISSUE: there is still an occasional issue with code stripping on iOS. If you run into iOS issues, try turning stripping off for now. [0.6.8-preview] - 2019-03-25 fixed Build For Content Update to no longer delete everything it built. [0.6.7-preview] - 2019-03-07 Fix for iOS and Android. Symptom was NullReferenceException dring startup resulting in nothing working. Fix requires re-running Build Player Content [0.6.6-preview] - 2019-03-05 BREAKING CODE CHANGES to ease code navigation, we have added several layers of namespace to the code. All Instantiate API calls (Addressables and AssetReference) have been changed to only work with GameObjects. any hardcoded profile path to com.unity.addressables (specifically LocalLoadPath, RemoteLoadPath, etc) should use UnityEngine.AddressableAssets.Addressables.RuntimePath instead. For build paths, replace Assets/StreamingAssets/com.unity.addressables/[BuildTarget] with [UnityEngine.AddressableAssets.Addressables.BuildPath]/[BuildTarget] For load paths, replace Assets/StreamingAssets/com.unity.addressables/[BuildTarget] with {UnityEngine.AddressableAssets.Addressables.RuntimePath}/[BuildTarget] We have removed attribute AssetReferenceTypeRestriction as it is cleaner to enforce type via generics Attribute AssetReferenceLabelRestriction is renamed to AssetReferenceUILabelRestriction and must be surrounded by #if UNITY_EDITOR in your game code, to enforce it's editor-only capability Modifications to IResourceProvider API. Removed PreloadDependencies API. Instead use DownloadDependencies Content Update calculation has changed, this will invalide previously generated addressables_content_state.bin files. Some types for content update were made private as a result of the above change. Minimum Unity version is now 2018.3 to address a build-time bug with progressive lightmapper. Moved all of the Resource Manager package to be contained within Addressables (no longer a stand alone package). No code change implications. Change to content catalog building: Previous model built one catalog per group, wherever that group built it's data. New model builds one catalog locally, and optionally one \"remote\". Remote location is set on the top level AddressableAssetSettings object. Loading will now always check if remote has changes (if remote exists), and use local otherwise (or cached version of remote). LoadScene API now takes the LoadSceneParameters that were added to the engine in 2018.2 Exposed AddressablesBuildDataBuilderContext.BuildScriptContextConstants for use in build scripts. Refactored AddressablesBuildDataBuilderContext.GetValue to take default parameter. Fixed Scene asset path to be consistent between different play modes in the catalog data. Exposed the various IDataBuilder implementations as public classes. Exposed asset and bundle provider types for BundledAssetGroupSchema. Fixed several bugs when loading catalogs from other projects. Added provider suffix to Initialization operation and Addressables.LoadCatalogsFromRuntimeData API to better support overriding providers. Exposed CachedProvider options in BundledAssetGroupSchema. Each unique set of parameters will generate a separate provider. There is also an option to force a group to have its own providers. Added IEnumerable Keys property to IResourceLocator interface. Exposed InitializationOperation as public API. Added BuildTarget to ResourceManagerRuntimeData. This is used to check if the generated player content was built with the same build target as the player or the editor when entering play mode. Removed warnings generated from not finding the cached catalog hash files, which is not an error. Fixed bug where scenes were not unloading. Fixed GUI exception thrown in group inspector. Fixed error case where an asset (usually a bundle) was loaded multiple times as different types (object and AssetBundle). Fixed divide by zero bug when computing load percent of simulated asset bundles. AddressableAssetBuildResult.CreateResult now takes the settingsPath as a parameter to pass this to the result. Fix AssetReference GUI when the AssetReference is inside an array of classes, part of a SerializedObject, or private. Fix AssetReferenceSprite to properly support sprites (as opposed to Texture2D's). Fixed bug involving scenes being repeatedly added to the build scenes list. Removed deprecated and obsolete code. If you are upgrading from a very old version of Addressables, please update to 0.5.3-preview first. Removed the default MergeMode on LoadAssets calls to enforce explicit behavior. Added IAsyncOperation GetDownloadSize(object key) API to compute remaining data needed to load an asset Fixed assets being stuck in a read-only state in UI Unified asset moving API to clean up public interface Added PlayerVersion override to AddressableAssetSettings Ensure UI cannot show invalide assets (such as .cs files) Renamed Addressables.LoadAddtionalCatalogs to Addressables.LoadContentCatalog and now it takes the path of the catalog instead of the settings file Moved provider information from ResourceManagerRuntimeDate into ContentCatalogData Updating ResourceManager to be a non-static class Fixed bugs surrounding assets moving in or out of Resources (outside Addressables UI) Fixed the AssetReference dropdown to properly filter valid assets (no Resources and honoring type or label limitations). Fixed AssetReferences to handle assets inside folders marked as Addressable. Added attribute AssetReferenceUIRestriction to support user-created AssetReference restrictions (they are only enforced in UI, for dropdown and drag&drop) Changed addressables_content_state.bin to only build to the folder containing the AddressableAssetSettings object (Assets/AddressableAssetsData/ in most cases) Fixed issue where the wrong scene would sometimes be open post-build. [0.5.3-preview] - 2018-12-19 fixed upgrade bug from 0.4.x or lower to 0.5.x or higher. During upgrade, the \"Packed Mode\" option was removed from play mode. Now it's back and upgrades are safe from 0.4.x or from 0.5.x to 0.5.3 [0.5.2-preview] - 2018-12-14 IMPORTANT CHANGE TO BUILDING We have disabled automatic asset bundle building. That used to happen when you built the player, or entered play mode in \"packed mode\". This is no longer the case. You must now select \"Build->Build Player Content\" from the Addressables window, or call AddressableAssetSettings.BuildPlayerContent(). We did this because we determined that automatic building did not scale well at all for large projects. fixed regression loading local bundles Added Addressables.DownloadDependencies() interface fixes for Nintendo Switch support Fixed issues around referencing Addressables during an Awake() call Code refactor and naming convention fixes Cleaned up missing docs Content update now handles not having and groups marked as Static Content Fixed errors when browing for the addressables_content_state.bin and cancelling Moved addressables_content_state.bin to be generated into the addressables settings folder Changed some exceptions when releasing null bundles to warnings to handle the case of releasing a failed download operation Separated hash and crc options to allow them to be used independently in asset bundle loads. Use CRC in AssetBundle.LoadFromFileAsync calls if specified Always include AssetBundleRequestOptions for asset bundle locations [0.4.8-preview] - 2018-10-22 Added all referenced types in asset bundles to link.xml to prevent them from being stripped in IL2CPP builds [0.4.7-preview] - 2018-10-20 updated Scriptable Build Pipeline version in dependencies [0.4.6-preview] - 2018-10-16 MINIMUM RECOMMENDED VERSION - 2018.2.11+ We have re-enabled the addressables checkbox. Versions of 2018.2 older than the .11 release will work unless you attempt to view the Animation Import Settings inspector. If you do have animations you need to inspect, use .11+. If you do not, use any official release version of 2018.2. refactored the way IResourceProviders are initialized in the player - serialized data is constructed at runtime to control how the providers are configured added readonly custom inspector for AddressableAssetEntryCollection AssetReference now stores the loaded asset which can be accessed via the Asset property after LoadAsset completes. ReleaseAsset has been modified to not need the asset passed in (the old version is marked obsolete] fixed profiler details view not updating when a mouse drag is completed fixed null-ref when moving Resources to Addressables when there are no Resources blocked moving EditorSceneList within GUI fixed cap on address name length fixed workflows of marking Resources as addressable and moving an addressable into Resources. fixed issue where AssetReferenceDrawer did not mark scene as dirty when changed. added Hosting Services feature; provides extensible framework and implementation for serving packed content to player builds from the Editor replaced addressables buildscript with an interface based system. IDataBuilder class is now used to define builders of specific types of data. The Addressables settings object contains a collection of data builders and uses these to create player and play mode data. Users can implemented custom data builders to control the build process. replaced AssetGroupProcessors with a collection of AssetGroupSchema objects. The difference is that the schema objects only contain data and groups can have multiple schemas. The logic for processing groups now resides in the build script and uses the schemas as data sources and filters for how to build. Added Initialization objects that can be created during the build to run during addressables initialization Implemented Caching API initialization with initialization objects Changed some API and tests to work with 2019.x fixed how AssetReference's draw when within lists, arrays, or contained classes Fixed the workflow of scenes moving in and out of the Editor Build Settings Scene list. Removed \"Preview\" and added \"Analyze\". The new system runs any rules it knows about. Currently this is one rule that is manually set up in code. Future work will have additional rules, and expose the ability to create/add user- or project-specific rules This process can be slow, as it runs most of a build to get accurate data. Within the Analyze window there is a \"fix\" button that allows each rule to fix any issues if the rule knows how. The current rule is a \"check duplicate asset\" rule. This looks for assets that are pulled into multiple asset bundles due to dependency calculations. The way it fixes things is to move all of those into a newly created group. Added option to toggle logging of all exceptions within the Resource Manager Refactored initialization of the addressable asset settings to prevent it getting into a bad state. [0.3.5-preview] - 2018-09-05 implemented content update workflow. Added a dropdown to the \"Build\" button on main window's toolbar. \"Build/Prepare for Content Update\" will detect assets in locked bundles (bundles flagged as static, by default all local bundles). \"Build/Build for Content Update\" will build assets with a catalog that is compatible with a previously released player. \"Build/Build Packed Data\" will build in the same way entering play mode in PackedMode would. implemented Clean Build. \"Build/Clean/*\" will clear out build caches. cleaned up streaming assets folder better after build moved asset group data into separate assets in order to better support version control fixed bug when canceling export of entries to an AssetEntryCollection fixed several bugs related to caching packed bundles in play mode added option to build settings to control whether streaming assets is cleared after each build enabled CreateBuiltInShadersBundle task in build and preview fixed bug in AA initialization that was cuasing tests to fail when AA is not being used. fixed bug where toggling \"send profiler events\" would have no effect in some situations default the first 2 converted groups to have StaticContent set to true UI Redesign Moved most data settings onto actual assets. AddressableAssetSettings and AddressableAssetGroup assets. AddressableAssetSettings asset has \"Send Profile Events\", list of groups, labels, and profiles AddressableAssetGroup assets have all data associated with that group (such as BuildPath) Made \"preview\" be a sub-section within the Addressables window. The \"Default\" group can now be set with a right-click in the Addressables window. Set play mode from \"Mode\" dropdown on main window's toolbar. Moved \"Hierarchical Search\" option onto magnifying glass of search bar. Removed now empty settings cog button. fixed issue when packing groups into seperate bundles generated duplicate asset bundle names, leading to an error being thrown during build added support for disabling the automatic initialization of the addressables system at runtime via a script define: ADDRESSABLES_DISABLE_AUTO_INITIALIZATION added API to create AssetReference from AddressableAssetSettings object in order to create an entry if it does not exist. moving resource profiler from the ResourceManager package to the Addressables package fixed bug where UnloadScene operation never entered Done state or called callback. fixed loading of additonal catalogs. The API has changed to Addressables.LoadCatalogsFromRuntimeData. fixed bug in InitializationOperation where content catalogs were not found. changed content update workflow to browse for cachedata.bin file instead of folder fixed exception thrown when creating a group and using .NET 4.x fixed bugs surrounding a project without addressables data. AssetLabelReference inspector rendering AssetReference drag and drop fixed profiler details view not updating when a mouse drag is completed fixes surrounding the stability of interacting with the \"default\" group. Added docs for the Content Update flow. Adjusted UI slightly so single-clicking groups shows their inspector. removed not-helpful \"Build/Build Packed Data\" item from menu. fixed bug where you could no longer create groups, and group assets were not named correctly [0.2.2-preview] - 2018-08-08 disabled asset inspector gui for addressables checkbox due to editor bug [0.2.1-preview] - 2018-07-26 smoothed transition from 0.1.x data to 0.2.x data added checks for adding duplicate scenes into the EditorBuildSettings.scenes list fixed exception when deleting group via delete key, added confirmation to all deletions [0.2.0-preview] - 2018-07-23 Fixed bundles being built with default compression instead of compression from settings Fixed bug in tracking loaded assets resulting in not being able to release them properly Added Key property to IAsyncOperation to allow for retrieval of key that requested the operation Added AssetLabelReference to provide inspector UI for selecting the string name of a label Fixed dragging from Resources to a group. Added ability to re-initialize Addressables with multiple runtime data paths. This is to support split projects. Clean up StreamingAssets folder after build/play mode [0.1.2-preview] - 2018-06-11 fixed Application.streamingAssetsPath being stripped in IL2CPP platforms [0.1.1-preview] - 2018-06-07 MIN VERSION NOW 2018.2.0b6 updated dependency [0.1.0-preview] - 2018-06-05 MIN VERSION NOW 2018.2.0b6 added better checks for detecting modified assets in order to invalidate cache fixed preview window showing scenes in wrong bundle exclude current processor type from conversion context menu fixed exception when right clicking asset groups added support for adding extra data to resource locations made Addressables.ReleaseInstance destroy even non-addressable assets. append hash to all bundle names pass crc & hash to bundle provider clear catalog cache whenever packed mode content is rebuilt [0.0.27-preview] - 2018-05-31 fixed ResourceManager initialization to work as the stand-alone player [0.0.26-preview] - 2018-05-24 re-added Instantiate(AssetReference) for the sake of backwards compatability. [0.0.25-preview] - 2018-05-23 workaround for engine bug surrounding shader build. Fix to engine is on it's way in. [0.0.24-preview] - 2018-05-21 minor bug fix [0.0.23-preview] - 2018-05-21 new format for content catalogs detects changes in project and invalidates cached runtime data and catalogs data is not copied into StreamingAssets folder when running fast or virtual mode added external AssetEntry collections for use by packages modifying large number of asset entries on the UI is no longer unresponsive added an option to search the asset list in a hierarchical fashion. Helps track down which group an asset is in. many small bug fixes. [0.0.22-preview] - 2018-05-03 dependency update. [0.0.21-preview] - 2018-05-03 fixed build-time object deletion bug. [0.0.20-preview] - 2018-05-02 Added support for extracting Built-In Shaders to a common bundle Added build task for generating extra data for sprite loading edge case fix build related bugs introduced in 0.0.19. [0.0.19-preview] - 2018-05-01 Complete UI rework. Moved all functionality to one tab Preview is a toggle to view in-line. Profiles are edied from second window (this part is somewhat placeholder pending a better setup) Dependency updates Minor cleanup to build scripts [0.0.18-preview] - 2018-04-13 minor bug fixes exposed memory cache parameters to build settings, changed defaults to use LRU and timed releases to make preloading dependencies more effective [0.0.17-preview] - 2018-04-13 added tests fixed bugs major API rewrite all API that deals with addresses or keys have been moved to Addressables LoadDependencies APIs moved to Addressables Async suffix removed from all Load APIs [0.0.16-preview] - 2018-04-04 added BuildResult and callback for BuildScript added validation of instance to scene and scene to instance maps to help debug instances that change scenes and have not been updated added ResourceManager.RecordInstanceSceneChange() method to allow RM to track when an instance is moved to another scene moved variable expansion of location data to startup [0.0.15-preview] - 2018-03-28 fixed scene unloading release all instances when a scene unloads that contains unreleased instances fixed overflow error in virtual mode load speeds [0.0.14-preview] - 2018-03-20 Updated dependencies [0.0.12-preview] - 2018-03-20 Minor UI updates doc updates fixed bug involving caching of \"all assets\" improved error checking & logging minor bug fixes. [0.0.8-preview] - 2018-02-08 Initial submission for package distribution"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home Page. | Addressables | 1.17.6-preview",
    "keywords": "Home Page. This is the home page for this package."
  },
  "license/index.html": {
    "href": "license/index.html",
    "title": "| Addressables | 1.17.6-preview",
    "keywords": "window.location.replace('LICENSE.html')"
  },
  "license/LICENSE.html": {
    "href": "license/LICENSE.html",
    "title": "| Addressables | 1.17.6-preview",
    "keywords": "Addressables copyright © 2020 Unity Technologies ApS Licensed under the Unity Companion License for Unity-dependent projects--see Unity Companion License . Unless expressly provided otherwise, the Software under this license is made available strictly on an “AS IS” BASIS WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. Please review the license for details on these and other terms and conditions."
  },
  "manual/AddressableAssetsAsyncOperationHandle.html": {
    "href": "manual/AddressableAssetsAsyncOperationHandle.html",
    "title": "Async operation handling | Addressables | 1.17.6-preview",
    "keywords": "Async operation handling Several methods from the Addressables API return an AsyncOperationHandle struct. The main purpose of this handle is to allow access to the status and result of an operation. The result of the operation is valid until you call Addressables.Release or Addressables.ReleaseInstance with the operation (for more information on releasing assets, see documentation on memory management ). When the operation completes, the AsyncOperationHandle.Status property is either AsyncOperationStatus.Succeeded or AsyncOperationStatus.Failed . If successful, you can access the result through the AsyncOperationHandle.Result property. You can either check the operation status periodically, or register for a completed callback using the AsyncOperationHandle.Complete event. When you no longer need the asset provided by a returned AsyncOperationHandle struct, you should release it using the Addressables.Release method. Type vs. typeless handles Most Addressables API methods return a generic AsyncOperationHandle<T> struct, allowing type safety for the AsyncOperationHandle.Completed event, and for the AsyncOperationHandle.Result object. There is also a non-generic AsyncOperationHandle struct, and you can convert between the two handles as desired. Note that a runtime exception occurs if you attempt to cast a non-generic handle to a generic handle of an incorrect type. For example: AsyncOperationHandle<Texture2D> textureHandle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\"); // Convert the AsyncOperationHandle<Texture2D> to an AsyncOperationHandle: AsyncOperationHandle nonGenericHandle = textureHandle; // Convert the AsyncOperationHandle to an AsyncOperationHandle<Texture2D>: AsyncOperationHandle<Texture2D> textureHandle2 = nonGenericHandle.Convert<Texture2D>(); // This will throw and exception because Texture2D is required: AsyncOperationHandle<Texture> textureHandle3 = nonGenericHandle.Convert<Texture>(); PercentComplete vs. GetDownloadStatus AsyncOperationHandle has two methods that can reflect the progress of the operation. GetDownloadStatus() will return a DownloadStatus struct. This contains information about how many bytes have been downloaded, and how many are needed. The DownloadStatus.Percent is a helper method that represents the percentage of bytes downloaded. PercentComplete on the other hand, will return an equally-weighted aggregate percentage of all sub-operations. This percent complete is useful to get a sense of progress, but it may not accurately reflect what you would expect depending on the makeup of your operations. One example would be a call to Addressables.DownloadDependenciesAsync , where 5 asset bundles needed downloading. Here GetDownloadStatus() would inform you of the progress towards to total number of bytes needed, while PercentComplete would have each of the 5 downloads representing 20% of the total, regardless of their size. In another example, LoadAssetAsync() is called, and one bundle needs downloading before an asset can be loaded from it. Here, the download could represent 50% of PercentComplete , and the actual load into memory could represent the other 50%. In this instance, GetDownloadStatus() would represent the download need, and would reach 100% before the operation finished, as the operation had more to do after downloading. AsyncOperationHandle use case examples Register a listener for completion events using the AsyncOperationHandle.Completed callback: private void TextureHandle_Completed(AsyncOperationHandle<Texture2D> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) { Texture2D result = handle.Result; // The texture is ready for use. } } void Start() { AsyncOperationHandle<Texture2D> textureHandle = Addressables.LoadAsset<Texture2D>(\"mytexture\"); textureHandle.Completed += TextureHandle_Completed; } AsyncOperationHandle implements IEnumerator so it can be yielded in coroutines: public IEnumerator Start() { AsyncOperationHandle<Texture2D> handle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\"); //if the handle is done, the yield return will still wait a frame, but we can skip that with an IsDone check if(!handle.IsDone) yield return handle; if (handle.Status == AsyncOperationStatus.Succeeded) { Texture2D texture = handle.Result; // The texture is ready for use. // ... // Release the asset after its use: Addressables.Release(handle); } } Addressables also supports asynchronous await through the AsyncOperationHandle.Task property: public async Start() { AsyncOperationHandle<Texture2D> handle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\"); await handle.Task; // The task is complete. Be sure to check the Status is successful before storing the Result. } The AsyncOperationHandle.Task property is not available on WebGL as multi-threaded operations are not supported on that platform. Note that Loading scenes with SceneManager.LoadSceneAsync with allowSceneActivation set to false or using Addressables.LoadSceneAsync and setting false for the activateOnLoad parameter can lead to subsequent async operations being blocked and unable to complete. See the allowSceneActivation documentation . Loading Addressable Scenes When loading an Addressable Scene, all the dependencies for your GameObjects in the scene are accessed through AssetBundles loaded during the Scene load operation. Assuming no other objects reference the associated AssetBundles, when the Scene is unloaded, all the AssetBundles, both for the Scene and any that were needed for dependencies, are unloaded. Note: If you mark a GameObject in an Addressable loaded scene as DontDestroyOnLoad or move it to another loaded Scene and then unload your original Scene, all dependencies for your GameObject are still unloaded. If you find yourself in that scenario there are a couple options at your disposal: Make the GameObject you want to be DontDestroyOnLoad a single Addressable prefab. Instantiate the prefab when you need it and then mark it as DontDestroyOnLoad . Before unloading the Scene that contained the GameObject you mark as DontDestroyOnLoad , call Addressables.ResourceManager.Acquire(AsyncOperationHandle) and pass in the Scene load handle. This increases the reference count on the Scene, and keeps it and its dependencies loaded until Release is called on the acquired handle."
  },
  "manual/AddressableAssetsCustomOperation.html": {
    "href": "manual/AddressableAssetsCustomOperation.html",
    "title": "Custom operations | Addressables | 1.17.6-preview",
    "keywords": "Custom operations The IResourceProvider API allows you to extend the loading process by defining locations and dependencies in a data-driven manner. In some cases, you might want to create a custom operation. The IResourceProvider API is internally built on top of these custom operations. Creating custom operations Create custom operations by deriving from the AsyncOperationBase class and overriding the desired virtual methods. You can pass the derived operation to the ResourceManager.StartOperation method to start the operation and receive an AsyncOperationHandle struct. Operations started this way are registered with the ResourceManager and appear in the Addressables Event Viewer . Executing the operation The ResourceManager invokes the AsyncOperationBase.Execute method for your custom operation once the optional dependent operation completes. Completion handling When your custom operation completes, call AsyncOperationBase.Complete on your custom operation object. You can call this within the Execute method or defer it to outside the call. Calling AsyncOperationBase.Complete notifies the ResourceManager that the operation is complete and will invoke the associated AsyncOperationHandle.Completed events. Terminating the operation The ResourceManager invokes the AsyncOperationBase.Destroy method for your custom operation when you release the AsyncOperationHandle that references it. This is where you should release any memory or resources associated with your custom operation."
  },
  "manual/AddressableAssetsDevelopmentCycle.html": {
    "href": "manual/AddressableAssetsDevelopmentCycle.html",
    "title": "Addressable Assets development cycle | Addressables | 1.17.6-preview",
    "keywords": "Addressable Assets development cycle One of the key benefits of Addressable Assets is decoupling how you arrange, build, and load your content. Traditionally, these facets of development are heavily tied together. Traditional asset management If you arrange content in Resources directories, it gets built into the base application and you must load the content using the Resources.Load method, supplying the path to the resource. To access content stored elsewhere, you would use direct references or AssetBundles . If you use AssetBundles, you would again load by path, tying your load and organization strategies together. If your AssetBundles are remote, or have dependencies on other bundles, you have to write code to manage downloading, loading, and unloading all of your bundles. Addressable Asset management Giving an Asset an address allows you to load it using that address, no matter where it is in your Project or how you built the Asset. You can change an Addressable Asset’s path or filename without issue. You can also move the Addressable Asset from the Resources folder, or from a local build destination, to some other build location (including remote ones), without ever changing your loading code. Asset group schemas Schemas define a set of data. You can attach schemas to Asset groups in the Inspector. The set of schemas attached to a group defines how the build processes its contents. For example, when building in packed mode, groups with the BundledAssetGroupSchema schema attached to them act as sources for asset bundles. You can combine sets of schemas into templates that you use to define new groups. You can add schema templates via the AddressableAssetSettings Inspector. Build scripts Build scripts are represented as ScriptableObject Assets in the Project that implement the IDataBuilder interface. Users can create their own build scripts and add them to the AddressableAssetSettings object through its Inspector. To apply a build script in the Addressables Groups window ( Window > Asset Management > Addressables > Groups ), select Play Mode Script , and choose a dropdown option. Currently, there are three scripts implemented to support the full application build, and three Play mode scripts for iterating in the Editor. Play mode scripts The Addressable Assets package has three build scripts that create Play mode data to help you accelerate app development. Use Asset Database (faster) Use Asset Database mode ( BuildScriptFastMode ) allows you to run the game quickly as you work through the flow of your game. It loads Assets directly through the Asset database for quick iteration with no analysis or AssetBundle creation. Simulate Groups (advanced) Simulate Groups mode ( BuildScriptVirtualMode ) analyzes content for layout and dependencies without creating AssetBundles. Assets load from the Asset database though the ResourceManager , as if they were loaded through bundles. To see when bundles load or unload during game play, view the Asset usage in the Addressables Event Viewer window ( Window > Asset Management > Addressables > Event Viewer ). Simulate Groups mode helps you simulate load strategies and tweak your content groups to find the right balance for a production release. Use Existing Build (requires built groups) Use Existing Build mode most closely matches a deployed application build, but it requires you to build the data as a separate step. If you aren't modifying Assets, this mode is the fastest since it does not process any data when entering Play mode. You must either build the content for this mode in the Addressables Groups window ( Window > Asset Management > Addressables > Groups ) by selecting Build > New Build > Default Build Script , or using the AddressableAssetSettings.BuildPlayerContent() method in your game script. If under New Build there is an unclickable No Build Script Available , check AddressableAssetSettings in the Inspector and see Build and Play Mode Scripts section. In order to show up under New Build in Addressables Groups window , there must be a build script ScriptableObject that is able to build type AddressablesPlayerBuildResult paired with an entry in the Build and Play Mode Scripts section of the Inspector window for AddressableAssetSettings . To add a new Build or Play Mode script, click the + under the Build and Play Mode Scripts section and find your build mode asset. Once it is added, if the script is a Play Mode script it will show up under Window > Asset Management > Addressables > Groups > Play Mode Script . If the script is able to build AddressablesPlayerBuildResult it will show up under Window > Asset Management > Addressables > Groups > Build > New Build . Build and Play Mode scripts provided by default, including BuildSciptPackedMode , are located under Assets/AddressableAssetsData/DataBuilders . See earlier section \"Build scripts\" for more information on custom build scripts. Analysis and debugging By default, Addressable Assets only logs warnings and errors. You can enable detailed logging by opening the Player settings window ( Edit > Project Settings... > Player ), navigating to the Other Settings > Configuration section, and adding \" ADDRESSABLES_LOG_ALL \" to the Scripting Define Symbols field. You can also disable exceptions by unchecking the Log Runtime Exceptions option in the AddressableAssetSettings object Inspector. You can implement the ResourceManager.ExceptionHandler property with your own exception handler if desired, but this should be done after Addressables finishes runtime initialization (see below). Enable the build layout report to get information and statistics about your content builds. You can use this report to help verify that your builds are creating your bundles as you expect. Initialization objects You can attach objects to the Addressable Assets settings and pass them to the initialization process at runtime. The CacheInitializationSettings object controls Unity's caching API at runtime. To create your own initialization object, create a ScriptableObject that implements the IObjectInitializationDataProvider interface. This is the Editor component of the system responsible for creating the ObjectInitializationData that is serialized with the runtime data. Customizing URL Evaluation There are several scenarios where you will need to customize the path or URL of an Asset (an AssetBundle generally) at runtime. The most common example is creating signed URLs. Another might be dynamic host determination. The code below is an example of appending a query string to all URLs: //Implement a method to transform the internal ids of locations string MyCustomTransform(IResourceLocation location) { if (location.ResourceType == typeof(IAssetBundleResource) && location.InternalId.StartsWith(\"http\")) return location.InternalId + \"?customQueryTag=customQueryValue\"; return location.InternalId; } //Override the Addressables transform method with your custom method. This can be set to null to revert to default behavior. [RuntimeInitializeOnLoadMethod] static void SetInternalIdTransform() { Addressables.InternalIdTransformFunc = MyCustomTransform; } * Please Note *: When bundling video files into Addressables with the intent of loading them on the Android platform, you must create a CacheInitializationSettings object, disable Compress Bundles on that object, then add it to the list of Initialization Objects on the AddressableAssetSettings object if it has not been already. Content update workflow Update workflow moved to a new page: Content Update Workflow Multiple Projects Some users find it beneficial to split their project into multiple Unity projects, such as isolating the artwork from the code to lessen import times. In order to take advantage of this multiple project setup you'll need to utilize Addressables.LoadContentCatalogAsync(...) to load the content catalogs of your separate projects in your main project. A general multi-project workflow is as follows: Create your main project (Project A) and ancillary project(s) (Project(s) B, C, etc.). Add Addressables in each project and setup the desired Addressable Asset Entries. Build your Addressable Player Content for each project. In your main project, before attempting to load assets from the other projects, load the desired content catalogs from the other projects using Addressables.LoadContentCatalogAsync(...) Use Addressables as normal. Note: Ensure that the content catalogs and Asset Bundles of the other projects are reachable by the main project. Setup any required hosting services beforehand."
  },
  "manual/AddressableAssetsGettingStarted.html": {
    "href": "manual/AddressableAssetsGettingStarted.html",
    "title": "Getting started | Addressables | 1.17.6-preview",
    "keywords": "Getting started Installing the Addressable Assets package Important : The Addressable Asset System requires Unity version 2018.3 or later. To install this package, follow the instructions in the Package Manager documentation . Preparing Addressable Assets Marking assets as Addressable There are two ways to mark an asset as Addressable in the Unity Editor: In the object's Inspector. In the Addressables Groups window. Using the Inspector In your Project window, select the desired asset to view its Inspector. In the Inspector, click the Addressable checkbox and enter a name by which to identify the asset. Marking an asset as Addressable in the Inspector window. Using the Addressables window Select Window > Asset Management > Addressables > Groups to open the Addressables Groups window. Next, drag the desired asset from your Project window into one of the asset groups in the Addressables Groups window. Marking an asset as Addressable in the Addressables Groups window. Specifying an address The default address for your asset is the path to the asset in your project (for example, Assets/images/myImage.png ). To change the asset's address from the Addressables Groups window, right-click the asset and select Change Address . Please Note: The address cannot contain square brackets [] , and will fail the build if it does. This is meant to protect the runtime functionality that parses brackets to locate sub assets. For example, at runtime, loading myAsset[mySubAsset] will try to look up an asset at address myAsset , and then attempt to load the sub asset mySubAsset from that. When you first start using Addressable Assets, the system saves some edit-time and runtime data assets for your project in the Assets/AddressableAssetsData file, which should be added to your version control check-in. Building your Addressable content The Addressables Asset System needs to build your content into files that can be consumed by the running game before you build the application. This step is not automatic. You can build this content via the Editor or API: To build content in the Editor, open the Addressables Groups window, then select Build > New Build > Default Build Script . To build content using the API, use AddressableAssetSettings.BuildPlayerContent() . See Build layout report for information on how to generate a report about the layout of your built content. Assets in Packages Important : Marking package assets as Addressable requires Unity version 2020.2.0a9 or later. Creating Addressable Groups in packages Create a group in the Addressables Groups window. When you are done modifying the group, save the project. Move the group asset and its respective schema assets into your package. Open a new project that uses your package. If your group has a “Content Packing & Unloading” schema, update its build and load paths. Your group can now be included in your next Addressables build. If you want to modify the group again, make sure to close all projects that use the package and reopen them once you save all modifications. This will reload the group asset. If your group has a “Content Packing & Unloading” schema, update its build and load paths again. Using Addressable Assets Loading or instantiating by address You can load or instantiate an Addressable Asset at runtime. Loading an asset loads all dependencies into memory (including the AssetBundle data if applicable), allowing you to use the asset when you need to. This does not actually put the desired asset into your scene. To add the asset to your scene you must instantiate. Using Addressables instantiation interfaces will load the asset, then immediately adds it to your Scene. To access an asset from your game script using a string address, declare the UnityEngine.AddressableAssets namespace, then call the following methods: Addressables.LoadAssetAsync<GameObject>(\"AssetAddress\"); This loads the asset with the specified address. Addressables.InstantiateAsync(\"AssetAddress\"); This instantiates the asset with the specified address into your Scene. Note : LoadAssetAsync and InstantiateAsync are asynchronous operations. You may provide a callback to work with the asset when it finishes loading (see documentation on Async operation handling for more information). using System.Collections; using System.Collections.Generic; using UnityEngine.AddressableAssets; using UnityEngine; public class AddressablesExample : MonoBehaviour { GameObject myGameObject; ... Addressables.LoadAssetAsync<GameObject>(\"AssetAddress\").Completed += OnLoadDone; } private void OnLoadDone(UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle<GameObject> obj) { // In a production environment, you should add exception handling to catch scenarios such as a null result. myGameObject = obj.Result; } } Sub-assets and components Sub-assets and components are special cases for asset loading. Components You cannot load a GameObject's component directly through Addressables. You must load or instantiate the GameObject, then retrieve the component reference from it. To see how you could extend Addressables to support component loading, see our ComponentReference sample . Sub-assets The system supports loading sub-assets, but requires special syntax. Examples of potential sub-assets include sprites in a sprite sheet, or animation clips in an FBX file. For examples of loading sprites directly, see our sprite loading sample To load all sub-objects in an asset, you can use the following example syntax: Addressables.LoadAssetAsync<IList<Sprite>>(\"MySpriteSheetAddress\"); To load a single sub-object in an asset, you could do this: Addressables.LoadAssetAsync<Sprite>(\"MySpriteSheetAddress[MySpriteName]\"); The names available within an asset are visible in the main Addressables group editor window. In addition, you can use an AssetReference to access the sub-object of an asset. See notes in the below section. For SpriteAtlas objects specifically, note that the atlas inspector has a checkbox for Include In Build . This option does not determine whether the atlas itself is built into AssetBundles, rather it determines how items reference it. When you enable Include in Build , all dependency linkages remain intact. Thus, if you have an Addressable prefab sprite that is dependent on an atlas, the atlas will be pulled into an AssetBundle. Similarly, if you explicilty mark the atlas as Addressable, the prefab will list the atlas bundle as a dependency, and things are hooked up properly at load time. If you disable Include In Build , the linkage is not preserved. When you load an Addressable prefab that is dependent on the atlas, the atlas will be requested, and you must load and manage the connection manually using SpriteAtlasManager.atlasRequested . In this scenario, you can still mark the atlas as Addressable to access each sprite manually. When viewing a SpriteAtlas in the Addressables Groups window, ensure the SpriteAtlas has been packed if you intend to view the sub-objects in the Window. This can be done by clicking Pack Preview in the inspector of the SpriteAtlas object. If the SpriteAtlas is packed and you still cannot see the sub-objects, check the Show Sprite and Subobject Addresses option is enabled; it is located in the Tools menu of the Addressables Groups window. Using the AssetReference class The AssetReference class provides a way to access Addressable Assets without needing to know their addresses. To access an Addressable Asset using the AssetReference class: Select a GameObject from your Scene hierarchy or Project window. In the Inspector, click the Add Component button, then select the component type. Any serializable component can support an AssetReference variable (for example, a game script, ScriptableObject, or other serializable class). Add a public AssetReference variable in the component (for example, public AssetReference explosion; ). In the Inspector, select which Addressable Asset to link to the object, by either dragging the asset from the Project window into the exposed AssetReference field, or choosing from the dropdown of previously defined Addressable Assets in your project (shown below). Referencing an Addressable Asset via script component. To load or instantiate an AssetReference asset, call its corresponding method. For example: AssetRefMember.LoadAssetAsync<GameObject>(); or AssetRefMember.InstantiateAsync(pos, rot); Note : As with normal Addressable Assets, LoadAssetAsync and InstantiateAsync are asynchronous operations. You may provide a callback to work with the asset when it finishes loading (see documentation on Async operation handling for more information). Sub-assets If an asset that contains sub-assets (such as a SpriteAtlas or FBX) is added to an AssetReference, you are given the option to reference the asset itself, or a sub-asset. The single dropdown you are used to seeing becomes two. The first selects the asset itself, and the second selects the sub-asset. If you select \" \" in the second dropdown, that will be treated as a reference to the main asset. Build considerations Local data in StreamingAssets The Addressable Asset System needs some files at runtime to know what to load and how to load it. Those files are generated when you build Addressables data and wind up in the StreamingAssets folder, which is a special folder in Unity that includes all its files in the build. When you build Addressables content, the system stages those files in the Library. Then, when you build the application, the system copies the required files over to StreamingAssets , builds, and deletes them from the folder. This way, you can build data for multiple platforms while only having the relevant data included in each build. In addition to the Addressables-specific data, any groups that build their data for local use will also use the Library platform-specific staging location. To verify that this works, set your build path and load paths to profile variables starting with [UnityEngine.AddressableAssets.Addressables.BuildPath] and {UnityEngine.AddressableAssets.Addressables.RuntimePath} respectively. You can specify these settings in the AddressableAssetSettings Inspector (by default, this object is located in your project's Assets/AddressableAssetsData directory). Downloading in advance Calling the Addressables.DownloadDependenciesAsync() method loads the dependencies for the address or label that you pass in. Typically, this is the AssetBundle. The AsyncOperationHandle struct returned by this call includes a PercentComplete attribute that you can use to monitor and display download progress. You can also have the app wait until the content has loaded. Regarding PercentComplete PercentComplete takes into account several aspects of the underlying operations being handled by a single AsyncOperationHandle . There may be instances where the progression isn't linear, or some semblance of linear. This can be due to quick operations being weighted the same as operations that will take longer. For example, given an asset you wish to load from a remote location that takes a non-trival amount of time to download and is reliant on a local bundle as a dependcy you'll see your PercentComplete jump to 50% before continuing. This is because the local bundle is able to be loaded much quicker than the remote bundle. However, all the system is aware of is the need for two operations to be complete. If you wish to ask the user for consent prior to download, use Addressables.GetDownloadSize() to return how much space is needed to download the content from a given address or label. Note that this takes into account any previously downloaded bundles that are still in Unity's asset bundle cache. While it can be advantageous to download assets for your app in advance, there are instances where you might choose not to do so. For example: If your app has a large amount of online content, and you generally expect users to only ever interact with a portion of it. You have an app that must be connected online to function. If all your app's content is in small bundles, you might choose to download content as needed. Rather than using the percent complete value to wait until the content is loaded, you can use the preload functionality to show that the download has started, then continue on. This implementation would require a loading or waiting screen to handle instances where the asset has not finished loading by the time it's needed. Building for multiple platforms The Addressable Asset System generates AssetBundles containing your Addressable Assets when building application content. AssetBundles are platform-dependant, and thus must be rebuilt for every unique platform you intend to support. By default, when building Addressables app data, data for your given platform is stored in platform-specific subdirectories of the Addressables build path(s). The runtime path accounts for these platform folders, and points to the applicable app data. Note : If you use the Addressables BuildScriptPackedPlayMode script in the Editor Play mode, Addressables will attempt to load data for your current active build target. As such, issues may arise if your current build target data isn't compatible with your current Editor platform. For more information, see documentation on Play mode scripts . Note : If a group has a “Content Packing & Unloading” schema, its Compression mode can be modified in the Inspector window. For optimal asset loading times regardless of platform, only use LZ4 for local content and LZMA for online content. Grouping assets It is a good practice to logically collect assets into multiple groups rather than put them all in one large group. The key benefit of this method is to avoid conflicts in version control systems (VCS) when multiple contributors make edits to the same file. Having one large asset group might result in the VCS's inability to cleanly merge these various changes. Building scenes that are packed together After running a build where you have multiple Scenes in an Addressable Assets group, those Scenes will become interdependent if: Under Packed Assets in the Project window, the group's Bundle Mode is set to Pack Together . The Scenes in that group all have the same asset label, and the Bundle Mode is set to Pack Together By Label . If you modify even one of these grouped Scenes then perform a content update build , all the interdependent Scenes will move together into a new Content Update group. Loading Content Catalogs Content Catalogs are the data stores Addressables uses to look up an asset's physical location based on the key(s) provided to the system. By default, Addressables builds the local content catalog for local Addressable Groups. If the Build Remote Catalogs option is turned on under the AddressableAssetSettings, then one additional catalog is built to store locations for remote Addressable Groups. Ultimately Addressables only uses one of these catalogs. If a remote catalog is built and it has a different hash than the local catalog, it is downloaded, cached, and used in place of the built-in local catalog. It is possible, however, to specify additional Content Catalogs to be loaded. There are different reasons you might decide loading additional catalogs is right for your project, such as building an art-only project that you want to use across different projects. Should you find that loading additional catalogs is right for you, there is a method that can assist in this regard, LoadContentCatalogAsync . For LoadContentCatalogAsync , all that is required is for you to supply the location of the catalog you wish to load. However, this alone does not use catalog caching, so be careful if you're loading a catalog from a remote location. You will incur that WebRequest every time you need to load that catalog. To help prevent you from needing to download a remote catalog every time, if you provide a .hash file with the hash of the catalog alongside the catalog you're loading, we can use this to properly cache your Content Catalog. Please Note: The hash file does need to be in the same location and have the same name as your catalog. The only difference to the path should be the extension. One additional note: You'll notice this method comes with a parameter autoReleaseHandle . In order for the system to download a new remote catalog, any prior calls to LoadContentCatalogAsync that point to the catalog you're attempting to load need to be released. Otherwise, the system picks up the Content Catalog load operation from our operation cache. If the cached operation is picked up, the new remote catalog is not downloaded. If set to true, the parameter autoReleaseHandle can ensure that the operation doesn't stick around in our operation cache after completing."
  },
  "manual/AddressableAssetsHostingServices.html": {
    "href": "manual/AddressableAssetsHostingServices.html",
    "title": "Asset Hosting Services | Addressables | 1.17.6-preview",
    "keywords": "Asset Hosting Services Overview Hosting Services provide an integrated facility for using Addressable Assets configuration data to serve packed content to local or network-connected application builds from within the Unity Editor. Hosting Services are designed to improve iteration velocity when testing packed content, and can also be used to serve content to connected clients on local and remote networks. Packed mode testing and iteration Moving from Editor Play mode testing to platform application build testing introduces complexities and time costs to the development process. Hosting Services provide extensible Editor-embedded content delivery services that map directly to your Addressables group configuration. Using a custom Addressables profile, you can quickly configure your application to load all content from the Unity Editor itself. This includes builds deployed to mobile devices, or any other platform, that have network access to your development system. Turn-key content server You can deploy Asset Hosting Services into a server environment by running in batch mode (headless) to host content for both intranet- and internet-facing Unity application clients. Setup This article details the initial setup of Asset Hosting Services for your project. While the setup guide focuses on Editor workflows, you can use the API to configure Hosting Services by setting the HostingServicesManager property of the AddressableAssetSettings class. Configuring a new Hosting Service Use the Hosting window to add, configure, and enable new Hosting Services. In the Editor, select Window > Asset Management > Addressables > Hosting , or click the Tools > Hosting Services button from the Addressables Groups window menu to access the Addressables Hosting window. The Addressables Hosting window. To add a new Local Hosting Service, click the Create > Local Hosting button. Adding a new Hosting Service. Note : For more information on implementing custom hosting service types, see the section on custom services . The newly added service appears in the Hosting Services section of the Addressables Hosting window. Use the Service Name field enter a name for the service. The new service defaults to the disabled state. To initiate the service, select the Enable check box. The updated Addressables Hosting window after adding a service. The HTTP Hosting Service automatically assigns a port number when it starts. The port number is saved and reused between Unity sessions. To choose a different port, either assign a specific port number in the Port field, or use the Reset button to randomly assign a different port. Note : If you reset the port number, you must execute a full application build to generate and embed the correct URL. The HTTP Hosting Service is now enabled and ready to serve content from the directory specified in the BuildPath of each asset group. Hosting Service profile setup When working with Hosting Services during development, Unity recommends creating a profile that configures all asset groups to load content from the Hosting Service using a directory or directories created specifically for that purpose. For more about profiles, see Addressable Assets Profiles . Once in the Addressables Profiles window, create a new profile via Create > Profile . In the following example, the new profile is called \"Editor Hosted\". Creating a service profile. Modify the loading path fields to instead load from the Hosting Service. HttpHostingService is a URL that uses the local IP address and the port assigned to the service. From the Addressables Hosting window, you can use the profile variables named PrivateIpAddress and HostingServicePort to construct the URL (for example, http://[PrivateIpAddress]:[HostingServicePort] ). Additionally, you should modify all build path variables to point to a common directory outside of the project's Assets folder. Configuring the service's profile. Verify that each group is configured correctly. Ensure that the BuildPath and LoadPath paths are set to their respective profile keys that are modified for use with Hosting Services. In this example, you can see how the profile variables in the LoadPath are expanded to build a correct base URL for loading from Hosted Services. Inspecting the service's load paths. Finally, select the new profile from the Addressables Groups window, create a build, and deploy to the target device. The Unity Editor now serves all load requests from the application through the HttpHostingService service. You can now make additions and changes to content without redeployment. Rebuild the Addressable content, and relaunch the already deployed application to refresh the content. Selecting a Hosting Service profile. Batch mode You can also use Hosting Services to serve content from the Unity Editor running in batch mode. To do so, launch Unity from the command line with the following options: -batchMode -executeMethod UnityEditor.AddressableAssets.HostingServicesManager.BatchMode This loads the Hosting Services configuration from the default AddressableAssetSettings object, and starts all configured services. To use an alternative AddressableAssetSettings configuration, create your own static method entry point, to call through the UnityEditor.AddressableAssets.HostingServicesManager.BatchMode(AddressableAssetSettings settings) overload. Custom services Hosting Services are designed to be extensible, allowing you to implement your own custom logic for serving content-loading requests from the Addressable Assets System. For example: Support a custom IResourceProvider that uses a non-HTTP protocol for downloading content. Manage an external process for serving content that matches your production CDN solution (such as an Apache HTTP server). Implementing a custom service The HostingServicesManager can manage any class that implements an IHostingService interface (for more details on method parameters and return values, see the API documentation . To create a new custom service: Follow the steps outlined in the configuring a new Hosting Service section above, but instead of selecting Create > Local Hosting button, select Create > Custom Service button instead. Drag and drop the applicable script into its field, or select it from the object picker. The dialog validates that the selected script implements the IHostingService interface. To finish adding the service, click the Add button. Moving forward, your custom service will appear in the Service Type dropdown options. Adding a custom Asset Hosting Service."
  },
  "manual/AddressableAssetsMigrationGuide.html": {
    "href": "manual/AddressableAssetsMigrationGuide.html",
    "title": "Upgrading to the Addressables system | Addressables | 1.17.6-preview",
    "keywords": "Upgrading to the Addressables system This article details how to modify your existing project to take advantage of Addressable Assets. There are three traditional methods for referencing assets: Direct References : Add assets directly into components or Scenes, which the application loads automatically. Resource Folders : Add assets to your Resource folder and load them by filename. AssetBundles : Add assets to AssetBundles, then load them with their dependencies by file path. The direct reference method To migrate from this approach, follow these steps: Replace your direct references to objects with asset references (for example, public GameObject directRefMember; becomes public AssetReference AssetRefMember; ). Drag assets onto the appropriate component’s Inspector, as you would for a direct reference. If you'd like to load an asset based on an object rather than a string name, instantiate it directly from the AssetReference object you created in your setup (for example, AssetRefMember.LoadAssetAsync<GameObject>(); or AssetRefMember.InstantiateAsync(pos, rot); ). When the Asset is not needed anymore, it must be unloaded with the Addressables.Release method. See Mirroring load and unload for details. Note : The Addressable Asset system loads assets asynchronously. When you update your direct references to asset references, you must also update your code to operate asynchronously. The Resource folders method When you mark an asset in a Resources folder as Addressable, the system automatically moves the asset from the Resources folder to a new folder in your project named Resources_moved . The default address for a moved asset is the old path, omitting the folder name. For example, your loading code might change from Resources.LoadAsync<GameObject>(\"desert/tank.prefab\"); to Addressables.LoadAssetAsync<GameObject>(\"desert/tank.prefab\"); . Note : Some functionality of the Resources class may not be supported directly after modifying your project to use Addressable Assets. For example, consider the Resources.LoadAll function. Previously, if you had assets in a folder Resources/MyPrefabs/ , and ran Resources.LoadAll<SampleType>(\"MyPrefabs\"); , it would have loaded all the assets in Resources/MyPrefabs/ matching type SampleType . Addressable Assets do not support this functionality. You could achieve similar results using the Addressable Assets concept of labels , but the two ideas are not directly analogous. The AssetBundles method When you open the Addressables Groups window, Unity offers to convert all AssetBundles into Addressable Asset groups. This is the easiest way to migrate your code. If you choose to convert your assets manually, click the Ignore button. Then, either use the direct reference or resource folder methods previously described. The default path for the address of an asset is its file path. If you use the path as the asset's address, you'd load the asset in the same manner as you would load from a bundle. The Addressable Asset System handles the loading of the bundle and all its dependencies."
  },
  "manual/AddressableAssetsOverview.html": {
    "href": "manual/AddressableAssetsOverview.html",
    "title": "Addressable Assets overview | Addressables | 1.17.6-preview",
    "keywords": "Addressable Assets overview The Addressable Assets System consists of two packages: Addressable Assets package (primary package) Scriptable Build Pipeline package (dependency) When you install the Addressable Assets package, the Scriptable Build Pipeline package installs at the same time. See the latest version of the Unity Scriptable Build Pipeline documentation. Concepts The following concepts are referenced throughout this documentation: Address : An asset's location identifier for easy runtime retrieval. AddressableAssetData directory : Stores your Addressable Asset metadata in your project’s Assets directory. Asset group : A set of Addressable Assets available for build-time processing. Asset group schema : Defines a set of data that you can assign to a group and use during the build. AssetReference : An object that operates like a direct reference, but with deferred initialization. The AssetReference object stores the GUID as an Addressable that you can load on demand. Asynchronous loading : Allows the location of the asset and its dependencies to change throughout the course of your development without changing the game code. Asynchronous loading is foundational to the Addressable Asset System. Build script : Runs asset group processors to package assets, and provides the mapping between addresses and Resource locations for the Resource Manager. Label : Provides an additional Addressable Asset identifier for runtime loading of similar items (for example, Addressables.DownloadDependenciesAsync(\"spaceHazards\"); )."
  },
  "manual/AddressableAssetsProfiles.html": {
    "href": "manual/AddressableAssetsProfiles.html",
    "title": "Addressable Assets Profiles | Addressables | 1.17.6-preview",
    "keywords": "Addressable Assets Profiles The Addessable Assets Profile system allows you to create a set of string variables that more easily enables you to change how your content is built into bundles. These variables can be used to determine whether your content is local to device or on a remote server. For each profile, you specify values for each variable. This way, instead of manually changing the individual paths for each of your build scenarios, you can change profiles to swap them all at once. Profile Setup There are multiple ways to access the Profile setup window in the Editor. Select Window > Asset Management > Addressables > Profiles . Select Window > Asset Management > Addressables > Groups , then select Tools > Profiles . Select Window > Asset Management > Addressables > Groups , then select Profile > Manage Profiles .. You can also access these settings via the AddressableAssetSettings Inspector. The Addressables Profiles window showing two profiles. There are five variables we provide by default: BuildTarget LocalBuildPath LocalLoadPath RemoteBuildPath RemoteLoadPath You can add or remove variables at any time. Adding a new profile You can create new profile by selecting Create > Profile . A new profile row appears in the table. Right-click the profile name to select whether to set this as the active profile, rename the profile, or delete it. Every profile must define a value for every variable. When you create a new profile, all values are copied from the currently selected profile. Adding a new variable You can create new variables to add to the default set by selecting Create > Variable . In the resulting window, give the new variable a name and string value, then click Save . The new variable appends to the end of the variable table. Right-click the variable name to rename or delete the variable. You can likewise rename or delete the provided variables. Syntax All variables are of type \"string\". In general, you can type in exactly the needed path or value, but there are two additional syntax designators allowed: Square brackets [ ]. Items surrounded by square brackets are evaluated at build time. The values inside can be other profile variables (such as [BuildTarget]) or code variables (such as [UnityEditor.EditorUserBuildSettings.activeBuildTarget]). During build time, as the groups are being processed, the items inside square brackets are evaluated and the resulting string is written into the catalog. Curly brackets { }. Items surrounded by curly brackets are evaluated at runtime. Generally values here will be code variables (such as {UnityEngine.AddressableAssets.Addressables.RuntimePath}). For example, you have a load path of: {MyNamespace.MyClass.MyURL}/content/[BuildTarget]} set on a group that is creating an AssetBundle called \"trees.bundle\". During the build, the catalog would register the load path for that bundle as {MyNamespace.MyClass.MyURL}/content/Android/trees.bundle} . Then, at startup, as the catalog is being processed, the profile system would evaluate MyNamespace.MyClass.MyURL to end up with the final load path of http://myinternet.com/content/Android/trees.bundle . Specifying packing and loading paths Once you set up the necessary variables in your profile, you can select the build and load paths for an asset group based on those specified variables. To set your build and load paths: Select an Addressable Assets group from the Project window. In its related Inspector window, under Content Packing & Loading > Build and Load Paths , select the desired variables from the currently set profile in the drop-downs for Build Path and Load Path . Notice that you do not enter the path directly, but rather select the variable representing the path defined in the Profiles window earlier. Once selected, the path displays under the drop-down but is not editable here. Be careful to ensure the build and load paths are a matched pair. For example, if you are building to the local path, you cannot load from a server. Examples Consider the following example, demonstrating the local development phase of your content. Content with local and remote bundles stored locally for development. While in development, you would have both your local and remote bundles using local paths, as seen below. Paths set for local development. In this instance, you can see that the local and remote paths are in fact local, which makes more sense for development, as setting up a remote server would be a pain. However, once the content is ready for production, you would move the remote bundles to a server, as the diagram below shows. Content with remote bundle moved to a server for production. In this case, using profiles, you could change the remote load path for \"Production\" to that server. Without having to change your asset groups, you can change all of your remote bundles to actually become remote. It should be noted, variables are arbitrary key-value pairs to aid development. Setting variables such as \"LocalBuildPath\" does not guarantee that data built to that location is copied to the StreamingAssets path of a Player build. Data is only copied to the Player's StreamingAssets folder from Addressables.BuildPath ."
  },
  "manual/AddressablesAPI.html": {
    "href": "manual/AddressablesAPI.html",
    "title": "Expanded API documentation | Addressables | 1.17.6-preview",
    "keywords": "Expanded API documentation This page exists in addition to the standard Addressable Assets Scripting API documentation . The purpose of this expanded API documentation is to provide quick access and a deeper understanding of often-used or important API items, including code samples where relevant. BuildPlayerContent DownloadDependenciesAsync ExceptionHandler InitializeAsync InstantiateAsync LoadContentCatalogAsync LoadingAddressableAssets LoadResourceLocationsAsync LoadSceneAsync TransformInternalId UpdateCatalogs"
  },
  "manual/AddressablesCCD.html": {
    "href": "manual/AddressablesCCD.html",
    "title": "Addressable Asset system with Cloud Content Delivery | Addressables | 1.17.6-preview",
    "keywords": "Addressable Asset system with Cloud Content Delivery In addition to the existing Asset Hosting Services , the Addressable Asset system can be used in conjunction with Cloud Content Delivery (CCD) to have the CCD service serve assets you configure using the Addressable Asset system. Note : The purpose of this page is to describe how to link the concepts of Addressable Assets to CCD, and is not meant to be an in-depth discussion of these ideas. Before reading this page, make sure you are familiar with both the Addressable Asset system and Cloud Content Delivery. In order to set up Addressable Assets to work with CCD: Configure your assets as addressable. Configure your groups. Configure your profile to include your CCD URL. Build your AssetBundles, then upload them to CCD. Configure your assets as addressable The first step to managing Addressable Assets with CCD is to mark the assets you require as Addressable. See Marking assets as Addressable . Configure your groups Next, it's important to place your assets into groups. This is important because you need to generate AssetBundles later by building these groups. See Using the Addressables window . Configure profile with CCD URL Next, you need to link your project to your CCD project. You do this by inserting a custom URL as the RemoteLoadPath of your desired Addressables profile. At this stage, there are two workflow paths you can choose, each with its own custom URL. The basic workflow just points to the latest content in the specified bucket, given by: https://(ProjectID).client-api.unity3dusercontent.com/client_api/v1/buckets/(BucketID)/entry_by_path/content/?path= The badge workflow links your project to the contents pointed at by a specific badge: https://(ProjectID).client-api.unity3dusercontent.com/client_api/v1/buckets/(BucketID)/release_by_badge/(BadgeName)/entry_by_path/content/?path= where: (ProjectID) is your CCD project's ID string. (BucketID) is the Bucket ID string for the CCD bucket within your project with which you want to interact. (BadgeName) is the name of the specific CCD badge with which you want to interact. Once you have your custom URL: In the Editor, select Window > Asset Management > Addressables > Profiles . In the RemoteLoadPath field for the desired profile row, enter your URL. For that profile, your project will now know where to fetch its Addressable Assets. Build and upload Addressable content to CCD Next, for the profile you want to use with CCD, you must generate your Addressable content that you will later place in your CCD project. To build content, see Building your Addressable content . If you are changing the contents of a group, see Building for content updates . Building your Addressable content can generate a content catalog (.json), a hash file (.hash), and an AssetBundle (.bundle) file. At this point, you need to upload these files to the bucket you specified above. This upload is done via the CCD command-line interface (CLI). See Unity Cloud Content Delivery ."
  },
  "manual/AddressablesFAQ.html": {
    "href": "manual/AddressablesFAQ.html",
    "title": "Addressables FAQ | Addressables | 1.17.6-preview",
    "keywords": "Addressables FAQ Is it better to have many small bundles or a few bigger ones? There are a few key factors that go into deciding how many bundles to generate. First, it's important to note that you control how many bundles you have both by how large your groups are, and by the groups' build settings. \"Pack Together\" for example, creates one bundle per group, while \"Pack Separately\" creates many. See schema build settings for more information . Once you know how to control bundle layout, the decision of how to set these up will be game specific. Here are key pieces of data to help make that decision: Dangers of too many bundles: Each bundle has memory overhead. Details are on the memory management page . This is tied to a number of factors, outlined on that page, but the short version is that this overhead can be significant. If you anticipate 100's or even 1000's of bundles loaded in memory at once, this could mean a noticeable amount of memory eaten up. There are concurrency limits for downloading bundles. If you have 1000's of bundles you need all at once, they cannot not all be downloaded at the same time. Some number will be downloaded, and as they finish, more will trigger. In practice this is a fairly minor concern, so minor that you'll often be gated by the total size of your download, rather than how many bundles it's broken into. Bundle information can bloat the catalog. To be able to download or load catalogs, we store string-based information about your bundles. 1000's of bundles worth of data can greatly increase the size of the catalog. Greater likelihood of duplicated assets. Say two materials are marked as Addressable and each depend on the same texture. If they are in the same bundle, then the texture is pulled in once, and referenced by both. If they are in separate bundles, and the texture is not itself Addressable, then it will be duplicated. You then either need to mark the texture as Addressable, accept the duplication, or put the materials in the same bundle. Dangers of too few bundles: The UnityWebRequest (which we use to download) does not resume failed downloads. So if a large bundle is downloading and your user loses connection, the download is started over once they regain connection. Items can be loaded individually from bundles, but cannot be unloaded individually. For example, if you have 10 materials in a bundle, load all 10, then tell Addressables to release 9 of them, all 10 will likely be in memory. This is also covered on the memory management page . What compression settings are best? Addressables provides three different options for bundle compression: Uncompressed, LZ4, and LZMA. Generally speaking, LZ4 should be used for local content, and LZMA for remote, but more details are outlined below as there can be exceptions to this. You can set the compression option using the Advanced settings on each group. Compression does not affect in-memory size of your loaded content. Uncompressed - This option is largest on disk, and generally fasted to load. If your game happens to have space to spare, this option should at least be considered for local content. A key advantage of uncompressed bundles is how they handle being patched. If you are developing for a platform where the platform itself provides patching (such as Steam or Switch), uncompressed bundles provide the most accurate (smallest) patching. Either of the other compression options will cause at least some bloat of patches. LZ4 - If Uncompressed is not a viable option, then LZ4 should be used for all other local content. This is a chunk-based compression which provides the ability to load parts of the file without needing to load it in its entirety. LZMA - LZMA should be used for all remote content, but not for any local content. It provides the smallest bundle size, but is slow to load. If you were to store local bundles in LZMA you could create a smaller player, but load times would be significantly worse than uncompressed or LZ4. For downloaded bundles, we avoid the slow load time by recompressing the downloaded bundle when storing it in the asset bundle cache. By default, bundles will be stored in the cache Uncompressed. If you wish to compress the cache with LZ4, you can do so by creating a CacheInitializationSettings . See Initialization Objects for more information about setting this up. Note that the hardware characteristics of a platform can mean that uncompressed bundles are not always the fastest to load. The maximum speed of loading uncompressed bundles is gated by IO speed, while the speed of loading LZ4-compressed bundles can be gated by either IO speed or CPU, depending on hardware. On most platforms, loading LZ4-compressed bundles is CPU bound, and loading uncompressed bundles will be faster. On platforms that have low IO speeds and high CPU speeds, LZ4 loading can be faster. It is always a good practice to run performance analysis to validate whether your game fits the common patterns, or needs some unique tweaking. More information on Unity's compression selection is available in the Asset Bundle documentation . Are there ways to miminize the catalog size? Currently there are two optimizations available. Compress the local catalog. If your primary concern is how big the catalog is in your build, there is an option in the inspector for the top level settings of Compress Local Catalog . This option builds catalog that ships with your game into an asset bundle. Compressing the catalog makes the file itself smaller, but note that this does increase catalog load time. Disable built-in scenes and Resources. Addressables provides the ability to load content from Resources and from the built-in scenes list. By default this feature is on, which can bloat the catalog if you do not need this feature. To disable it, select the \"Built In Data\" group within the Groups window ( Window > Asset Management > Addressables > Groups ). From the settings for that group, you can uncheck \"Include Resources Folders\" and \"Include Build Settings Scenes\". Unchecking these options only removes the references to those asset types from the Addressables catalog. The content itself is still built into the player you create, and you can still load it via legacy API. What is addressables_content_state? After every content build of Addressables, we produce an addressables_content_state.bin file, which is saved to the folder path defined in the Addressable Assets Settings value \"Content State build Path\" appended with / . If this value is empty, the default location will be the Assets/AddressableAssetsData/<Platform>/ folder of your Unity project. This file is critical to our content update workflow . If you are not doing any content updates, you can completely ignore this file. If you are planning to do content updates, you will need the version of this file produced for the previous release. We recommend checking it into version control and creating a branch each time you release a player build. More information is available on our content update workflow page . What are possible scale implications? As your project grows larger, keep an eye on the following aspects of your assets and bundles: Total bundle size - Historically Unity has not supported files larger than 4GB. This has been fixed in some recent editor versions, but there can still be issues. It is recommended to keep the content of a given bundle under this limit for best compatibility across all platforms. Sub assets affecting UI performance - There is no hard limit here, but if you have many assets, and those assets have many sub-assets, it may be best to turn off sub-asset display. This option only affects how the data is displayed in the Groups window, and does not affect what you can and cannot load at runtime. The option is available in the groups window under Tools > Show Sprite and Subobject Addresses . Disabling this will make the UI more responsive. Group hierarchy display - Another UI-only option to help with scale is Group Hierarchy with Dashes . This is available within the inspector of the top level settings. With this enabled, groups that contain dashes '-' in their names will display as if the dashes represented folder hierarchy. This does not affect the actual group name, or the way things are built. For example, two groups called \"x-y-z\" and \"x-y-w\" would display as if inside a folder called \"x\", there was a folder called \"y\". Inside that folder were two groups, called \"x-y-z\" and \"x-y-w\". This will not really affect UI responsiveness, but simply makes it easier to browse a large collection of groups. Bundle layout at scale - For more information about how best to set up your layout, see the earlier question: Is it better to have many small bundles or a few bigger ones Is it possible to retrieve the address of an asset or reference at runtime? In the most general case, loaded assets no longer have a tie to their address or IResourceLocation . There are ways, however, to get the properly associated IResourceLocation and use that to read the field PrimaryKey. The PrimaryKey field will be set to the assets's address unless \"Include Address In Catalog\" is disabled for the group this object came from. In that case, the PrimaryKey will be the next item in the list of keys (probably a GUID, but possibly a Label or empty string). Examples Retrieving an address of an AssetReference. This can be done by looking up the Location associated with that reference, and getting the PrimaryKey: var op = Addressables.LoadResourceLocationsAsync(MyRef1); yield return op; if (op.Status == AsyncOperationStatus.Succeeded && op.Result != null && op.Result.Count > 0) { Debug.Log(\"address is: \" + op.Result[0].PrimaryKey); } Loading multiple assets by label, but associating each with their address. Here, again LoadResourceLocationsAsync is needed: Dictionary<string, GameObject> _preloadedObjects = new Dictionary<string, GameObject>(); private IEnumerator PreloadHazards() { //find all the locations with label \"SpaceHazards\" var loadResourceLocationsHandle = Addressables.LoadResourceLocationsAsync(\"SpaceHazards\", typeof(GameObject)); if( !loadResourceLocationsHandle.IsDone ) yield return loadResourceLocationsHandle; //start each location loading List<AsyncOperationHandle> opList = new List<AsyncOperationHandle>(); foreach (IResourceLocation location in loadResourceLocationsHandle.Result) { AsyncOperationHandle<GameObject> loadAssetHandle = Addressables.LoadAssetAsync<GameObject>(location); loadAssetHandle.Completed += obj => { _preloadedObjects.Add(location.PrimaryKey, obj.Result); }; opList.Add(loadAssetHandle); } //create a GroupOperation to wait on all the above loads at once. var groupOp = Addressables.ResourceManager.CreateGenericGroupOperation(opList); if( !groupOp.IsDone ) yield return groupOp; Addressables.Release(loadResourceLocationsHandle); //take a gander at our results. foreach (var item in _preloadedObjects) { Debug.Log(item.Key + \" - \" + item.Value.name); } }"
  },
  "manual/BuildPlayerContent.html": {
    "href": "manual/BuildPlayerContent.html",
    "title": "AddressableAssetSettings.BuildPlayerContent | Addressables | 1.17.6-preview",
    "keywords": "AddressableAssetSettings.BuildPlayerContent API static void BuildPlayerContent() static void BuildPlayerContent(out AddressablesPlayerBuildResult result) Description AddressableAssetSettings.BuildPlayerContent() is used to build relevant Addressables data into AssetBundles and the corresponding ContentCatalog . It can be used in custom scripts used to assist in continuous integration/deployment. To check for success, use BuildPlayerContent(out AddressablesPlayerBuildResult result) . result.Error will contain any error message returned if the Addressables build failed. If string.IsNullOrEmpty(result.Error) is true, the build was successful. There are a few pieces of information that BuildPlayerContent takes into consideration when performing the build: the AddressablesDefaultSettingsObject , ActivePlayerDataBuilder , and the content_state.bin . The AddressablesDefaultSettingsObject drives which groups get processed and which Addressables profile is used. The profile dictates variables such as local and remote build paths as well as load paths. A default AddressablesDefaultSettingsObject is provided but can be overwritten by setting AddressablesDefaultSettingsObject.Settings to your custom AddressableAssetSettings . Ensure the active profile is set to the desired profile ID before performing the build. If, for example, you have a profile you want to use for a continuous integration pipeline called \"Custom CI Profile\", you can set the active profile using this code snippet, AddressableAssetProfileSettings profileSettings = AddressableAssetSettingsDefaultObject.Settings.profileSettings; string profileId = profileSettings.GetProfileId(\"Custom CI Profile\"); AddressableAssetSettingsDefaultObject.Settings.activeProfileId = profileId; The build is performed using the ActivePlayerDataBuilder , which is determined by a combination of the ActivePlayerDataBuilderIndex and the list of DataBuilders . The list of DataBuilders is comprised of ScriptableObjects , which implement the IDataBuilder interface. A basic example of adding and setting the ActivePlayerDataBuilder would look like this, public void AddAndSetActiveDataBuilder(IDataBuilder dataBuilder) { if (AddressableAssetSettingsDefaultObject.Settings.AddDataBuilder(dataBuilder)) { AddressableAssetSettingsDefaultObject.Settings.ActivePlayerDataBuilderIndex = AddressableAssetSettingsDefaultObject.Settings.DataBuilders.Count - 1; } } This sample adds the IDataBuilder to the list of DataBuilders and then sets the ActivePlayerDataBuilderIndex to the last index of that list. Other useful methods for manipulating the DataBuilders are RemoveDataBuilder and SetDataBuilderAtIndex . It may also be desirable to save content state between builds, typically for use with content build updates. Addressables uses a content_state.bin to save the AssetState into a structure called a CachedAssetState . Retrieval of the .bin file can be done as follows, string contentStatePath = ContentUpdateScript.GetContentStateDataPath(false); AddressablesContentState contentState = ContentUpdateScript.LoadContentState(contentStatePath); //... and then saving the new content state can be done using ContentUpdateScript.SaveContentState(...) ."
  },
  "manual/ContentUpdateWorkflow.html": {
    "href": "manual/ContentUpdateWorkflow.html",
    "title": "Content update workflow | Addressables | 1.17.6-preview",
    "keywords": "Content update workflow Addressables provides a content update workflow intended for games that will dynamically be downloading content from a CDN. In this situation, a player (app, exe, apk, etc.) is built and deployed (such as through the Android app store). While running, the app will contact a CDN to discover and download additional content. This is not the same as games that use platform provided patching systems (such as Switch or Steam). For these games the every build of the game should be a complete fresh content build, completely bypassing the update flow. In this instance, the addressables_content_state.bin file that is generated after each build can be discarded or ignored. Project structure Unity recommends structuring your game content into two categories: Cannot Change Post Release : Static content that you never expect to update. Can Change Post Release : Dynamic content that you expect to update. In this structure, content marked as Cannot Change Post Release ships with the application (or downloads soon after install), and resides in very few large bundles. Content marked as Can Change Post Release resides online, ideally in smaller bundles to minimize the amount of data needed for each update. One of the goals of the Addressable Assets System is to make this structure easy to work with and modify without having to change your scripts. However, the Addressable Assets System can also accommodate situations that require changes to the content marked as Cannot Change Post Release , when you don't want to publish a whole new application build. Modified assets and their dependencies (and dependents) will be duplicated in new bundles that will be used instead of the shipped content. This can result in a much smaller update than replacing the entire bundle or rebuilding the game. Once a build has been made, it is important to NOT change the state of a group from \"Cannot Change Post Release\" to \"Can Change Post Release\" or vice versa until an entirely new build is made. If the groups change after a full content build but before a content update, Addressables will not be able to generate the correct changes needed for the update. Note that in cases that do not allow remote updates (such as many of the current video-game consoles, or games without a server), you should make a complete and fresh build every time. How it works Addressables uses a content catalog to map an address to each Asset, specifying where and how to load it. In order to provide your app with the ability to modify that mapping, your original app must be aware of an online copy of this catalog. To set that up, enable the Build Remote Catalog setting on the AddressableAssetSettings Inspector. This ensures that a copy of the catalog gets built to and loaded from the specified paths. This load path cannot change once your app has shipped. The content update process creates a new version of the catalog (with the same file name) to overwrite the file at the previously specified load path. Building an application generates a unique app content version string, which identifies what content catalog each app should load. A given server can contain catalogs of multiple versions of your app without conflict. We store the data we need in the addressables_content_state.bin file. This includes the version string, along with hash information for any Asset that is contained in a group marked as Cannot Change Post Release . By default, this is located in the Assets/AddressableAssetsData/\\<platform\\> Project directory, where \\<platform\\> is your target platform. The addressables_content_state.bin file contains hash and dependency information for every Cannot Change Post Release Asset group in the Addressables system. All groups building to the StreamingAssets folder should be marked as Cannot Change Post Release , though large remote groups may also benefit from this designation. During the next step (preparing for content update, described below), this hash information determines if any Cannot Change Post Release groups contain changed Assets, and thus need those Assets moved elsewhere. Update life cycle The first step in the process of building content is always a fresh full build. This can be triggered from within the Addressables Groups window in the Unity Editor ( Window > Asset Management > Addressables > Groups ). Once there, selecting your build script from Build > New Build . Unless you create a custom build, the only option will be Default Build Script . Every time a full player build is created (such as through File > Build and Run ), this should be preceded by a full content build of Addressables. After a player build is created, if you wish to update it's contents via a CDN, then it becomes time to do a content update build. Life cycle example This is a sample flow over the course of your game's existence. More details of key steps are outlined later in this document. Create and refine content until ready for initial release. Trigger initial addressables content build via the Groups window. Build a player, such as via Build and Run. Continue to refine & iterate on content. If you do not have a CDN, and are not dynamically downloading content, after step 4, return to step 2 to create a fresh content build and fresh player. If you do distribute content via CDN, continued iteration involves more steps. I will refer to the player built in step 3 above as \"PlayerBuild1\". Steps continue as follows: Optionally trigger Check for Content Update Restrictions (see Identifying changed assets below). Trigger a content update build via Update a Previous Build (see Building for content updates below). At this point you can repeat steps 4-6 until you are ready to create a new player to submit to your platform of choice. Optionally save addressables_content_state.bin file and branch content. Optionally create a new build destination on your CDN. Especially if changing Unity version. When creating a new player, there are two scenarios to consider. In the simplest case, you are never going to distribute new content for \"PlayerBuild1\". The content you have released so far for \"PlayerBuild1\" is all users will get until they update to future player builds. In this scenario, you do not do step 7, and simply return from step 6 back to step 2, this time creating \"PlayerBuild2\", and only making content updates for it. In the more complex scenario, you wish to build a \"PlayerBuild2\", but make a new content available to both players. Here, you must do step 7, saving your addressables_content_state.bin . The simplest way to handle this is to completely branch your content. This ensures properly named catalogs and content for each build. There are ways around this, but they involve leaving the standard catalog creation and naming systems. The purpose of step 8 is to ensure each player build has a clean space to download content. Often this isn't needed, but is safer. One key example where it is an absolute must is when you have updated Unity version, but not some content. If an AssetBundle is built with identical content, but two different Unity versions, the hash will be the same, but the CRC will be different. This means, with any of our bundle naming schemes, the new bundle will have the same name as the old one (thus overwritting it). As it also has a new CRC, the old player will not be able to download it successfully (we keep up with CRC's in our catalog for download safety). Planning for content updates When planning for a content update, there are a few items to ensure are set up correctly during the initial build (step 2 above). First is that the correct groups are tagged with \"Can\" or \"Cannot\" change as described above. The next is that the addressables_content_state.bin file that is generated off of this build is saved. By default this is built to Assets/AddressableAssetsData/\\<platform\\> Project directory, where \\<platform\\> is your target platform. We recommend using version control to save the file at this point. When a full rebuild is required Addressables can only distribute content, not code. As such, a code change generally necessitates a fresh player build, and often a fresh build of content. In some instances a new player can download old content from a CDN, but this requires a careful analysis of what type tree was created during the initial build. This is advanced territory to explored carefully. Note that Addressables itself is code, so updating Addressables or Unity version likely requires creating a new player build and fresh content builds. Unique Bundle IDs Unique Bundle IDs is an advanced option that should only be enabled if you require the ability to load new versions of content while old versions are still in memory. There is an extra cost associated with build and content refreshes if this option is on. When loading AssetBundles into memory, Unity enforces that two bundles cannot be loaded with the same internal names. This can put some limitations on updating bundles at runtime. As Addressables supports updating the catalog outside of initialization, it's possible to update content that you have already loaded. To make this work, one of two things must happen. One option is to unload all your Addressables content prior to updating the catalog. This ensures new bundles with old names will not cause conflicts in memory. The second option is to ensure that your updated AssetBundles have unique internal identifiers. This would allow you to load new bundles, while the old are still in memory. We have an option to enable this second option. Turn on \"Unique Bundle IDs\" within the AddressableAssetSettings Inspector. The downside of this option is that it requires bundles to be rebuilt up the dependency chain. Meaning if you changed a material in one group, by default only the material's bundle would be rebuilt. With \"Unique Bundle IDs\" on, any Asset that references that material would also need rebuilding. Identifying changed assets If you have modified Assets in any Cannot Change Post Release groups, you'll need to run the Check for Content Update Restrictions command (step 5 above). This will take any modified Asset, its dependencies if their bundle name was modified, and all other Assets that depend on the modified Asset out of the Cannot Change Post Release groups and move them to a new group. To generate the new Asset groups: Open the Addressables Groups window in the Unity Editor ( Window > Asset Management > Addressables > Groups ). In the Addressables Groups window, select Tools on the top menu bar, then Check for Content Update Restrictions . In the Build Data File dialog that opens, select the addressables_content_state.bin file (by default, this is located in the Assets/AddressableAssetsData/\\<platform\\> Project directory, where \\<platform\\> is your target platform). This data is used to determine which Assets or dependencies have been modified since the application was last built. The system moves these Assets, their dependencies if their bundle name was modified, and all other Assets that depend on the modified Assets to a new group in preparation for the content update build. Note : This command will do nothing if all your changes are confined to Can Change Post Release groups. Important : Before running the prepare operation, Unity recommends branching your version control system. The prepare operation rearranges your Asset groups in a way suited for updating content. Branching ensures that next time you ship a new player, you can return to your preferred content arrangement. Building for content updates To build for a content update: Open the Addressables Groups window in the Unity Editor ( Window > Asset Management > Addressables > Groups ). In the Addressables Groups window, select Build on the top menu, then Update a Previous Build . In the Build Data File dialog that opens, select the build folder of an existing application build. The build folder must contain an addressables_content_state.bin file (by default, this is located in the Assets/AddressableAssetsData/\\<platform\\> Project directory, where \\<platform\\> is your target platform). The build generates a content catalog, a hash file, and the AssetBundles. The generated content catalog has the same name as the catalog in the selected application build, overwriting the old catalog and hash file. The application loads the hash file to determine if a new catalog is available. The system loads unmodified Assets from existing bundles that were shipped with the application or already downloaded. The system uses the content version string and location information from the addressables_content_state.bin file to create the AssetBundles. AssetBundles that do not contain updated content are written using the same file names as those in the build selected for the update. If an AssetBundle contains updated content, a new AssetBundle is generated that contains the updated content, with a new file name so that it can coexist with the original. Only AssetBundles with new file names must be copied to the location that hosts your content. The system also builds AssetBundles for content that cannot change, but you do not need to upload them to the content hosting location, as no Addressables Asset entries reference them. Note that you should not change the build scripts between building a new player and making content updates (e.g., player code, addressables). This could cause unpredictable behavior in your application. Additionally if you delete the local content bundles created by your Addressables build from the Project Library folder, attempts to load Assets in those bundles fail when you run your game or application in the Editor and use the Use Existing Build (requires built groups) Play Mode script. Checking for content updates at runtime You can add a custom script to periodically check whether there are new Addressables content updates. Use the following function call to start the update: public static AsyncOperationHandle<List<string>> CheckForCatalogUpdates(bool autoReleaseHandle = true) where List<string> contains the list of modified locator IDs. You can filter this list to only update specific IDs, or pass it entirely into the UpdateCatalogs API. If there is new content, you can either present the user with a button to perform the update, or do it automatically. Note that it is up to the developer to make sure that stale Assets are released. The list of catalogs can be null and if so, the following script updates all catalogs that need an update: public static AsyncOperationHandle<List<IResourceLocator>> UpdateCatalogs(IEnumerable<string> catalogs = null, bool autoReleaseHandle = true) The return value is the list of updated locators. Content update examples In this example, a shipped application is aware of the following groups: Local_Static Remote_Static Remote_NonStatic AssetA AssetL AssetX AssetB AssetM AssetY AssetC AssetN AssetZ Note that Local_Static and Remote_Static are part of the Cannot Change Post Release groups. As this version is live, there are players that have Local_Static on their devices, and potentially have either or both of the remote bundles cached locally. If you modify one Asset from each group ( AssetA , AssetL , and AssetX ), then run Check for Content Update Restrictions , the results in your local Addressable settings are now: Local_Static Remote_Static Remote_NonStatic content_update_group (non-static) AssetX AssetA AssetB AssetM AssetY AssetL AssetC AssetN AssetZ Note that the prepare operation actually edits the Cannot Change Post Release groups, which may seem counterintuitive. The key, however, is that the system builds the above layout, but discards the build results for any such groups. As such, you end up with the following from a player's perspective: Local_Static AssetA AssetB AssetC The Local_Static bundle is already on player devices, which you can't change. This old version of AssetA is no longer referenced. Instead, it is stuck on player devices as dead data. Remote_Static AssetL AssetM AssetN The Remote_Static bundle is unchanged. If it is not already cached on a player's device, it will download when AssetM or AssetN is requested. Like AssetA , this old version of AssetL is no longer referenced. Remote_NonStatic (old) AssetX AssetY AssetZ The Remote_NonStatic bundle is now old. You could delete it from the server, but either way it will not be downloaded from this point forward. If cached, it will eventually leave the cache. Like AssetA and AssetL , this old version of AssetX is no longer referenced. Remote_NonStatic (new) AssetX AssetY AssetZ The old Remote_NonStatic bundle is replaced with a new version, distinguished by its hash file. The modified version of AssetX is updated with this new bundle. content_update_group AssetA AssetL The content_update_group bundle consists of the modified Assets that will be referenced moving forward. Note that the example above has the following implications: Any changed local Assets remain unused on the user's device forever. If the user already cached a non-static bundle, they will need to re-download the bundle, including the unchanged Assets (in this instance, for example, AssetY and AssetZ ). Ideally, the user has not cached the bundle, in which case they simply need to download the new Remote_NonStatic bundle. If the user has already cached the Static_Remote bundle, they only need to download the updated asset (in this instance, AssetL via content_update_group ). This is ideal in this case. If the user has not cached the bundle, they must download both the new AssetL via content_update_group and the now-defunct AssetL via the untouched Remote_Static bundle. Regardless of the initial cache state, at some point the user will have the defunct AssetL on their device, cached indefinitely despite never being accessed. The best setup for your remote content will depend on your specific use case. How Content Update Handles Dependencies Directly changing an asset is not the only way to have it flagged as needing to be rebuilt as part of a content update. Changing an assets dependencies is a less obvious factor that gets taken into account when building an update. Lets take part of the example above: Local_Static AssetA AssetB AssetC but now let us assume more information about a few of the assets. Let's say we have a dependency chain that looks like this: AssetA depends on Dependency1 which depends on Dependency2 AssetB depends on Dependency2 AssetC depends on Dependency3 Where all three dependencies are a mix of Addressable and non-Addressable assets. Now, if only Dependency1 is changed and Check For Content Update Restriction is run, the resulting project structure looks like: Local_Static content_update_group AssetA AssetB AssetC If only Dependency2 is changed: Local_Static content_update_group AssetA AssetB AssetC Finally, if only Dependency3 is changed: Local_Static content_update_group AssetA AssetB AssetC This is because when a dependency is changed the entire dependency tree needs to be rebuilt. Let's take a look at one more example with the following dependency tree. AssetA depends on AssetB which depends on Dependency2 AssetB depends on Dependency2 AssetC depends on Dependency3 Now, if Dependency2 is changed, the project structure looks like: Local_Static content_update_group AssetA AssetB AssetC because AssetA relies on AssetB and AssetB relies on Dependency2 . Since the entire chain needs to be rebuilt both AssetA and AssetB will get put into the content_update_group ."
  },
  "manual/DiagnosticTools.html": {
    "href": "manual/DiagnosticTools.html",
    "title": "Diagnostic tools | Addressables | 1.17.6-preview",
    "keywords": "Diagnostic tools Build layout report The build layout report provides detailed information and statistics about your Addressables builds, including: Description of AssetBundles Sizes of each Asset and AssetBundle Explanation of non-explicit Assets that were pulled into AssetBundles AssetBundle dependencies Because compiling the report increases build time, the build layout report is disabled by default. You can enable the report in the Addressables section of the Preferences window . Once enabled, the report is created whenever you build Addressables content. You can find the report in your project folder at Library/com.unity.addressables/buildlayout.txt . See Building your Addressable content for more information about building content. Build Profiling Running an Addressables build creates a .json log file that contains build performance information. You can find the log file in your project folder at Library/com.unity.addressables/AddressablesBuildTEP.json . View the log file by entering the chrome://tracing URL in Google Chrome. A sample log file being displayed in chrome://tracing See Unity Scriptable Build Pipeline for more information about build performance logging. The Addressables Analyze tool Analyze is a tool that gathers information on your Projects' Addressables layout. In some cases, Analyze may take appropriate actions to clean up the state of your Project. In others, Analyze is purely an informational tool that allows you to make more informed decisions about your Addressables layout. Using Analyze In the Editor, open the Addressables Analyze window ( Window > Asset Management > Addressables > Analyze ), or open it via the Addressables Groups window by clicking the Tools > Analyze button. The Analyze window displays a list of Analyze rules, along with the following operations: Analyze Selected Rules Clear Selected Rules Fix Selected Rules The analyze operation The analyze operation is the information-gathering step of the rule. Running this action on a rule or set of rules gathers data about the build, dependency maps, and more. Each rule is responsible for gathering the desired data and reporting it back as a list of AnalyzeResult objects. No action should be taken to modify any data or the state of the Project during the analyze step. Based on the data gathered in this step, the fix operation may be the appropriate course of action. Some rules, however, only contain an analyze step, as no reasonably appropriate and universal action can be taken based on the information gathered. Check Scene to Addressable Duplicate Dependencies and Check Resources to Addressable Duplicate Dependencies are examples of such rules. Rules that are purely informational and contain no fix operation are categorized as Unfixable Rules . Those that do have a fix operation are categorized as Fixable Rules . The clear step This operation will remove any data gathered by the analysis and update the TreeView accordingly. The fix operation For Fixable Rules , you may choose to run the fix operation. This uses data gathered during the analyze step to perform any necessary modifications and resolve the issues. Check Duplicate Bundle Dependencies is an example of a fixable rule, because there is a reasonably appropriate action that can be taken to resolve the issues detected in the analysis. Provided Analyze rules Fixable rules Check Duplicate Bundle Dependencies This rule checks for potentially duplicated assets, by scanning all groups with BundledAssetGroupSchemas and projecting the asset group layout. This essentially requires triggering a full build, so this check is time-consuming and performance-intensive. Issues : Duplicated assets result from assets in different groups sharing dependencies, for example two Prefabs that share a material existing in different Addressable groups. That material (and any of its dependencies) would be pulled into both groups containing the Prefabs. To prevent this, the material must be marked as Addressable, either with one of the Prefabs, or in its own space, thereby putting the material and its dependencies in a separate Addressable group. Resolution : If this check discovers any issues, running the fix operation on this rule creates a new Addressable group in which to move all dependent assets. Exceptions : If you have an asset containing multiple objects, it is possible for different groups to only pull in portions of the asset, and not actually duplicate. An FBX with many meshes is an example of this. If one mesh is in \"GroupA\" and another is in \"GroupB\", this rule will think that the FBX is shared, and extract it into its own group if you run the fix operation. In this edge case, running the fix operation is actually harmful, as neither group would have the full FBX asset. Also note that duplicate assets may not always be an issue. If assets will never be requested by the same set of users (for example, region-specific assets), then duplicate dependencies may be desired, or at least inconsequential. Each Project is unique, so fixing duplicate asset dependencies should be evaluated on a case by case basis. Unfixable rules Check Resources to Addressable Duplicate Dependencies This rule detects if any assets or asset dependencies are duplicated between built Addressable data and assets residing in a Resources folder. Issues : These duplications mean that data will be included in both the application build and the Addressables build. Resolution : This rule is unfixable, because no appropriate action exists. It is purely informational, alerting you to the redundancy. You must decide how to proceed and what action to take, if any. One example of a possible manual fix is to move the offending asset(s) out of the Resources folder, and make them Addressable. Check Scene to Addressable Duplicate Dependencies This rule detects any assets or asset dependencies that are shared between the Scenes in the Editor Scene list and Addressables. Issues : These duplications mean that data will be included in both the application build and the Addressables build. Resolution : It is purely informational, alerting you to the redundancy. You must decide how to proceed and what action to take, if any. One example of a possible manual fix is to pull the built-in Scene(s) with duplicated references out of Build Settings and make it an Addressable Scene. Build Bundle Layout This rule will show how assets explicitly marked as Addressable will be laid out in the Addressable build. Given these explicit assets, we also show what assets are implicitly referenced by, and therefore will be pulled into, the build. Data gathered by this rule does not indicate any particular issues. It is purely informational. Extending Analyze Each unique Project may require additional Analyze rules beyond what comes pre-packaged. The Addressable Assets System allows you to create your own custom rule classes. AnalyzeRule objects Create a new child class of the AnalyzeRule class, overriding the following properties: CanFix tells Analyze if the rule is deemed fixable or not. ruleName is the display name you'll see for this rule in the Analyze window . You'll also need to override the following methods, which are detailed below: List<AnalyzeResult> RefreshAnalysis(AddressableAssetSettings settings) void FixIssues(AddressableAssetSettings settings) void ClearAnalysis() Note : If your rule is designated unfixable, you don't have to override the FixIssues method. RefreshAnalysis This is your analyze operation. In this method, perform any calculations you'd like and cache any data you might need for a potential fix. The return value is a List<AnalyzeResult> list. After you'd gathered your data, create a new AnalyzeResult for each entry in your analysis, containing the data as a string for the first parameter and a MessageType for the second (to optionally designate the message type as a warning or error). Return the list of objects you create. If you need to make child elements in the TreeView for a particular AnalyzeResult object, you can delineate the parent item and any children with kDelimiter . Include the delimiter between the parent and child items. FixIssues This is your fix operation. If there is an appropriate action to take in response to the analyze step, execute it here. ClearAnalysis This is your clear operation. Any data you cached in the analyze step can be cleaned or removed in this function. The TreeView will update to reflect the lack of data. Adding custom rules to the GUI A custom rule must register itself with the GUI class using AnalyzeSystem.RegisterNewRule<RuleType>() , in order to show up in the Analyze window. For example: class MyRule : AnalyzeRule {} [InitializeOnLoad] class RegisterMyRule { static RegisterMyRule() { AnalyzeSystem.RegisterNewRule<MyRule>(); } }"
  },
  "manual/DownloadDependenciesAsync.html": {
    "href": "manual/DownloadDependenciesAsync.html",
    "title": "Addressables.DownloadDependenciesAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.DownloadDependenciesAsync API static AsyncOperationHandle DownloadDependenciesAsync(object key, bool autoReleaseHandle = false) static AsyncOperationHandle DownloadDependenciesAsync(IList<IResourceLocation> locations, bool autoReleaseHandle = false) static AsyncOperationHandle DownloadDependenciesAsync(IEnumerable keys, MergeMode mode, bool autoReleaseHandle = false) Returns AsyncOperationHandle : an async operation handle that encompasses all the operations used to download the requested dependencies. Once complete, this handle can be safely released. Description Addressables.DownloadDependenciesAsync is primarily designed to be used to download and cache remote AssetBundles prior to their use at runtime. Caching AssetBundles early leads to improved performance on any initial call, such as a LoadAssetAsync , that would have otherwise needed to download the bundles as part of their operation. After reading the Result of this operation, it is best practice to release the handle manually; though the memory footprint is low, should you keep it in memory. This operation can be safely released once it is complete or you can pass true in the autoReleaseHandle parameter to ensure it is released on completion. Of note, if the handle is released you won't be able to check the success of the operation handle through the Status property since the release invalidates the operation handle. Downloaded AssetBundles are stored in the engines AssetBundle cache. Addressables provides a type of initialization object called a CacheInitializationSettings which can be used to control the AssetBundle cache settings. Related API AsyncOperationHandle.GetDownloadStatus() will return information about how many bytes have been downloaded, and how many are needed. This is the API that should be used in place of AsyncOperationHandle.PercentComplete when working with any download operaion. See AsyncOperationHandle . GetDownloadSizeAsync checks the total size of all AssetBundles that need to be downloaded. Cached AssetBundles return a size of 0. Unlike most operations that don't load anything, GetDownloadSizeAsync does not autorelease. It does not autorelease because the Result is needed which could not be accessed from a released handle. Once you have read the size out of the Result , you are responsible for releasing the operation handle; not doing so has little impact on the memory footprint. ClearDependencyCacheAsync clears any cached AssetBundles for a given key or list of keys and its dependencies. It is also possible to use the UnityEngine.Caching APIs to manipulate the cache used by Addressables. Of note, ClearDependencyCacheAsync works off the current content catalog. This means if an AssetBundle is downloaded and cached, and the content catalog is updated to point to a new version of that AssetBundle , and it is possible for the previously cached bundle to remain in the cache until the cache says it's expired. Code Sample public IEnumerator Start() { string key = \"assetKey\"; //Clear all cached AssetBundles Addressables.ClearDependencyCacheAsync(key); //Check the download size AsyncOperationHandle<long> getDownloadSize = Addressables.GetDownloadSizeAsync(key); yield return getDownloadSize; //If the download size is greater than 0, download all the dependencies. if (getDownloadSize.Result > 0) { AsyncOperationHandle downloadDependencies = Addressables.DownloadDependenciesAsync(key); yield return downloadDependencies; } //... } Pitfalls Some platforms, such as PlayStation 4 and Nintendo Switch, do not support local AssetBundle caching."
  },
  "manual/ExceptionHandler.html": {
    "href": "manual/ExceptionHandler.html",
    "title": "ResourceManager.ExceptionHandler | Addressables | 1.17.6-preview",
    "keywords": "ResourceManager.ExceptionHandler API static Action<AsyncOperationHandle, Exception> ExceptionHandler Description The ResourceManager.ExceptionHandler allows you to create and set custom exception handlers for the Addressables runtime. If no ExceptionHandler is provided, a default implementation is used. Exceptions created during runtime error scenarios do not get automatically thrown. They are sent to the ExceptionHandler and reported in the AsyncOperationHandle.OperationException of any given operation. Code Sample void Start() { ResourceManager.ExceptionHandler = CustomExceptionHandler; //... } //Gets called for every error scenario encountered during an operation. //A common use case for this is having InvalidKeyExceptions fail silently when a location is missing for a given key. void CustomExceptionHandler(AsyncOperationHandle handle, Exception exception) { if (exception.GetType() != typeof(InvalidKeyException)) Addressables.LogException(handle, exception); }"
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Unity Addressable Asset system | Addressables | 1.17.6-preview",
    "keywords": "Unity Addressable Asset system The Addressable Asset system provides an easy way to load assets by “address”. It handles asset management overhead by simplifying content pack creation and deployment. The Addressable Asset system uses asynchronous loading to support loading from any location with any collection of dependencies. Whether you use direct references, traditional AssetBundles , or Resource folders for asset management, Addressable Assets provide a simpler way to make your game more dynamic. What is an asset? An asset is content that you use to create your game or app. Common examples of assets include Prefabs, textures, materials, audio clips, and animations. What is an Addressable Asset? Making an asset \"Addressable\" allows you to use that asset's unique address to call it from anywhere. Whether that asset resides in the local application or on a content delivery network, the Addressable Asset System locates and returns it. You can load a single Addressable Asset via its address, or load many Addressable Assets using a custom group label that you define. Why use Addressable Assets? Traditional means of structuring game assets make it challenging to efficiently load content. Addressables shorten your iteration cycles, allowing you to devote more time to designing, coding, and testing your application. Iteration time : Referring to content by its address is extremely efficient. Optimizations to the content no longer require changes to your code. Dependency management : The system returns all dependencies of the requested content, so that all meshes, shaders, animations, and so forth load before returning the content to you. Memory management : The system unloads assets as well as loading them, counting references automatically and providing a robust profiler to help you spot potential memory problems. Content packing : Because the system maps and understands complex dependency chains, it allows for efficient packing of bundles, even when moving or renaming assets. You can easily prepare assets for both local and remote deployment, to support downloadable content and reduced application size. Profiles : The system allows you to create a set of string variables that more easily enables you to change how your content is built into bundles without modifying settings in multiple places. What about my existing game? The Addressable Asset System provides a migration path for upgrading, whether you use direct references, Resource folders, or AssetBundles."
  },
  "manual/InitializeAsync.html": {
    "href": "manual/InitializeAsync.html",
    "title": "Addressables.InitializeAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.InitializeAsync API AsyncOperationHandle<IResourceLocator> Addressables.InitializeAsync() Returns AsyncOperationHandle<IResourceLocator> : The AsyncOperationHandle for the InitializationOperation . This handle is automatically released after it completes. Description Initializing Addressables is a preliminary operation that has the responsibility of setting up the runtime data for Addressables. Addressables.InitializeAsync creates and executes an InitializationOperation operation. This operation does the following: Sets up the ResourceManager and the ResourceLocators . Loads the RuntimeData that Addressables built in the Editor. Executes InitializationObjects operations that were added to the Addressables build. Loads the ContentCatalog . Optionally checks for updates to the ContentCatalog . By default this check is turned on. You can manually initialize Addressables, though it is not required, by calling Addressables.InitializeAsync() . If Addressables is not manually initialized, by default Addressables checks that initialization has occurred. If the initial call, such as a LoadAsset request, detects that initialization has not occured then an InitilizationOperation is kicked off automatically. The LoadAsset operation is chained behind the initialization operation and executes automatically afterwards. By default Addressables sets up an ExceptionHandler in the ResourceManager for any exceptions that get logged. An exception handler can be setup manually by assigning a custom handler to UnityEngine.ResourceManagement.ResourceManager.ExceptionHandler . It is also possible to turn off runtime exception logging in the ResourceManager by unchecking the box Log Runtime Exceptions on the AddressableAssetSettingsObject . //Manual initialization IEnumerator Start() { AsyncOperationHandle<IResourceLocator> handle = Addressables.InitializeAsync(); yield return handle; //... } Manual initialization can have performance benefits on your initial load. If you know you will use Addressables and don't want to incur the cost of initialization on your first Addressables operation, calling this manually can be a potential solution. It may be preferable to manually initialize Addressables for debugging purposes. Lazy-initialization through a chain operation can muddle errors and make the root of the problem unclear. Manual initialization keeps that process separate which can help narrow down any issues. The Result of this operation is an IResourceLocator . This object contains a list of Addressable keys and a method that can be used to gather the IResourceLocation(s) for a given key and asset type. Access to the Result or Status is only available in a Completed callback. If a yield return is used instead, the Addressables will have auto-released the handle by the time access is attempted. Full API documentation can be found here . InitializationObjects These are ScriptableObjects that can be added to an Addressable build to bootstrap some operation as part of Addressables initialization. For example, the CacheInitializationObject is provided by default. If one of these objects is created and added to the AddressableAssetSettings object, under Initialization Objects, it can be used to automatically setup Cache settings at runtime. Custom Initialization objects can be implemented and created by creating a class and inheriting from ScriptableObject and implementing IObjectInitializationDataProvider ."
  },
  "manual/InstantiateAsync.html": {
    "href": "manual/InstantiateAsync.html",
    "title": "Addressables.InstantiateAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.InstantiateAsync API static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) static AsyncOperationHandle<GameObject> InstantiateAsync(IResourceLocation location, InstantiationParameters instantiateParameters, bool trackHandle = true) static AsyncOperationHandle<GameObject> InstantiateAsync(object key, Transform parent = null, bool instantiateInWorldSpace = false, bool trackHandle = true) static AsyncOperationHandle<GameObject> InstantiateAsync(object key, Vector3 position, Quaternion rotation, Transform parent = null, bool trackHandle = true) static AsyncOperationHandle<GameObject> InstantiateAsync(object key, InstantiationParameters instantiateParameters, bool trackHandle = true) Returns AsyncOperationHandle<GameObject> : an async operation handle that contains the instantiated GameObject as the Result . Description Addressables.InstantiateAsync is the Addressables mechanism used to instantiate GameObjects by either key or direct IResourceLocation . There are multiple ways Addressables can be used to instantiate a GameObject , each with their own set of pros and cons. The main two ways are using the Addressables.InstanitateAsync API directly, or using the Addressables.LoadAssetAsync<GameObject> API and then manually instantiating the GameObject yourself. If you are instantiating a GameObject through the InstanitateAsync API, you have the convenience of allowing Addressables to do all the work of resolving the IResourceLocation if the key version of the API is used. Regardless which version of the API is used, Addressables downloads all the required dependencies, and instantiates the object for you. As a note, the instantation itself is synchronous. The asynchronous aspect of this API comes from all the loading-related activity Addressables does prior to instantiation. If the GameObject has been preloaded using LoadAssetAsync or LoadAssetsAsync the operation and instantiation becomes synchrounous. For example: IEnumerator Start() { string key = \"myprefab\"; AsyncOperationHandle<GameObject> loadOp = Addressables.LoadAssetAsync<GameObject>(key); yield return loadOp; if (loadOp.Status == AsyncOperationStatus.Succeeded) { var op = Addressables.InstantiateAsync(key); if (op.IsDone) // <--- this will always be true. A preloaded asset will instantiate synchronously. { //... } //... } } The downside to using this API is that it incurs overhead that can be mitigated by handing instantiation manually. Should you decide to synchronously instantiate a GameObject manually, you'll need to use the LoadAssetAsync API to first load the required assets and dependencies. With the loaded GameObject , you can manually instantiate the Result like so: public IEnumerator Start() { AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>(\"prefabKey\"); yield return handle; if(handle.Result != null) Instantiate(handle.Result); //,,. } This has the added benefit of being able to keep the load operation handle in memory and instantiating the Result as often as needed without incuring additional unwanted overhead. One downside is it's be possible to release the load handle too early and unload all the data needed by any currently instantiated prefabs. If there are any issues during the excecution of these operations, an Exception is generated and returned in the operations OperationException . That exception is also logged as an error by default. If you would like to see the exceptions when they happen, process them, and choose how to handle them, see ResourceManager.ExceptionHandler . Either use of instantiation can benefit from information found in the Memory Management manual page. Code Sample public IEnumerator Start() { AsyncOperationHandle<GameObject> handle = Addressables.InstantiateAsync(\"prefabKey\"); //note that this may be done instantly, but if you yield return, it guarantees a miminum one frame delay. // The same is true for the .Completed callback, even if done, it will not callback that frame. if(!handle.IsDone) yield return handle; //... }"
  },
  "manual/LoadContentCatalogAsync.html": {
    "href": "manual/LoadContentCatalogAsync.html",
    "title": "Addressables.LoadContentCatalogAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.LoadContentCatalogAsync API static AsyncOperationHandle<IResourceLocator> LoadContentCatalogAsync(string catalogPath, string providerSuffix = null) static AsyncOperationHandle<IResourceLocator> LoadContentCatalogAsync(string catalogPath, bool autoReleaseHandle, string providerSuffix = null) Returns AsyncOperationHandle<IResourceLocator> : An async operation handle that returns the IResourceLocator loaded by the catalog. After the operation has completed, it is safe to release this handle. No further action is required to load the content catalog once the operation completes. The IResourceLocator returned from the operation is available but not needed to make use of the newly loaded catalog. Best Practice Pass true into the autoReleaseHandle parameter. Description LoadContentCatalogAsync is used to load a secondary Content Catalog. The Content Catalog returns an IResourceLocator , which maps addresses to asset locations. Using this API allows you to load assets built by Addressables from a project separate than that which contains your runtime player build. It is a common case for larger projects to split the project with asset content from the project containing runtime scripts; typically this is done to reduce import times. Addressables supports this workflow through the LoadContentCatalogAsync API. Both projects need to contain the Addressables package and build their player content for the appropriate platform. The content project must build all of its content into remote Addressable groups. Also ensure that Build Remote Catalog is turned on for the content project. From there, place the AssetBundles from the content project into the desired remote location and load the catalog in your runtime project. It is also possible to end up with multiple secondary catalogs if you're using a custom build script to build your player content. Once the secondary catalog is loaded, you can use the keys built into that catalog with the Addressables APIs. Also, once a secondary catalog is loaded it cannot be unloaded. The AsyncOperationHandle can safely be released or you can pass in true to the autoReleaseHandle parameter. Once a secondary catalog is downloaded, it is cached locally if a corresponding .hash file is located alongside the catalog's .json file. The API looks for a .hash file of the same name as the catalog in the same directory as the catalog itself. The .hash file contains the current hash of the content catalog. If no .hash file can be found, the remote catalog is downloaded on all future requests. Otherwise, when loading the remote catalog on subsequent application starts, the local hash of the catalog is compared against the hash of the remote catalog at the given location. If a different hash is detected, the remote catalog is downloaded, cached, and used. If the remote and local hash match, or if there is no internet connection, the cached catalog is used. If you need to update catalogs (either primary or secondary) during runtime. You must release the returned handle or use true for autoReleaseHandle when using LoadContentCatalogAsync. Refer to the UpdateCatalogs documentation. The providerSuffix parameter can be used to ensure unique IDs for the resource providers loaded from a given catalog. The string passed in will be appended to all provider IDs. Code Sample public IEnumerator Start() { //Load a catalog and automatically release the operation handle. AsyncOperationHandle<IResourceLocator> handle = Addressables.LoadContentCatalogAsync(\"path_to_secondary_catalog\", true); yield return handle; //... }"
  },
  "manual/LoadingAddressableAssets.html": {
    "href": "manual/LoadingAddressableAssets.html",
    "title": "Addressables.LoadAsset(s)Async | Addressables | 1.17.6-preview",
    "keywords": "Addressables.LoadAsset(s)Async Addressables.LoadAssetAsync static AsyncOperationHandle<TObject> LoadAssetAsync<TObject>(object key) static AsyncOperationHandle<TObject> LoadAssetAsync<TObject>(IResourceLocation location) Returns AsyncOperationHandle<TObject> - The operation handle for a single requested asset. Description Loads a single Addressable Asset. Addressables.LoadAssetAsync uses the key of an Addressable object or direct ResourceLocations to load an Addressable asset of a specified type. The loaded asset can be accessed through the Result property of the AsyncOperationHandle returned by the function. This API does the following: Gathers all dependencies for the given key or resource location. The key version of the API incurs an additional step to lookup the first IResourceLocation that matches the provided key. Downloads any remote AssetBundles that are required. Loads the AssetBundles into memory. Populates the Result property with the requested object. The internal operation of the AsyncOperationHandle returned will have a reference count of 1 by default. This handle will need to be manually released in order to decrease the reference count and unload the AssetBundles in memory. If there are multiple request calls for the same asset, then the reference count for the underlying internal operation increases, and the cached load operation is not used. This means that all newly-created handles need to ensure they are properly released in order to unload the AssetBundles. Note that there is also the option to load an asset with the helper function LoadAssetAsync in the AssetReference class (for example AssetRefMember.LoadAssetAsync<GameObject>() ) but it has more restrictions to reference count. When called, it caches the handle in the AssetReference of the load if successful. Due to the cached handle, this load cannot be called again to load or increase the reference count. If the second call was simply an attempt to access the result, you can use myAssetReference.Asset . If the second call was an attempt to increase the reference count, you must call directly into addressables, with Addressables.LoadAssetAsync(myAssetReference) If there are any issues during the excecution of these operations, an Exception is generated and returned in the operations OperationException . That exception is also logged as an error by default. If you would like to see the exceptions when they happen, process them, and choose how to handle them, see ResourceManager.ExceptionHandler . Code Sample IEnumerator LoadGameObjectAndMaterial() { //Load a GameObject AsyncOperationHandle<GameObject> goHandle = Addressables.LoadAssetAsync<GameObject>(\"gameObjectKey\"); yield return goHandle; if(goHandle.Status == AsyncOperationStatus.Succeeded) { GameObject obj = goHandle.Result; //etc... } //Load a Material AsyncOperationHandle<IList<IResourceLocation>> locationHandle = Addressables.LoadResourceLocationsAsync(\"materialKey\"); yield return locationHandle; AsyncOperationHandle<Material> matHandle = Addressables.LoadAssetAsync<Material>(locationHandle.Result[0]); yield return matHandle; if (matHandle.Status == AsyncOperationStatus.Succeeded) { Material mat = matHandle.Result; //etc... } //Use this only when the objects are no longer needed Addressables.Release(goHandle); Addressables.Release(matHandle); } You can use this pattern to load any number of supported runtime types with Addressables. The benefit loading and caching ResourceLocations is purely a performance consideration. If you pass in a key, which is the most common use of this API, Addressables needs to iterate through its ResourceLocators to find the corresponding ResourceLocation. If you directly pass in an IResourceLocation , this step is skipped. Additionally, the Addressables loading APIs benefit from information found in Memory management . Pitfalls Loading a GameObject through Addressables and then instantiating it through the standard Object.Instantiate(...) method can have potentially disastrous results. When loading the asset, only the load operation contains any knowledge of a reference count. If you release this operation handle prior to destroying your GameObject instance, all the data (materials, textures, etc.) is unloaded out from underneath the object when the AssetBundle is unloaded. Addressables.LoadAssetsAsync static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(object key, Action<TObject> callback) static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(object key, Action<TObject> callback, bool releaseDependenciesOnFailure) static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IEnumerable keys, Action<TObject> callback, MergeMode mode) static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(IEnumerable keys, Action<TObject> callback, MergeMode mode, bool releaseDependenciesOnFailure) static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>((IList<IResourceLocation> locations, Action<TObject> callback)) static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>((IList<IResourceLocation> locations, Action<TObject> callback, bool releaseDependenciesOnFailure)) Returns AsyncOperationHandle<IList<TObject>> - The operation handle for a list of requested assets. Description Addressables.LoadAssetsAsync uses the keys of multiple Addressable objects or direct ResourceLocations to load an Addressable asset of a specified type. You can access the loaded asset through the Result property of the AsyncOperationHandle returned by the function. This API does the following: 1) Gathers all dependencies for the given key or resource location. The key version of the API incurs an additional step to lookup the first IResourceLocation that matches the provided key. 2) Downloads any remote AssetBundles that are required. 3) Loads the AssetBundles into memory. 4) Populates the Result property with the requested objects that successfully loaded or null. Just a quick note about step 4: Whether the Result is populated with successful objects or null is dependant on the use of the bool releaseDependenciesOnFailure parameter provided. If you pass true into the parameter, the Result property is populated with null if any of the requested objects fail to load. Passing false into this parameter populates the Result with any objects that were successfully loaded, even if some failed. If this parameter is not specified then the default value true is used. Another useful parameter that can be used with LoadAssetsAsync is the MergeMode parameter. The result of your load operation can change based on what's passed in. Addressables.LoadAssetsAsync is also useful when used in conjunction with the Addressable label feature. If a label is passed in as the key, Addressables.LoadAssetsAsync loads every asset marked with that label. Similar to the single load APIs, you must properly manage and release the AsyncOperationHandle that these calls return when they are no longer needed. This ensures that AssetBundles do not remain loaded in memory unnecessarily. Also, if there are multiple requests for the same assets, then the reference count for the underlying internal operation increases and the cached load operation is used. This means that all newly created handles need to ensure they are properly released in order to have the AssetBundles unload. The callback parameter is called individually for each asset loaded by the operation. Given that the load operation are asynchronous the order of execution is not guaranteed. Passing in a list of keys \"key1\", \"key2\", \"key3\" does not determine the order that the callback operates on each of these loaded assets. MergeMode.None - Takes the results from the first key. MergeMode.UseFirst - Takes the results from the first key. MergeMode.Union - Takes results of each key and collects items that matched any key. MergeMode.Intersection - Takes results of each key, and collects items that matched every key. If there are any issues during the excecution of these operations, an Exception is generated and returned in the operations OperationException . That exception is also logged as an error by default. If you would like to see the exceptions when they happen, process them, and choose how to handle them, see ResourceManager.ExceptionHandler . Code Sample IEnumerator LoadAllLocations(List<IResourceLocation> locations) { //Will load all assets for the provided IResourceLocations AsyncOperationHandle<IList<GameObject>> loadWithIResourceLocations = Addressables.LoadAssetsAsync<GameObject>(locations, obj => { //Gets called for every loaded asset Debug.Log(obj.name); }); yield return loadWithIResourceLocations; IList<GameObject> loadWithLocationsResult = loadWithIResourceLocations.Result; //Will load all assets for the provided IResourceLocations //With false passed in as the last parameter the Result will be populated with //objects that could be successfully loaded, even if others could not. AsyncOperationHandle<IList<GameObject>> doNotReleaseOnFailWithIResourceLocations = Addressables.LoadAssetsAsync<GameObject>(locations, obj => { //Gets called for every loaded asset Debug.Log(obj.name); }, false); yield return doNotReleaseOnFailWithIResourceLocations; IList<GameObject> multipleKeyResult = doNotReleaseOnFailWithIResourceLocations.Result; //Use this only when the objects are no longer needed Addressables.Release(loadWithIResourceLocations); Addressables.Release(doNotReleaseOnFailWithIResourceLocations); } IEnumerator LoadAllAssetsByKey() { //Will load all objects that match the given key. //If this key is an Addressable label, it will load all assets marked with that label AsyncOperationHandle<IList<GameObject>> loadWithSingleKeyHandle = Addressables.LoadAssetsAsync<GameObject>(\"objectKey\", obj => { //Gets called for every loaded asset Debug.Log(obj.name); }); yield return loadWithSingleKeyHandle; IList<GameObject> singleKeyResult = loadWithSingleKeyHandle.Result; //Loads all assets that match the list of keys. //With no MergeMode parameter specified, the Result will be that of the first key. AsyncOperationHandle<IList<GameObject>> loadWithMultipleKeys = Addressables.LoadAssetsAsync<GameObject>(new string[] { \"key1\", \"key2\" }, obj => { //Gets called for every loaded asset Debug.Log(obj.name); }); yield return loadWithMultipleKeys; IList<GameObject> multipleKeyResult1 = loadWithMultipleKeys.Result; //This will load the assets that match the given keys and populate the Result //with only objects that match both of the provided keys AsyncOperationHandle<IList<GameObject>> intersectionWithMultipleKeys = Addressables.LoadAssetsAsync<GameObject>(new string[] { \"key1\", \"key2\" }, obj => { //Gets called for every loaded asset Debug.Log(obj.name); }, Addressables.MergeMode.Intersection); yield return intersectionWithMultipleKeys; IList<GameObject> multipleKeyResult2 = intersectionWithMultipleKeys.Result; //This will load all objects that match either of the provided keys since we passed in //MergeMode.Union. It will also populate any successfully loaded objects into the //Result property even if others fail because of the final parameter being false. AsyncOperationHandle<IList<GameObject>> unionWithMultipleKeysDoNotRelease = Addressables.LoadAssetsAsync<GameObject>(new string[] { \"key1\", \"key2\" }, obj => { //Gets called for every loaded asset Debug.Log(obj.name); }, Addressables.MergeMode.Union, false); yield return unionWithMultipleKeysDoNotRelease; IList<GameObject> multipleKeyResult3 = unionWithMultipleKeysDoNotRelease.Result; //Use this only when the objects are no longer needed Addressables.Release(loadWithSingleKeyHandle); Addressables.Release(loadWithMultipleKeys); Addressables.Release(intersectionWithMultipleKeys); Addressables.Release(unionWithMultipleKeysDoNotRelease); } Pitfalls Loading a GameObject through Addressables and then instantiating it through the standard Object.Instantiate(...) method can have potentially disastrous results. When loading the asset, only the load operation contains any knowledge of a reference count. If you release this operation handle prior to destroying your GameObject instance, all the data (materials, textures, etc.) is unloaded out from underneath the object when the AssetBundle is unloaded. When loading with a list of keys, be sure to pass it in as an IList<object> even if all the keys are strings. Because of the method overloads and casting, passing in a list that isn't typed to object uses the static AsyncOperationHandle<IList<TObject>> LoadAssetsAsync<TObject>(object key, Action<TObject> callback) overload. Because of the asynchronous nature of loading, the order of objects in the Result is done in no certain order. Should you need to coordinate the key of an object and its result, you need to correlate those manually. Example IEnumerator LoadAndStoreResult() { List<GameObject> associationDoesNotMatter = new List<GameObject>(); AsyncOperationHandle<IList<GameObject>> handle = Addressables.LoadAssetsAsync<GameObject>(\"label\", obj => associationDoesNotMatter.Add(obj)); yield return handle; } IEnumerator LoadAndAssociateResultWithKey() { AsyncOperationHandle<IList<IResourceLocation>> locations = Addressables.LoadResourceLocationsAsync(\"label\"); yield return locations; Dictionary<string, GameObject> associationDoesMatter = new Dictionary<string, GameObject>(); foreach (IResourceLocation location in locations.Result) { AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>(location); handle.Completed += obj => associationDoesMatter.Add(location.PrimaryKey, obj.Result); yield return handle; } }"
  },
  "manual/LoadResourceLocations.html": {
    "href": "manual/LoadResourceLocations.html",
    "title": "Addressables.LoadResourceLocationsAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.LoadResourceLocationsAsync API static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(object key, Type type = null) static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(IEnumerable keys, MergeMode mode, Type type = null) Returns AsyncOperationHandle<IList<IResourceLocation>> : A list of all IResourceLocations that match the given key and Type combination. This handle needs to be released when it is no longer needed. Description Load a list of IResourceLocations . Addressables.LoadResourceLocationsAsync is used to return either an empty list or a list of valid IResourceLocations that match the given key(s) and Type combination. The Result can contain the IResourceLocation for varying Types if the given Type parameter is null . To note, this operation cannot fail. If no matching IResourceLocations can be found then the Result is an empty list. This makes the API useful for verifying that a key exists without fear of an InvalidKeyException getting thrown. The MergeMode used in LoadResourceLocationsAsync(IEnumerable keys, MergeMode mode, Type type = null) helps to control what is returned in the Result of the operation. MergeMode.None and MergeMode.UseFirst act identically. Either of these options ensures the Result is only populated with the first IResourceLocation it could find that matches the given keys and Type . MergeMode.Union collects every IResourceLocation that matches any of the keys and Type provided and retuns it in the Result . MergeMode.Intersection returns only the IResourceLocations that match every key and Type provided in the Result . It may also be desireable to pre-load IResourceLocations for use later on. When the \"Key\" version of an API static AsyncOperationHandle<IList<IResourceLocation>> LoadResourceLocationsAsync(object key, Type type = null) is used (as opposed to passing the IResourceLocation directly), the Addressable system has to look up the IResourceLocation itself. Pre-loading and then providing the location to an Addressable API can have performance benefits. Code Sample IEnumerator Start() { //Returns any IResourceLocations that are mapped to the key \"AssetKey\" AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(\"AssetKey\"); yield return handle; //... Addressables.Release(handle); } IEnumerator Start() { //Returns any IResourceLocations that match the keys \"level2\" AND \"holiday\" AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(new string[] { \"level2\", \"holiday\" }, Addressables.MergeMode.Intersection); yield return handle; //... Addressables.Release(handle); } IEnumerator Start() { //Returns any IResourceLocations that match the keys \"knight\" OR \"villager\" AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(new string[] { \"knight\", \"villager\" }, Addressables.MergeMode.Union); yield return handle; //... Addressables.Release(handle); } Sub-Objects Sub-Objects are a special case. Locations for Sub-Objects are generated at runtime to keep bloat out of the content catalogs and improve runtime performance, such as entering Play Mode while using the Use Asset Database Playmode script. This has implications when calling LoadResourceLocationsAsync with a Sub-Object key. If the system is not aware of the desired Type then IResourceLocations is generated for each Type of Sub-Object detected. If an AssetReference with a Sub-Object selection is not set, the system generates IResourceLocations for each Type of detected Sub-Object with the Address of the main object. For the following examples lets assume we have an FBX asset marked as Addressable that has a Mesh Sub-Object. When passing a string Key: IEnumerator Start() { AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(\"myFBXObject\"); yield return handle; //This result contains 3 IResourceLocations. One with Type GameObject, one with Type Mesh, and one with Type Material. Since the string Key has no Type information we generate all possible IResourceLocations to match the request. IList<IResourceLocation> result = handle.Result; //... Addressables.Release(handle); } IEnumerator Start() { AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(\"myFBXObject[Mesh]\"); yield return handle; //This result contains 3 IResourceLocations. One with Type GameObject, one with Type Mesh, and one with Type Material. Since the string Key has no Type information we generate all possible IResourceLocations to match the request. IList<IResourceLocation> result = handle.Result; //... Addressables.Release(handle); } IEnumerator Start() { AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(\"myFBXObject[Mesh]\", typeof(Mesh)); yield return handle; //This result contains 1 IResourceLocation. Since the Type parameter has a value passed in we can create the IResourceLocation. IList<IResourceLocation> result = handle.Result; //... Addressables.Release(handle); } When using an AssetReference: //An AssetReference set to point to the Mesh Sub-Object of a FBX asset public AssetReference myFBXMeshReference; IEnumerator Start() { AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(myFBXMeshReference); yield return handle; //This result contains 1 IResourceLocation. Since the AssetReference contains Type information about the Sub-Object, we can generate the appropriate IResourceLocation. IList<IResourceLocation> result = handle.Result; //... Addressables.Release(handle); } //An AssetReference that is not set to point at a Sub-Object public AssetReference myFBXReference; IEnumerator Start() { AsyncOperationHandle<IList<IResourceLocation>> handle = Addressables.LoadResourceLocationsAsync(myFBXReference); yield return handle; //This result contains 3 IResourceLocation. Since the AssetReference Sub-Object is not set we generate all possible IResourceLocations with the detected Sub-Object Types. IList<IResourceLocation> result = handle.Result; //... Addressables.Release(handle); }"
  },
  "manual/LoadSceneAsync.html": {
    "href": "manual/LoadSceneAsync.html",
    "title": "Addressables.LoadSceneAsync | Addressables | 1.17.6-preview",
    "keywords": "Addressables.LoadSceneAsync API AsyncOperationHandle<SceneInstance> LoadSceneAsync(object key, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) AsyncOperationHandle<SceneInstance> LoadSceneAsync(IResourceLocation location, LoadSceneMode loadMode = LoadSceneMode.Single, bool activateOnLoad = true, int priority = 100) Returns AsyncOperationHandle<SceneInstance> : An AsyncOperationHandle for the scene load operation. The result is the loaded SceneInstance . Description Load a scene asynchronously. See the full API documentation of Addressables.LoadSceneAsync . Addressables.LoadSceneAsync uses a key or IResourceLocation to load an Addressable scene. The other parameters, such as loadMode , activateOnLoad , and priority correlate to parameters used by the SceneManager.LoadSceneAsync . More information about priority and activateOnLoad (called allowSceneActivation by AsyncOperation ) can be found in the full API documentation for SceneManagement.SceneManager.LoadSceneAsync , Be aware, if activateOnLoad is set to false , the entire async operation queue is stalled behind the blocked scene load operation. This is not limited to scene load requests. Any asynchronous request is blocked until the scene is allowed to activate. This means yield retruns and callbacks cannot trigger until the queue is unblocked. If multiple scene load operations are started with activateOnLoad=false it can lead to inconsistent behavior. For example, IEnumerator Start() { AsyncOperationHandle<SceneInstance> handle1 = Addressables.LoadSceneAsync(\"level1\", LoadSceneMode.Additive, false); AsyncOperationHandle<SceneInstance> handle2 = Addressables.LoadSceneAsync(\"other\", LoadSceneMode.Additive, false); yield return handle1; //will sometimes trigger, sometimes not yield return handle2; //will never trigger } Whichever of the two loads gets to \"loaded but not activated\" first blocks the queue and fires its completion/yield/task events. In this case, if \"level1\" loads first, its yield return proceeds, but execution is stuck on handle2 forever. If \"other\" loads first, then even though handle2 is done, handle1 cannot finish. Which scene loads first has nothing to do with which one is requested first in code. While Addressables.LoadSceneAsync is asynchronous, it should be noted that the final part of scene loading requires operation on the main thread. This can be blocking. If the loadMode passed in is LoadSceneMode.Single then Resources.UnloadUnusedAssets is called to clear memory. This can cause hitching. Code Sample public IEnumerator Start() { //Simple use case for loading a scene with the key \"level1\" AsyncOperationHandle<SceneInstance> handle = Addressables.LoadSceneAsync(\"level1\"); yield return handle; //.... } IEnumerator Start() { //Not allowing scene activation immediately AsyncOperationHandle<SceneInstance> handle = Addressables.LoadSceneAsync(\"level1\", LoadSceneMode.Additive, false); yield return handle; //... //One way to handle manual scene activation. if (handle.Status == AsyncOperationStatus.Succeeded) yield return handle.Result.ActivateAsync(); //... } DontDestroyOnLoad If a scene is loaded through Addressables and a GameObject is moved out of that loaded scene, know that releasing that scene load handle unloads the underlying AssetBundle and can affect the moved GameObjects . A common use case is marking a GameObject as DontDestroyOnLoad . Since Addressables has no way of knowing an object was moved out of the loaded scene, it is unable to track the moved objects with the underlying reference count on the loaded AssetBundle . Two solutions for this problem are: Make any object you want to mark DontDestroyOnLoad its own Addressable asset and load it independently. Call Addressables.ResourceManager.Acquire on the AsyncOperationHandle<SceneInstance> used to load the scene before unloading the scene. This bumps the reference count and keeps the entire AssetBundle loaded into memory after the scene is unloaded. You are responsible for releasing the AsyncOperationHandle<SceneInstance> after Acquire has been called."
  },
  "manual/MemoryManagement.html": {
    "href": "manual/MemoryManagement.html",
    "title": "Memory management | Addressables | 1.17.6-preview",
    "keywords": "Memory management Mirroring load and unload When working with Addressable Assets, the primary way to ensure proper memory management is to mirror your load and unload calls correctly. How you do so depends on your Asset types and load methods. In all cases, however, the release method can either take the loaded Asset, or an operation handle returned by the load. For example, during Scene creation (described below) the load returns a AsyncOperationHandle<SceneInstance> , which you can release via this returned handle, or by keeping up with the handle.Result (in this case, a SceneInstance ). Asset loading To load an Asset, use Addressables.LoadAssetAsync (single asset) or Addressables.LoadAssetsAsync (multiple assets) . Note : LoadAssetAsync is intended for use with keys that map to single entries. If you provide a key that matches multiple entries (such as a widely used label) the method will load the first match it finds to the given key. This is not deterministic as it can be affected by build order. This loads the Asset into memory without instantiating it. Every time the load call executes, it adds one to the ref-count for each Asset loaded. If you call LoadAssetAsync three times with the same address, you will get three different instances of an AsyncOperationHandle struct back, all referencing the same underlying operation. That operation has a ref-count of three for the corresponding Asset. If the load succeeds, the resulting AsyncOperationHandle struct contains the Asset in the .Result property. You can use the loaded Asset to instantiate using Unity's built-in instantiation methods, which does not increment the Addressables ref-count. To unload the Asset, use the Addressables.Release method, which decrements the ref-count. When a given Asset's ref-count is zero, that Asset is ready to be unloaded, and decrements the ref-count of any dependencies. Note : The Asset may or may not be unloaded immediately, contingent on existing dependencies. For more information, read the section on when memory is cleared . Scene loading To load a Scene, use Addressables.LoadSceneAsync . You can use this method to load a Scene in Single mode, which closes all open Scenes, or in Additive mode (for more information, see documentation on Scene mode loading ). To unload a Scene, use Addressables.UnloadSceneAsync , or open a new Scene in Single mode. You can open a new Scene by either using the Addressables interface, or using the SceneManager.LoadScene or SceneManager.LoadSceneAsync methods. Opening a new Scene closes the current one, properly decrementing the ref-count. GameObject instantiation To load and instantiate a GameObject Asset, use Addressables.InstantiateAsync . This instantiates the Prefab located by the specified location parameter. The Addressables system will load the Prefab and its dependencies, incrementing the ref-count of all associated Assets. Calling InstantiateAsync three times on the same address results in all dependent assets having a ref-count of three. Unlike calling LoadAssetAsync three times, however, each InstantiateAsync call returns an AsyncOperationHandle pointing to a unique operation. This is because the result of each InstantiateAsync is a unique instance. You will need to individually release each returned AsyncOperationHandle or GameObject instance. Another distinction between InstantiateAsync and other load calls is the optional trackHandle parameter. When set to false , you must keep the AsyncOperationHandle to use while releasing your instance. This is more efficient, but requires more development effort. To destroy an instantiated GameObject, use Addressables.ReleaseInstance , or close the Scene that contains the instantiated object. This Scene can have been loaded (and thus closed) in Additive or Single mode. This Scene can also have been loaded using either the Addressables or SceneManagement API. As noted above, if you set trackHandle to false , you can only call Addressables.ReleaseInstance with the handle, not with the actual GameObject. Note : If you call Addressables.ReleaseInstance on an instance that was not created using the Addressables API, or was created with trackHandle==false , the system detects that and returns false to indicate that the method was unable to release the specified instance. The instance will not be destroyed in this case. Addressables.InstantiateAsync has some associated overhead, so if you need to instantiate the same objects hundreds of times per frame, consider loading via the Addressables API, then instantiating through other methods. In this case, you would call Addressables.LoadAssetAsync , then save the result and call GameObject.Instantiate() for that result. This allows flexibility to call Instantiate in a synchronous way. The downside is that the Addressables system has no knowledge of how many instances you created, which can lead to memory issues if not properly managed. For example, a Prefab referencing a texture would no longer have a valid loaded texture to reference, causing rendering issues (or worse). These sorts of problems can be hard to track down as you may not immediately trigger the memory unload (see section on clearing memory , below). Data loading Interfaces that do not need their AsyncOperationHandle.Result released, will still need the operation itself to be released. Examples of these would be Addressables.LoadResourceLocationsAsync and Addressables.GetDownloadSizeAsync . They load data that you can access until the operation is released. This release should be done via Addressables.Release . Background interactions Operations that do not return anything in the AsyncOperationHandle.Result field have have an optional parameter to automatically release the operation handle on completion. If you have no further need for one of these operation handles after it has completed, set the autoReleaseHandle parameter to true to make sure the operation handle is cleaned up. The scenario where you would want autoReleaseHandle to be false would be if you needed to check the Status of the operation handle after it has completed. Examples of these interfaces are Addressables.DownloadDependenciesAsync and Addressables.UnloadScene . The Addressables Event Viewer Use the Addressables Event Viewer window to monitor the ref-counts of all Addressables system operations. To access the window in the Editor, select Window > Asset Management > Addressables > Event Viewer . Important : In order to view data in the Event Viewer, you must enable the Send Profiler Events setting in your AddressableAssetSettings object's Inspector. Changes to Send Profiler Events will be reflected in the following build. This means that entering play mode when using the Use Existing Build play mode script will use the value set during the most recent build. Alternatively, entering play mode when using the Use Asset Database or Simulate Groups play mode scripts will pick up the current state, as those play mode scripts rebuild the settings data upon entering play mode. The following information is available in the Event Viewer: A white vertical line indicates the frame in which a load request occurred. A blue background indicates that an Asset is currently loaded. The green part of the graph indicates an Asset's current ref-count. Note that the Event Viewer is only concerned with ref-counts, not memory consumption (see section on clearing memory , below, for more information). Listed under the Assets column, you will see a row for each of the following, per frame: FPS: The frames per second count. MonoHeap: The amount of RAM in use. Event Counts: The total number of events in a frame. Instantiation Counts: The total number of calls to Addressables.InstantiateAsync on a frame. Asset requests: Displays the reference count on an operation over time. If the Asset request has any dependencies, a triangle appears that you can click on to view the children's request operations. You can click the left and right arrows in order to step through the frames one by one, or click Current to jump to the latest frame. Press the + button to expand a row for more details. The information displayed in the Event Viewer is related to the build script you use to create Play mode data. When using the Event Viewer, avoid the Use Asset Database built script because it does not account for any shared dependencies among the Assets. Use the Simulate Groups script or the Use Existing Build script instead, but the latter is better suited for the Event Viewer because it gives a more accurate monitoring of the ref-counts. Connecting the Event Viewer to a standalone player To connect the Event Viewer to a standalone player, go into the build menu, select the platform you wish to use, and ensure that Development Build and Autoconnect Profiler are both enabled. Next, open the Unity Profiler by selecting Window > Analysis > Profiler and select the platform you wish to build for on the top toolbar. Finally, select Build and Run in the Build Settings window and the Event Viewer will automatically connect to and display events for the standalone player selected. When is memory cleared? An Asset no longer being referenced (indicated by the end of a blue section in the profiler) does not necessarily mean that Asset was unloaded. A common applicable scenario involves multiple Assets in an AssetBundle . For example: You have three Assets ( tree , tank , and cow ) in an AssetBundle ( stuff ). When tree loads, the profiler displays a single ref-count for tree , and one for stuff . Later, when tank loads, the profiler displays a single ref-count for both tree and tank , and two ref-counts for the stuff AssetBundle. If you release tree , it's ref-count becomes zero, and the blue bar goes away. In this example, the tree asset is not actually unloaded at this point. You can load an AssetBundle, or its partial contents, but you cannot partially unload an AssetBundle. No asset in stuff unloads until the AssetBundle itself is completely unloaded. The exception to this rule is the engine interface Resources.UnloadUnusedAssets . Executing this method in the above scenario causes tree to unload. Because the Addressables system cannot be aware of these events, the profiler graph only reflects the Addressables ref-counts (not exactly what memory holds). Note that if you choose to use Resources.UnloadUnusedAssets , it is a very slow operation, and should only be called on a screen that won't show any hitches (such as a loading screen). Delaying Unload In addition to ensuring items are cleared from memory quickly enough (as discussed above), it's important to ensure items are not churning in and out of memory too often. Specifically, loading an item, releasing it, then quickly reloading it. If it is the only item in a bundle, or at least the last released item, then we will unload the AssetBundle the moment the release comes through. This means there will be a full unload, and then an immediate reload. A common example of this is with shared dependencies. For example, say you have two materials, boat and plane that share a texture, cammo , which has been pulled into its own AssetBundle. Level 1 uses boat and level 2 uses plane . As you exit level 1 you release the boat , and immediately load plane . During the release, we will unload texture cammo . Then the subsequent load will immediately reload it. For this specific example, the easiest solution is to build a wrapper around Addressables that delays Release calls. That works here because it's known \"release and reload\" are likely to happen in a very short timeframe (level transitions). Depending on your scenario, the solution may need to be more or less complex. AssetBundle Memory Overhead When deciding how to organize your Addressable groups and AssetBundles, you may want to consider the runtime memory usage of each AssetBundle. Many small AssetBundles can give greater granularity for unloading, but can come at the cost of some runtime memory overhead. This section describes the various types of AssetBundle memory overhead. Serialized File Overhead When Unity loads an AssetBundle, it allocates an internal buffer for each serialized file in the AssetBundle. This buffer persists for the lifetime of the AssetBundle. A non-scene AssetBundle contains one serialized file, but a scene AssetBundle can contain up to two serialized files for each scene in the bundle. The buffer sizes are optimized per platform. Switch, Playstation, and Windows RT use 128k buffers. All other platforms use 14k buffers. You can use the Build Layout Report to determine how many serialized files are in an AssetBundle. Each serialized file also contains a TypeTree for each object type within the file. The TypeTree describes the data layout of each object type and allows you to load objects that are deserialized slightly differently from how they were serialized. All the TypeTrees are loaded when the AssetBundle is loaded and held in memory for the lifetime of the AssetBundle. The memory overhead associated with TypeTrees scales with the number of unique types in the serialized file and the complexity of those types. Although you can choose to ship AssetBundles without TypeTrees, be aware that even engine version patches can slightly change the serialization format and could result in undefined behavior when you use a newer runtime to load assets serialized with an older format; Unity recommends always shipping AssetBundles with TypeTree information, which is the default behavior. When you put objects of the same type in more than one AssetBundle, the type information for those objects is duplicated in the TypeTree of each AssetBundle. This duplication of type information is more noticeable when you use many small AssetBundles. You can test the impact that TypeTrees have on the size of your AssetBundles by building them with and without TypeTrees disabled and comparing the sizes. If after measuring, you find the duplicate TypeTree memory overhead to be unacceptable, you can avoid it by packing your objects of the same types in the same AssetBundles. AssetBundle Object The AssetBundle object itself has two main sources of runtime memory overhead: the table of contents and the preload table. While the size of an AssetBundle on disk is not the same as its size at runtime, you can use the disk size to approximate the memory overhead. This information is located in the Build Layout Report . The table of contents is a map within the bundle that allows you to look up each explicitly included asset by name. It scales linearly with the number of assets and the length of the string names by which they are mapped. The preload table is a list of all the objects that a loadable asset references. This data is needed so Unity can load all those referenced objects when you load an asset from the AssetBundle. For example, a prefab would have a preload entry for each component as well as any other assets it may reference (materials, textures, etc). Each preload entry is 64 bits and can reference objects in other AssetBundles. As an example, consider a situation in which you are adding two Assets to an AssetBundle ( PrefabA and PrefabB ) and both of these prefabs reference a third prefab ( PrefabC ), which is large and contains several components and references to other assets. This AssetBundle has two preload tables, one for PrefabA and one for PrefabB . Those tables contain entries for all the objects of their respective prefab, but also entries for all the objects in PrefabC and any objects referenced by PrefabC . Thus the information required to load PrefabC ends up duplicated in both PrefabA and PrefabB . This will happen whether or not PrefabC is explicitly added to an AssetBundle. Depending on how you organize your assets, the preload tables in AssetBundles could become quite large and contain many duplicate entries. This is especially true if you have several loadable assets that all reference a complex asset, such as PrefabC in the situation above. If you determine that the memory overhead from the preload table is a problem, you can structure your loadable assets so that they have fewer complex loading dependencies. AssetBundle dependencies Loading an Addressable Asset loads all the AssetBundle dependencies and keeps them loaded until you call Addressables.Release on the handle returned from the loading method. AssetBundle dependencies are created when an asset in one AssetBundle references an asset in another AssetBundle. An example of this is a material referencing a texture. The dependencies of all these AssetBundles can be thought of as a dependency graph. During the catalog generation stage of the build process, Addressables walks this graph to calculate all the AssetBundles that must be loaded for each Addressable Asset. Because dependencies are calculated at the AssetBundle level, all Addressable Assets within a single AssetBundle have the same dependencies. Adding an Addressable Asset that has an external reference (references an object in another AssetBundle) to an AssetBundle adds that AssetBundle as a dependency for all the other Addressable Assets in the AssetBundle. For Example: BundleA contains Addressable Assets RootAsset1 and RootAsset2 . RootAsset2 references DependencyAsset3 , which is contained in BundleB . Even though RootAsset1 has no reference to BundleB , BundleB is still a dependency of RootAsset1 because RootAsset1 is in BundleA , which has a reference on BundleB . Prior to 1.13.0, the dependency graph was not as thorough as it is now. In the example above, RootAsset1 would not have had a dependency on BundleB . This previous behavior resulted in references breaking when an AssetBundle being referenced by another AssetBundle was unloaded and reloaded. This fix may result in additional data remaining in memory if the dependency graph is complex enough. Duplicate dependencies When exploring memory management and dependency graphs, it's important to discuss duplicated content. There are two mechanisms by which an asset can be built into an AssetBundle: explicit and implicit. If you mark an asset as Addressable, it is explicitly put into an AssetBundle. That is the only AssetBundle it is in. Example: A material has a direct dependency on a texture, and both assets are marked as Addressable in separate AssetBundles BundleM and BundleT respectively. BundleT contains the texture. BundleM contains the material and lists BundleT as a dependency. If any dependencies are not explicitly included, then they are implicitly pulled in. Example: A material has a direct dependency on a texture, and only the material is marked as Addressable in BundleM . During build, the texture, because it is not explicitly included elsewhere, is pulled into BundleM when the material is. This implicit dependency inclusion can lead to duplication. Example: Two materials, matA and matB, are Addressable and both have direct dependencies on the same texture. If matA and matB are built into the same AssetBundle, then the texture is pulled implicitly in once. If matA and matB are built into separate AssetBundles, then the texture is pulled implicitly into each of those AssetBundles. At runtime, the engine has no record that these textures came from the same source asset, and are each loaded as they are needed by their respective materials. SpriteAtlas dependencies SpriteAtlases complicate the dependency calculation a bit, and merit a more thorough set of examples. Addressable Sprite Example 1: Three textures exist and are marked as Addressable in three separate groups. Each texture builds to about 500KB. During the build, they are built into three separate AssetBundles, each AssetBundle only containing the given sprite meta data and texture. Each AssetBundle is about 500KB and none of these AssetBundles have dependencies. Addressable Sprite Example 2: The three textures in Example 1 are put into a SpriteAtlas. That atlas is not Addressable. One of the AssetBundles generated contains that atlas texture and is about 1500KB. The other two AssetBundles only contain Sprite metadata (a few KB), and list the atlas AssetBundle as a dependency. Which AssetBundle contains the texture is deterministic in that it is the same through rebuilds, but is not something that can be set by the user. This is the key portion that goes against the standard duplication of dependencies. The sprites are dependent on the SpriteAtlas texture to load, and yet that texture is not built into all three AssetBundles, but is instead built only into one. Addressable Sprite Example 3: The SpriteAtlas from Example 2 is marked as Addressable in its own AssetBundle. At this point there are four AssetBundles created. If you are using a 2020.x or newer version of Unity, this builds as you would expect. The three AssetBundles with the sprites are each only a few KB and have a dependency on this fourth SpriteAtlas AssetBundle, which is be about 1500KB. If you are using 2019.x or older, the texture itself may end up elsewhere. The three sprite AssetBundles still depend on the SpriteAtlas AssetBundle. However, the SpriteAtlas AssetBundle may only contain meta data, and the texture may be in one of the other sprite AssetBundles. Addressable Prefab With Sprite Dependency Example 1: Instead of three Addressable textures, there are three Addressable sprite prefabs. Each prefab depends on its own sprite (about 500KB). Building the three prefabs separately results, as expected, in three AssetBundles of about 500KB each. Addressable Prefab With Sprite Dependency Example 2 Taking the prefabs and textures from the previous example, all three textures are added to a SpriteAtlas, and that atlas is not marked as Addressable. In this scenario, the SpriteAtlas texture is duplicated. All three AssetBundles are approximately 1500KB. This is expected based on the general rules about duplication of dependencies, but goes against the behavior seen in \"Addressable Sprite Example 2\". Addressable Prefab With Sprite Dependency Example 3 Taking the prefabs, textures, and SpriteAtlas form the above example, the SpriteAtlas is also marked as Addressable. Conforming to the rules of explicit inclusion, the SpriteAtlas texture is included only in the AssetBundle containing the SpriteAtlas. The AssetBundles with prefabs reference this fourth AssetBundle as a dependency."
  },
  "manual/SynchronousAddressables.html": {
    "href": "manual/SynchronousAddressables.html",
    "title": "Synchronous Workflow | Addressables | 1.17.6-preview",
    "keywords": "Synchronous Workflow Synchronous Addressables APIs help to more closely mirror Unity asset loading workflows. AsyncOperationHandles now have a method called WaitForCompletion() that force the async operation to complete and return the Result of the operation. API TObject WaitForCompletion() Result The result of WaitForCompletion is the Result of the async operation it is called on. If the operation fails, this returns default(TObject) . It is possible to get a default(TObject) for a result when the operation doesn't fail. Async operations that auto release their AsyncOperationHandles on completion are such cases. Addressables.InitializeAsync() and any API with a autoReleaseHandle parameter set to true will return default(TObject) even though the operations themselves succeeded. Performance It is worth noting that calling WaitForCompletion may have performance implications on your runtime when compared to Resources.Load or Instantiate calls directly. If your AssetBundle is local or has been previously downloaded and cached, these performance hits are likely to be negligible. However, this may not be the case for your individual project setup. All currently active Asset Load operations are completed when WaitForCompletion is called on any Asset Load operation, due to how Async operations are handled in the Engine. To avoid unexpected stalls, use WaitForCompletion when the current operation count is known, and the intention is for all active operations to complete synchronously. When using WaitForCompletion , there are performance implications. When using 2021.2.0 or newer, these are minimal. Using an older version can result in delays that scale with the number of Engine Asset load calls that are loading when WaitForCompletion is called. It is not recommended that you call WaitForCompletion on an operation that is going to fetch and download a remote AssetBundle . Though, it is possible if that fits your specific situation. Code Sample void Start() { //Basic use case of forcing a synchronous load of a GameObject var op = Addressables.LoadAssetAsync<GameObject>(\"myGameObjectKey\"); GameObject go = op.WaitForCompletion(); //Do work... Addressables.Release(op); }"
  },
  "manual/TableOfContents.html": {
    "href": "manual/TableOfContents.html",
    "title": "| Addressables | 1.17.6-preview",
    "keywords": "Unity Addressable Asset system Addressable Assets overview Getting started Addressable Assets development cycle Content update workflow Addressable Assets profiles Synchronous Addressables Asset Hosting Services Addressable Asset System with Cloud Content Delivery Memory management Async operation handling Custom operations Upgrading to the Addressables system Diagnostic Tools FAQ Expanded API documentation BuildPlayerContent DownloadDependenciesAsync ExceptionHandler InitializeAsync InstantiateAsync LoadContentCatalogAsync LoadingAddressableAssets LoadResourceLocationsAsync LoadSceneAsync TransformInternalId UpdateCatalogs"
  },
  "manual/TransformInternalId.html": {
    "href": "manual/TransformInternalId.html",
    "title": "TransformInternalId | Addressables | 1.17.6-preview",
    "keywords": "TransformInternalId Returns string A transformation of a given location to a potentially different location used at runtime. Description string Addressables.ResourceManager.TransformInternalId(IResourceLocation) is a function that Addressables uses when evaluating internal IDs. You can also manually pass in an IResourceLocation and return an ID based on a transformation function you specify. You can specify the transformation used by the ResourceManager by assigning a Func<IResourceLocation, string> to Addressables.ResourceManager.InternalIdTransformFunc . If no InternalIdTransformFunc is available, then the IResourceLocation.InternalId is returned. IResourceLocation.InternalId is the default location assigned to an IResourceLocation at build time to locate an asset. Using TransformInternalId grants a fair amount of flexability, especially in regards to remote hosting. Given a single IResourceLocation, you can transform the ID to point towards a server specified at runtime. This is particularly useful if your server IP address changes or to point at different servers for variant purposes. If Addressables.ResourceManager.InternalIdTransformFunc is not assigned to or is assigned null , then the IResourceLocation.InternalId is used by ResourceManager without passing any transformation. You do not need to call TransformInternalId manually in order for ResourceManager to use it. See ResourceManager ) for its full API documentation. Code Sample void Start() { Addressables.ResourceManager.InternalIdTransformFunc = TransformFunc; } string TransformFunc(IResourceLocation location) { //Implement a method that gets the base url for a given location string baseUrl = GetBaseURL(location); //Get the url you want to use to point to your current server string currentUrlToUse = GetCurrentURL(); return location.InternalId.Replace(baseUrl, currentUrlToUse); } In the above code sample, GetBaseURL and GetCurrentURL can be any solution you find appropriate for your project; these are not methods implemented in Addressables. The former can be your solution for acquiring the IP/url that was used at build time in the project and will be part of the IResourceLocation.InternalId . The latter can be your solution to get a server that points to your new server IP/url or specifc variant/themed/scaled content. void Start() { Addressables.ResourceManager.InternalIdTransformFunc = TransformFunc; } string TransformFunc(IResourceLocation location) { if(location.PrimaryKey.Contains(\"background\") && MyQualityCheck.Resolution == Res.Low) return location.InternalId.Replace(\"background\", \"bkg_low\"); return irl.InternalId; } This example shows how you could use information provided from the IResourceLocation among other settings to transform the IResourceLocation.InternalId . These are, of course, only a basic examples of the possibilities provided by assigning a custom implementation to Addressables.ResourceManager.InternalIdTransformFunc . Pitfalls If your first loads point to the wrong server, ensure that you assign Addressables.ResourceManager.InternalIdTransformFunc to your desired transform function prior to initiating your operation."
  },
  "manual/UpdateCatalogs.html": {
    "href": "manual/UpdateCatalogs.html",
    "title": "Addressables.UpdateCatalogs | Addressables | 1.17.6-preview",
    "keywords": "Addressables.UpdateCatalogs API static AsyncOperationHandle<List<IResourceLocator>> UpdateCatalogs(IEnumerable<string> catalogs = null, bool autoReleaseHandle = true) Returns AsyncOperationHandle<List<IResourceLocator>> : A list of the IResourceLocators loaded from the updated catalogs. Like with the LoadContentCatalogAsync API, no further action is needed to use the new content catalogs. The handle can be safely released after completion. Description Addressables.UpdateCatalogs is used to update the content catalog at runtime. When UpdateCatalogs is called, all Addressables requests, such as asset loading and instantiation, are blocked until the UpdateCatalogs operation is complete. There is an option on the AddressableAssetSettings object called \"Unique Bundle IDs\" which forces unique AssetBundle IDs. If enabled, this option may lead to more AssetBundles getting rebuilt during build time but makes updating content catalogs safer at runtime. \"Unique Bundle IDs\" creates more complex internal IDs for the AssetBundles , which prevents internal ID collisions at load time. The option is located on the AddressableAssetSettings object (inside Assets/AddressableAssetsData/ by default) under the General section. Related API The list of content catalogs with an available update can be aquired through Addressables.CheckForCatalogUpdates . If no catalog list is passed in, CheckForCatalogUpdates is called automatically. CheckForCatalogUpdates iterates through each ResourceLocator currently being used by Addressables and return a list of strings that correlate to the content catalog IDs that have an available update. In order for a Catalog to be discoverable as updated. The AsyncOperationHandle used to load the original Catalog must first be released. It is safe to release the AsyncOperationHandle from Addressables.CheckForCatalogUpdates after completion, or let it automatically relase with the autoReleaseHandle parameter. If you intend to use the Result of CheckForCatalogUpdates then store it as part of the Completed operation (see Code Sample below). Code Sample Check for catalog update prior to update operation: IEnumerator UpdateCatalogs() { List<string> catalogsToUpdate = new List<string>(); AsyncOperationHandle<List<string>> checkForUpdateHandle = Addressables.CheckForCatalogUpdates(); checkForUpdateHandle.Completed += op => { catalogsToUpdate.AddRange(op.Result); }; yield return checkForUpdateHandle; if (catalogsToUpdate.Count > 0) { AsyncOperationHandle<List<IResourceLocator>> updateHandle = Addressables.UpdateCatalogs(catalogsToUpdate); yield return updateHandle; } } Allow Addressables to handle checking for catalog updates automatically: IEnumerator UpdateCatalogs() { AsyncOperationHandle<List<IResourceLocator>> updateHandle = Addressables.UpdateCatalogs(); yield return updateHandle; }"
  }
}