<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-5V25JL6');</script>
    <script type="text/javascript">thisPackageMetaData = { name: "com.unity.entities", version: "0.17.0-preview.18", displayTitle:"Entities 0.17.0-preview.18", lang: "en" };</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>Conversion for LiveLink | Entities | 0.17.0-preview.18 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Conversion for LiveLink | Entities | 0.17.0-preview.18 ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/version-switcher.css">
    <link rel="stylesheet" href="../styles/language-switcher.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="unity:packageTitle" content="Entities | 0.17.0-preview.18">
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10" id="main_content">
          <div id="breadcrumb_placeholder"></div>
            <article class="content wrap" id="_content" data-uid="conversion-livelink">
<h1 id="conversion-for-livelink">Conversion for LiveLink</h1>

<p>Unity 2020.2 and later support converting GameObject data to Entities in real-time. To enable this feature, toggle on Live Conversion via the menu item <code>DOTS/Live Link Mode/Live Conversion in EditMode</code>. When enabled, all objects in open subscenes are automatically converted to entities in the editor. Any undoable changes to objects in these open subscenes lead to a reconversion of the affected GameObjects in the subscene. The result of this reconversion is then compared to the last known conversion result (the <code>shadow world</code> of the subscene) to generate a patch. This patch is applied to the editor world and sent to any connected LiveLink players.</p>
<h2 id="incremental-conversion">Incremental Conversion</h2>
<p>The key feature that enables editing entity data at scale is <em>incremental conversion</em>: Whenever there is a change to a GameObject, the LiveLink code automatically detects this change and marks the GameObject for reconversion. This ensures that only the data that has actually changed is reconverted. All undoable operations are detected as changes. If an operation is not undoable, it is not detected. Since conversion might run every frame in the editor, it is crucial to ensure that the set of objects to convert is as small as possible. This introduces the difficulty that the result of incrementally converting a subset of the objects in a scene must match a full reconversion of the scene.</p>
<h3 id="dependency-management">Dependency Management</h3>
<p>Generally speaking, changes to a GameObject only trigger a reconversion of that specific GameObject. GameObjects are always converted as a whole, so any change will reconvert the entire GameObject. In some cases, your conversion code might depend on other data. If your conversion code depends on more than just the input object, you need to express these additional dependencies explicitly. These are the dependencies that are currently available:</p>
<ul>
<li>depending on an asset (meaning that the conversion result depends on the contents of an asset),</li>
<li>depending on another GameObject (meaning that the conversion result depends on the state of another GameObject, e.g. the presence of components),</li>
<li>depending on a component on another GameObject (meaning that the conversion result depends on the state of the component data of another GameObject).</li>
</ul>
<p>In the following, we will give an example and an explanation for all types of dependencies.</p>
<h4 id="depending-on-the-content-of-an-asset">Depending on the content of an Asset</h4>
<p>When your conversion code reads the contents of an asset, you need to declare a dependency on the asset itself. This dependency means that the GameObject needs to be converted whenever the asset changes its content. As a concrete example, assume that you have conversion code that makes use of the bounding box around a mesh. This bounding box depends on the contents of a mesh asset. The GameObject thus needs to be reconverted whenever this mesh changes.</p>
<pre><code class="lang-cs" name="conversion">public struct BoundsComponent : IComponentData
{
    public Bounds Bounds;
}

[ConverterVersion(&quot;unity&quot;, 1)]
public class MeshBoundingBoxDependency : MonoBehaviour, IConvertGameObjectToEntity
{
    public Mesh Mesh;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new BoundsComponent {
            Bounds = Mesh.bounds
        });
        // Declare the dependency on the asset. Note the lack of a check for null.
        conversionSystem.DeclareAssetDependency(gameObject, Mesh);
    }
}
</code></pre><p>Note the lack of a check for <code>null</code>: All methods for declaring dependencies correctly handle the case of <code>null</code>, and it is imperative that you do not perform this check yourself. Unity overrides the comparison operator for the <code>UnityEngine.Object</code> type to also equal <code>null</code> when the object has been destroyed. Even though the object might be destroyed, we can still extract identifying data from it. This is crucial for correctly handling dependencies on objects that might be deleted and later restored (e.g. the deletion of an object is undone).</p>
<p>You <em>do not</em> need to declare a dependency if you merely <em>reference</em> an asset. References are stable and can be tracked automatically. For example, if your code is merely storing a reference to a mesh there is no need to declare a dependency:</p>
<pre><code class="lang-cs" name="conversion">public class MeshComponent : IComponentData
{
    public Mesh Mesh;
}

[ConverterVersion(&quot;unity&quot;, 1)]
public class MeshReference : MonoBehaviour, IConvertGameObjectToEntity
{
    public Mesh Mesh;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new MeshComponent {
            Mesh = Mesh
        });
        // No need to declare a dependency here, we&#39;re merely referencing an asset.
    }
}
</code></pre><h4 id="depending-on-another-gameobject">Depending on another GameObject</h4>
<p>Dependencies on another GameObject need to be declared when you depend on general properties of the GameObject, e.g. its name, whether it is enabled, or the presence of components on that GameObject.</p>
<pre><code class="lang-cs" name="conversion">public struct NameComponent : IComponentData {
    public Unity.Collections.FixedString32 Name;
}

[ConverterVersion(&quot;unity&quot;, 1)]
public class NameFromGameObject : MonoBehaviour, IConvertGameObjectToEntity
{
    public GameObject Other;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new NameComponent {
            Name = Other.name
        });
        // Note the lack of a null check
        conversionSystem.DeclareDependency(gameObject, Other);
    }
}
</code></pre><p>Note here that when you depend on the contents of a component on a GameObject you must declare a dependency on that component instead, see below.</p>
<h4 id="depending-on-component-data">Depending on Component data</h4>
<p>Conversion code might also depend on the component data on this or another GameObject. This is expected to be the most common kind of dependency. For example, your conversion code might depend on a <code>MeshFilter</code> that may or may not be stored on another GameObject.</p>
<pre><code class="lang-cs" name="conversion">[ConverterVersion(&quot;unity&quot;, 1)]
public class MeshFromOtherComponent : MonoBehaviour, IConvertGameObjectToEntity
{
    public MeshFilter MeshFilter;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new MeshComponent {
            Mesh = MeshFilter.sharedMesh
        });
        // Note the lack of a null check
        conversionSystem.DeclareDependency(gameObject, MeshFilter);
    }
}
</code></pre><p>Dependencies on Transform components specifically are mandatory: While GameObjects themselves are the smallest unit of conversion, there is code that relies on this dependency information on a component level. <code>Transform</code> components are hierarchical and a change to one transform component actually changes an entire hierarchy. There is a special code path for handling this case specifically, since moving around large hierarchies cannot rely on reconverting the entire hierarchy every frame. Instead, transform data on the converted entities is patched directly and only GameObjects whose conversion result actually depends on the transform data are reconverted (e.g. the conversion result depends on the rotation of the object or the specific position of the object in a scene).</p>
<pre><code class="lang-cs" name="conversion">public struct Offset : IComponentData
{
    public Unity.Mathematics.float3 Value;
}

[ConverterVersion(&quot;unity&quot;, 1)]
public class ReadFromOwnTransform : MonoBehaviour, IConvertGameObjectToEntity
{
    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new Offset {
            Value = transform.position
        });

        // We need to explicitly declare a dependency on the transform data,
        // even when it is on the same object.
        conversionSystem.DeclareDependency(gameObject, transform);
    }
}
</code></pre><p>Dependencies on transform data should be used sparingly since they run the danger of making editing large scenes slow. This is the only case in which you need to declare a reference on a component on the same GameObject.</p>
<p>When you store a reference to a GameObject instead of a component and use that to acquire a reference to a component, you also need to declare a dependency against the GameObject itself:</p>
<pre><code class="lang-cs" name="conversion">[ConverterVersion(&quot;unity&quot;, 1)]
public class ReadFromOtherMeshFilter : MonoBehaviour, IConvertGameObjectToEntity
{
    public GameObject Other;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        if (Other != null) {
            var meshFilter = Other.GetComponent&lt;MeshFilter&gt;();
            dstManager.AddComponentData(entity, new MeshComponent {
                Mesh = meshFilter.sharedMesh
            });

            // In this case, we need a null-check: meshFilter can only be
            // accessed when Other is not null.
            // It would be simpler to expose a reference to a Meshfilter on this
            // MonoBehaviour.
            conversionSystem.DeclareDependency(gameObject, meshFilter);
        }

        // Note the lack of a null-check
        conversionSystem.DeclareDependency(gameObject, Other);
    }
}
</code></pre><h3 id="debugging-incremental-conversion-failures">Debugging Incremental Conversion Failures</h3>
<p>The result of incrementally reconverting a subset of objects in a scene must match the result of a full conversion bit-by-bit. This is a hard requirement. Verifying this requirement is a challenge. To facilitate this, you can use <code>DOTS/Live Link Mode/Debug Incremental Conversion</code>. This will run a full conversion after every incremental conversion and compare the results. If there are any differences between the two conversion results, it will print out a summary of the differences.</p>
<p>The most common source for a mismatch between the two conversions are missing dependencies. When you are missing a dependency, a change to a GameObject or asset will not correctly reconvert all GameObjects whose conversion result depend on that GameObject or asset.</p>
<h2 id="known-issues">Known Issues</h2>
<p>There are known issues around <code>GetPrimaryEntity</code>. As of version 0.17 of the entities package, there is no way to express a dependency on the existence of a GameObject and <code>GetPrimaryEntity</code> does not register such a dependency. Therefore, the following demonstrates how to properly get a reference to another entity:</p>
<pre><code class="lang-cs" name="conversion">public struct EntityReference : IComponentData
{
    public Entity Entity;
}

[ConverterVersion(&quot;unity&quot;, 1)]
public class GetEntityReference : MonoBehaviour, IConvertGameObjectToEntity
{
    public GameObject Other;

    public void Convert(Entity entity, EntityManager dstManager,
        GameObjectConversionSystem conversionSystem)
    {
        dstManager.AddComponentData(entity, new EntityReference {
            Entity = conversionSystem.GetPrimaryEntity(Other)
        });

        // This line is required right now, unfortunately.
        // Note the lack of a null-check.
        conversionSystem.DeclareDependency(gameObject, Other);
    }
}
</code></pre><p>If the dependency registered on the last line is not present, you may run into an invalid conversion state: Specifically, deleting the GameObject referred to by <code>Other</code> and undoing said deletion will not reconvert your GameObject and lead to an invalid Entity reference.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2020 Unity Technologies<br>Generated by <strong>DocFX</strong></span> on Monday, November 2, 2020
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script type="text/javascript" src="../styles/metadata-collector.js"></script>
    <script type="text/javascript" src="../styles/version-switcher.js"></script>
    <script type="text/javascript" src="../styles/language-switcher.js"></script>
  </body>
</html>
