<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-5V25JL6');</script>
    <script type="text/javascript">thisPackageMetaData = { name: "com.unity.entities", version: "0.17.0-preview.18", displayTitle:"Entities 0.17.0-preview.18", lang: "en" };</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>Dynamic buffer components | Entities | 0.17.0-preview.18 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Dynamic buffer components | Entities | 0.17.0-preview.18 ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/version-switcher.css">
    <link rel="stylesheet" href="../styles/language-switcher.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="unity:packageTitle" content="Entities | 0.17.0-preview.18">
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10" id="main_content">
          <div id="breadcrumb_placeholder"></div>
            <article class="content wrap" id="_content" data-uid="ecs-dynamic-buffers">
<h1 id="dynamic-buffer-components">Dynamic buffer components</h1>

<p>Use dynamic buffer components to associate array-like data with an entity. Dynamic buffers are ECS components that can hold a variable number of elements, and automatically resize as necessary. </p>
<p>To create a dynamic buffer, first declare a struct that implements <a class="xref" href="../api/Unity.Entities.IBufferElementData.html">IBufferElementData</a> and defines the elements stored in the buffer. For example, you can use the following struct for a buffer component that stores integers:</p>
<pre><code class="lang-cs" name="declare-element">
public struct IntBufferElement : IBufferElementData
{
    public int Value;
}

</code></pre><p>To associate a dynamic buffer with an entity, add an <a class="xref" href="../api/Unity.Entities.IBufferElementData.html">IBufferElementData</a> component directly to the entity rather than adding the <a class="xref" href="../api/Unity.Entities.DynamicBuffer-1.html">dynamic buffer container</a> itself. </p>
<p>ECS manages the container. For most purposes, you can use a declared <code>IBufferElementData</code> type to treat a dynamic buffer the same as any other ECS component. For example, you can use the <code>IBufferElementData</code> type in <a class="xref" href="../api/Unity.Entities.EntityQuery.html">entity queries</a> as well as when you add or remove the buffer component. However, you must use different functions to access a buffer component and those functions provide the <a class="xref" href="../api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a> instance, which gives an array-like interface to the buffer data.</p>
<p>To specify an “internal capacity&quot; for a dynamic buffer component, use the <a class="xref" href="../api/Unity.Entities.InternalBufferCapacityAttribute.html">InternalBufferCapacity attribute</a>. The internal capacity defines the number of elements the dynamic buffer stores in the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk</a> along with the other components of an entity. If you increase the size of a buffer beyond the internal capacity, the buffer allocates a heap memory block outside the current chunk and moves all existing elements. ECS manages this external buffer memory automatically, and frees the memory when the buffer component is removed. </p>
<div class="NOTE"><h5>Note</h5><p>If the data in a buffer is not dynamic, you can use a <a class="xref" href="../api/Unity.Entities.BlobBuilder.html">blob asset</a> instead of a dynamic buffer. Blob assets can store structured data, including arrays. Multiple entities can share blob assets.</p>
</div>
<h2 id="declaring-buffer-element-types">Declaring buffer element types</h2>
<p>To declare a buffer, declare a struct that defines the type of element that you want to put into the buffer. The struct must implement <a class="xref" href="../api/Unity.Entities.IBufferElementData.html">IBufferElementData</a>, like so:</p>
<pre><code class="lang-cs" name="declare-element-full">
// InternalBufferCapacity specifies how many elements a buffer can have before
// the buffer storage is moved outside the chunk.
[InternalBufferCapacity(8)]
public struct MyBufferElement : IBufferElementData
{
    // Actual value each buffer element will store.
    public int Value;

    // The following implicit conversions are optional, but can be convenient.
    public static implicit operator int(MyBufferElement e)
    {
        return e.Value;
    }

    public static implicit operator MyBufferElement(int e)
    {
        return new MyBufferElement { Value = e };
    }
}

</code></pre><h2 id="adding-buffer-types-to-entities">Adding buffer types to entities</h2>
<p>To add a buffer to an entity, add the <code>IBufferElementData</code> struct that defines the data type of the buffer element, and then add that type directly to an entity or to an <a class="xref" href="../api/Unity.Entities.EntityArchetype.html">archetype</a>:</p>
<h3 id="using-entitymanageraddbuffer">Using EntityManager.AddBuffer()</h3>
<p>For more information, see the documentation on <a class="xref" href="../api/Unity.Entities.EntityManager.AddBuffer.html">EntityManager.AddBuffer()</a>.</p>
<pre><code class="lang-cs" name="declare">
EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity);

</code></pre><h3 id="using-an-archetype">Using an archetype</h3>
<pre><code class="lang-cs" name="declare">
Entity e = EntityManager.CreateEntity(typeof(MyBufferElement));

</code></pre><h3 id="using-the-generateauthoringcomponent-attribute">Using the <code>[GenerateAuthoringComponent]</code> attribute</h3>
<p>You can use <code>[GenerateAuthoringComponent]</code>to generate authoring components for simple IBufferElementData implementations that contain only one field. Setting this attribute allows you add an ECS IBufferElementData component to a GameObject so that you can set the buffer elements in the Editor.  </p>
<p>For example, if you declare the following type, you can add it directly to a GameObject in the Editor:</p>
<pre><code>[GenerateAuthoringComponent]
public struct IntBufferElement: IBufferElementData
{
    public int Value;
}
</code></pre><p>In the background, Unity generates a class named <code>IntBufferElementAuthoring</code> (which inherits from <code>MonoBehaviour</code>), which exposes a public field of <code>List&lt;int&gt;</code> type. When the GameObject containing this generated authoring component is converted into an entity, the list is converted into <code>DynamicBuffer&lt;IntBufferElement&gt;</code>, and then added to the converted entity.</p>
<p>Note the following restrictions:</p>
<ul>
<li>Only one component in a single C# file can have a generated authoring component, and the C# file must not have another MonoBehaviour in it.</li>
<li><code>IBufferElementData</code> authoring components cannot be automatically generated for types that contain more than one field.</li>
<li><code>IBufferElementData</code> authoring components cannot be automatically generated for types that have an explicit layout.</li>
</ul>
<h3 id="using-an-entitycommandbufferxrefunityentitiesentitycommandbuffer">Using an <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.html">EntityCommandBuffer</a></h3>
<p>You can add or set a buffer component when you add commands to an entity command buffer. </p>
<p>Use <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.AddBuffer.html#Unity_Entities_EntityCommandBuffer_AddBuffer__1_Unity_Entities_Entity_">AddBuffer</a> to create a new buffer for the entity, which changes the entity&#39;s archetype. Use <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.SetBuffer.html#Unity_Entities_EntityCommandBuffer_SetBuffer__1_Unity_Entities_Entity_">SetBuffer</a> to wipe out the existing buffer (which must exist) and create a new, empty buffer in its place. Both functions return a <a class="xref" href="../api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a> instance that you can use to populate the new buffer. You can add elements to the buffer immediately, but they are not otherwise accessible until the buffer is added to the entity when the command buffer is executed.</p>
<p>The following job creates a new entity using a command buffer and then adds a dynamic buffer component using <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.AddBuffer.html#Unity_Entities_EntityCommandBuffer_AddBuffer__1_Unity_Entities_Entity_">EntityCommandBuffer.AddBuffer</a>. The job also adds a number of elements to the dynamic buffer. </p>
<pre><code class="lang-cs" name="declare">
using Unity.Entities;
using Unity.Jobs;

public class CreateEntitiesWithBuffers : SystemBase
{
    // A command buffer system executes command buffers in its own OnUpdate
    public EntityCommandBufferSystem CommandBufferSystem;

    protected override void OnCreate()
    {
        // Get the command buffer system
        CommandBufferSystem
            = World.DefaultGameObjectInjectionWorld.GetExistingSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();
    }

    protected override void OnUpdate()
    {
        // The command buffer to record commands,
        // which are executed by the command buffer system later in the frame
        EntityCommandBuffer.ParallelWriter commandBuffer
            = CommandBufferSystem.CreateCommandBuffer().AsParallelWriter();
        //The DataToSpawn component tells us how many entities with buffers to create
        Entities.ForEach((Entity spawnEntity, int entityInQueryIndex, in DataToSpawn data) =&gt;
        {
            for (int e = 0; e &lt; data.EntityCount; e++)
            {
                //Create a new entity for the command buffer
                Entity newEntity = commandBuffer.CreateEntity(entityInQueryIndex);

                //Create the dynamic buffer and add it to the new entity
                DynamicBuffer&lt;MyBufferElement&gt; buffer =
                    commandBuffer.AddBuffer&lt;MyBufferElement&gt;(entityInQueryIndex, newEntity);

                //Reinterpret to plain int buffer
                DynamicBuffer&lt;int&gt; intBuffer = buffer.Reinterpret&lt;int&gt;();

                //Optionally, populate the dynamic buffer
                for (int j = 0; j &lt; data.ElementCount; j++)
                {
                    intBuffer.Add(j);
                }
            }

            //Destroy the DataToSpawn entity since it has done its job
            commandBuffer.DestroyEntity(entityInQueryIndex, spawnEntity);
        }).ScheduleParallel();

        CommandBufferSystem.AddJobHandleForProducer(this.Dependency);
    }
}
</code></pre><div class="NOTE"><h5>Note</h5><p>You are not required to add data to the dynamic buffer immediately. However, you won&#39;t have access to the buffer again until after the entity command buffer you are using is executed.</p>
</div>
<h2 id="accessing-buffers">Accessing buffers</h2>
<p>You can use <a class="xref" href="../api/Unity.Entities.EntityManager.html">EntityManager</a>, <a href="ecs_systems.html">systems</a>, and jobs to access the <a class="xref" href="../api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a> instance in much the same way as you access other component types of entities. </p>
<h3 id="entitymanager">EntityManager</h3>
<p>You can use an instance of the <a class="xref" href="../api/Unity.Entities.EntityManager.html">EntityManager</a> to access a dynamic buffer:</p>
<pre><code class="lang-cs" name="declare">
DynamicBuffer&lt;MyBufferElement&gt; dynamicBuffer
    = EntityManager.GetBuffer&lt;MyBufferElement&gt;(entity);

</code></pre><h3 id="looking-up-buffers-of-another-entity">Looking up buffers of another entity</h3>
<p>When you need to look up the buffer data belonging to another entity in a job, you can pass a <a class="xref" href="../api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a> variable to the job.</p>
<pre><code class="lang-cs" name="declare">
BufferFromEntity&lt;MyBufferElement&gt; lookup = GetBufferFromEntity&lt;MyBufferElement&gt;();
var buffer = lookup[entity];
buffer.Add(17);
buffer.RemoveAt(0);

</code></pre><h3 id="systembase-entitiesforeach">SystemBase Entities.ForEach</h3>
<p>You can access dynamic buffers associated with the entities you process with Entities.ForEach by passing the buffer as one of your lambda function parameters. The following example adds all the values stored in the buffers of type, <code>MyBufferElement</code>:</p>
<pre><code class="lang-cs" name="access-buffer-system">
public class DynamicBufferSystem : SystemBase
{
    protected override void OnUpdate()
    {
        var sum = 0;

        Entities.ForEach((DynamicBuffer&lt;MyBufferElement&gt; buffer) =&gt;
        {
            for(int i = 0; i &lt; buffer.Length; i++)
            {
                sum += buffer[i].Value;
            }
        }).Run();

        Debug.Log(&quot;Sum of all buffers: &quot; + sum);
    }
}

</code></pre><p>Note that we can write directly to the captured <code>sum</code> variable in this example because we execute the code with <code>Run()</code>. If we scheduled the function to run in a job, we could only write to a native container such as NativeArray, even though the result is a single value.</p>
<h3 id="ijobchunk">IJobChunk</h3>
<p>To access an individual buffer in an <code>IJobChunk</code> job, pass the buffer data type to the job and use that to get a <a class="xref" href="../api/Unity.Entities.BufferAccessor-1.html">BufferAccessor</a>. A buffer accessor is an array-like structure that provides access to all of the dynamic buffers in the current chunk. </p>
<p>Like the previous example, the following example adds up the contents of all dynamic buffers that contain elements of type, <code>MyBufferElement</code>. <code>IJobChunk</code> jobs can also run in parallel on each chunk, so in the example, it first stores the intermediate sum for each buffer in a native array and then uses a second job to calculate the final sum. In this case, the intermediate array holds one result for each chunk, rather than one result for each entity.</p>
<pre><code class="lang-cs" name="declare">
public class DynamicBufferJobSystem : SystemBase
{
    private EntityQuery query;

    protected override void OnCreate()
    {
        //Create a query to find all entities with a dynamic buffer
        // containing MyBufferElement
        EntityQueryDesc queryDescription = new EntityQueryDesc();
        queryDescription.All = new[] {ComponentType.ReadOnly&lt;MyBufferElement&gt;()};
        query = GetEntityQuery(queryDescription);
    }

    public struct BuffersInChunks : IJobEntityBatch
    {
        //The data type and safety object
        public BufferTypeHandle&lt;MyBufferElement&gt; BufferTypeHandle;

        //An array to hold the output, intermediate sums
        public NativeArray&lt;int&gt; sums;

        public void Execute(ArchetypeChunk batchInChunk, int batchIndex)
        {
            //A buffer accessor is a list of all the buffers in the chunk
            BufferAccessor&lt;MyBufferElement&gt; buffers
                = batchInChunk.GetBufferAccessor(BufferTypeHandle);

            for (int c = 0; c &lt; batchInChunk.Count; c++)
            {
                //An individual dynamic buffer for a specific entity
                DynamicBuffer&lt;MyBufferElement&gt; buffer = buffers[c];
                for(int i = 0; i &lt; buffer.Length; i++)
                {
                    sums[batchIndex] += buffer[i].Value;
                }
            }
        }
    }

    //Sums the intermediate results into the final total
    public struct SumResult : IJob
    {
        [DeallocateOnJobCompletion] public NativeArray&lt;int&gt; sums;
        public NativeArray&lt;int&gt; result;
        public void Execute()
        {
            for(int i  = 0; i &lt; sums.Length; i++)
            {
                result[0] += sums[i];
            }
        }
    }

    protected override void OnUpdate()
    {
        //Create a native array to hold the intermediate sums
        int chunksInQuery = query.CalculateChunkCount();
        NativeArray&lt;int&gt; intermediateSums
            = new NativeArray&lt;int&gt;(chunksInQuery, Allocator.TempJob);

        //Schedule the first job to add all the buffer elements
        BuffersInChunks bufferJob = new BuffersInChunks();
        bufferJob.BufferTypeHandle = GetBufferTypeHandle&lt;MyBufferElement&gt;();
        bufferJob.sums = intermediateSums;
        this.Dependency = bufferJob.ScheduleParallel(query, 1, this.Dependency);

        //Schedule the second job, which depends on the first
        SumResult finalSumJob = new SumResult();
        finalSumJob.sums = intermediateSums;
        NativeArray&lt;int&gt; finalSum = new NativeArray&lt;int&gt;(1, Allocator.Temp);
        finalSumJob.result = finalSum;
        this.Dependency = finalSumJob.Schedule(this.Dependency);

        this.CompleteDependency();
        Debug.Log(&quot;Sum of all buffers: &quot; + finalSum[0]);
        finalSum.Dispose();
    }
}

</code></pre><h2 id="reinterpreting-buffers">Reinterpreting buffers</h2>
<p>Buffers can be reinterpreted as a type of the same size. The intention is to
allow controlled type-punning and to get rid of the wrapper element types when
they get in the way. To reinterpret, call <a class="xref" href="../api/Unity.Entities.DynamicBuffer-1.Reinterpret.html">Reinterpret&lt;T&gt;</a>:</p>
<pre><code class="lang-cs" name="declare">
DynamicBuffer&lt;int&gt; intBuffer
    = EntityManager.GetBuffer&lt;MyBufferElement&gt;(entity).Reinterpret&lt;int&gt;();

</code></pre><p>The reinterpreted buffer instance retains the safety handle of the original
buffer, and is safe to use. Reinterpreted buffers reference original data, so
modifications to one reinterpreted buffer are immediately reflected in
others.</p>
<p><strong>Note:</strong> The reinterpret function only enforces that the types involved have the same length. For example, you can alias a <code>uint</code> and <code>float</code> buffer without raising an error because both types are 32-bits long. You must make sure that the reinterpretation makes sense logically.</p>
<h2 id="buffer-reference-invalidation">Buffer reference invalidation</h2>
<p>Every <a href="sync_points.html#structural-changes">structural change</a> invalidates all references to dynamic buffers. Structural changes generally cause entities to move from one chunk to another. Small dynamic buffers can reference memory within a chunk (as opposed to from main memory) and therefore, they need to be reacquired after a structural change.</p>
<pre><code class="lang-cs" name="declare">
var entity1 = EntityManager.CreateEntity();
var entity2 = EntityManager.CreateEntity();

DynamicBuffer&lt;MyBufferElement&gt; buffer1
    = EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity1);
// This line causes a structural change and invalidates
// the previously acquired dynamic buffer
DynamicBuffer&lt;MyBufferElement&gt; buffer2
    = EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity1);
// This line will cause an error:
buffer1.Add(17);

</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2020 Unity Technologies<br>Generated by <strong>DocFX</strong></span> on Wednesday, October 28, 2020
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script type="text/javascript" src="../styles/metadata-collector.js"></script>
    <script type="text/javascript" src="../styles/version-switcher.js"></script>
    <script type="text/javascript" src="../styles/language-switcher.js"></script>
  </body>
</html>
