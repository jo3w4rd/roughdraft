<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-5V25JL6');</script>
    <script type="text/javascript">thisPackageMetaData = { name: "com.unity.entities", version: "0.17.0-preview.18", displayTitle:"Entities 0.17.0-preview.18", lang: "en" };</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>Using Entity Batch jobs | Entities | 0.17.0-preview.18 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using Entity Batch jobs | Entities | 0.17.0-preview.18 ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/version-switcher.css">
    <link rel="stylesheet" href="../styles/language-switcher.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="unity:packageTitle" content="Entities | 0.17.0-preview.18">
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10" id="main_content">
          <div id="breadcrumb_placeholder"></div>
            <article class="content wrap" id="_content" data-uid="ecs-ijobentitybatch">
<h1 id="using-entity-batch-jobs">Using Entity Batch jobs</h1>

<p>Implement <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> or <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> inside a system to iterate through your data in batches of entities. </p>
<p>When you schedule an <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> job in the <a class="xref" href="../api/Unity.Entities.SystemBase.OnUpdate.html">OnUpdate</a> function of a system, the system identifies the chunks that should be passed to the job using the entity query you pass to the schedule function. The job invokes your <code>Execute</code> function once for each batch of entities in those chunks. By default, the batch size is a full chunk, but you can set the batch size to be some fraction of a chunk when scheduling the job. No matter the batch size, the entities in a given batch are always stored in the same chunk. In your job’s <code>Execute</code> function, you can iterate over the data inside each batch, entity by entity. </p>
<p>Use  <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> when you need an index value for all entities across the set of batches. Otherwise, <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> is more efficient since it doesn’t need to calculate these indices.</p>
<p>To implement a batch job:</p>
<ol>
<li><p><a href="#write-the-query">Query for data with an EntityQuery</a> to identify the entities that you want to process.</p>
</li>
<li><p><a href="#define-the-job-struct">Define the job struct</a> using either <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a>  or <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a>.</p>
</li>
<li><p><a href="#declare-data">Declare the data your job accesses</a>. On the job structure, include fields for ComponentTypeHandle objects that identify the types of components the job must directly access. Also, specify whether the job reads or writes to those components. You can also include fields that identify data you want to look up for entities that aren’t part of the query, as well as fields for non-entity data.</p>
</li>
<li><p><a href="#write-execute-function">Write the Execute function</a> of the job struct to transform your data. Get the NativeArray instances for the components the job reads or writes and then iterate over the current batch to perform the desired work.</p>
</li>
<li><p><a href="#schedule-the-job">Schedule the job</a> in the system OnUpdate function, passing the entity query identifying the entities to process to the schedule function.</p>
</li>
</ol>
<div class="NOTE"><h5>Note</h5><p>Iterating with <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a>  or <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> is more complicated and requires more code setup than using Entities.ForEach, and should only be used when necessary or more efficient.</p>
</div>
<p>For more information, the <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">ECS samples repository</a> contains a simple HelloCube example that demonstrates how to use IJobEntityBatch.</p>
<div class="NOTE"><h5>Note</h5><p><a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> supersedes <a class="xref" href="chunk_iteration_job.html">IJobChunk</a>. The primary differences are that you can schedule an <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> to iterate over smaller batches of entities than a full chunk and that you use the variant <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> if you need an job-wide index for the entities in each batch. </p>
</div>
<p><a name="write-the-query" id="write-the-query"></a></p>
<h2 id="query-for-data-with-an-entityquery">Query for data with an EntityQuery</h2>
<p>An <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> defines the set of component types that an <a class="xref" href="../api/Unity.Entities.EntityArchetype.html">EntityArchetype</a> must contain for the system to process its associated chunks and entities. An archetype can have additional components, but it must have at least those that the query defines. You can also exclude archetypes that contain specific types of components. </p>
<p>Pass the query that selects the entities your job should process to the schedule method that you use to schedule the job.</p>
<p>See <a class="xref" href="ecs_entity_query.html">Using an EntityQuery to query data</a> for information about defining queries.</p>
<div class="NOTE"><h5>Note</h5><p>Do not include completely optional components in the <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a>. To handle optional components, use the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.Has.html">ArchetypeChunk.Has</a> method inside <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.Execute.html">IJobEntityBatch.Execute</a> to determine whether the current <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk</a> has the optional component or not. Because all entities in the same batch have the same components, you only need to check whether an optional component exists once per batch, not once per entity.</p>
</div>
<p><a name="define-the-job-struct" id="define-the-job-struct"></a></p>
<h2 id="define-the-job-struct">Define the job struct</h2>
<p>A job struct consists of an <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.Execute.html">Execute</a> function that does the work to be performed and fields that declare the data used by the <code>Execute</code> function.</p>
<p>A typical <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> job struct looks like:</p>
<pre><code class="lang-cs" name="typical-struct">public struct UpdateTranslationFromVelocityJob : IJobEntityBatch
{
    public ComponentTypeHandle&lt;VelocityVector&gt; velocityTypeHandle;
    public ComponentTypeHandle&lt;Translation&gt; translationTypeHandle;
    public float DeltaTime;

    [BurstCompile]
    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)
    {
        NativeArray&lt;VelocityVector&gt; velocityVectors =
            batchInChunk.GetNativeArray(velocityTypeHandle);
        NativeArray&lt;Translation&gt; translations =
            batchInChunk.GetNativeArray(translationTypeHandle);

        for(int i = 0; i &lt; batchInChunk.Count; i++)
        {
            float3 translation = translations[i].Value;
            float3 velocity = velocityVectors[i].Value;
            float3 newTranslation = translation + velocity * DeltaTime;

            translations[i] = new Translation() { Value = newTranslation };
        }
    }
}
</code></pre><p>This example accesses the data for two components of an entity, VelocityVector and <a class="xref" href="../api/Unity.Transforms.Translation.html">Translation</a>, and calculates a new translation based on the time elapsed since the last update.</p>
<h3 id="ijobentitybatch-versus-ijobentitybatchwithindex">IJobEntityBatch versus IJobEntityBatchWithIndex</h3>
<p>The only difference between <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> and <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> is that <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> passes an <code>indexOfFirstEntityInQuery</code> parameter when it invokes the Execute function on a batch. This parameter is the index of the first entity in the current batch in the list of all entities selected by the entity query. </p>
<p>Use  <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> when you need an individual index for each entity. For example, if you calculate a unique result for each entity, you could use this index to write each result to a different element of a <a class="xref" href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/Unity.Collections.NativeArray_1.html">native array</a>. If you don’t use the <code>indexOfFirstEntityInQuery</code> value, use <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> instead, to avoid the overhead of calculating the index values.</p>
<div class="NOTE"><h5>Note</h5><p>When you are adding commands to an [EntityCommandBuffer.ParallelWriter] , you can use the <code>batchIndex</code> parameter as the <code>sortKey</code> argument of the command buffer functions. You do not need to use <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> just to get a unique sort key for each entity. The <code>batchIndex</code> parameter available from both job types works for this purpose.</p>
</div>
<p><a name="declare-data" id="declare-data"></a></p>
<h3 id="declare-the-data-your-job-accesses">Declare the data your job accesses</h3>
<p>The fields in your job struct declare the data available to your Execute function. These fields fall into four general categories:</p>
<ul>
<li><p><a class="xref" href="../api/Unity.Entities.ComponentTypeHandle-1.html">ComponentTypeHandle</a> fields -- component handle fields allow your Execute function to access the entity components and buffers stored in the current chunk. See <a href="#access-components">Accessing entity component and buffer data</a>.</p>
</li>
<li><p><a class="xref" href="../api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a>, <a class="xref" href="../api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a> fields -- these &quot;data from entity&quot; fields allow your  Execute function to look up data for any entity no matter where it is stored. (This type of random access is the least efficient way to access data and should only be used when necessary.) See <a href="#look-up-data">Looking up data for other entities</a>.</p>
</li>
<li><p>Other fields -- you can declare other fields for your struct as needed. You can set the value of such fields each time you schedule the job. See <a href="#access-other-data">Accessing other data</a>.</p>
</li>
<li><p>Output fields -- in addition to updating writable entity components or buffers in a job, you can also write to <a class="xref" href="https://docs.unity3d.com/2020.1/Documentation/Manual/JobSystemNativeContainer.html">native container</a> fields declared for the job struct. Such fields must be a native container, such as a <a class="xref" href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/Unity.Collections.NativeArray_1.html">NativeArray</a>; you cannot use other data types.</p>
</li>
</ul>
<p><a name="access-components" id="access-components"></a></p>
<h4 id="accessing-entity-component-and-buffer-data">Accessing entity component and buffer data</h4>
<p>Accessing data stored in a component of one of the entities in the query is three-step process:</p>
<p><strong>First</strong>, you must define a <a class="xref" href="../api/Unity.Entities.ComponentTypeHandle-1.html">ComponentTypeHandle</a> field on the job struct, setting T to the data type of the component. For example:</p>
<pre><code class="lang-cs" name="component-handle">public ComponentTypeHandle&lt;Translation&gt; translationTypeHandle;
</code></pre><p><strong>Next</strong>, you use this handle field inside the job’s <code>Execute</code> method to access the array containing the data for that type component (as a <a class="xref" href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/Unity.Collections.NativeArray_1.html">NativeArray</a>). This array contains an element for every entity in a batch:</p>
<pre><code class="lang-cs" name="component-array">NativeArray&lt;Translation&gt; translations =
    batchInChunk.GetNativeArray(translationTypeHandle);
</code></pre><p><strong>Finally</strong>, when you schedule the job (in the system’s <a class="xref" href="../api/Unity.Entities.SystemBase.OnUpdate.html">OnUpdate</a> method, you assign a value to the type handle field using the <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.GetComponentTypeHandle.html">ComponentSystemBase.GetComponentTypeHandle</a> function:</p>
<pre><code class="lang-cs" name="component-set-handle">// &quot;this&quot; is your SystemBase subclass
updateFromVelocityJob.translationTypeHandle
    = this.GetComponentTypeHandle&lt;Translation&gt;(false);
</code></pre><p>Always set the component handle fields of a job every time you schedule the job. Do not cache a type handle and use it later.</p>
<p>Each array of component data in a batch is aligned such that a given index corresponds to the same entity in all arrays. In other words, if your job uses two components of an entity, use the same array index in both data arrays to access data for the same entity.  </p>
<p>You can use <a class="xref" href="../api/Unity.Entities.ComponentTypeHandle-1.html">ComponentTypeHandle</a> variables to access component types that you do not include in the <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a>. However, you must check to make sure that the current batch contains the component before you try to access it. Use the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.Has.html">Has</a> function to check whether the current batch contains a specific component type:</p>
<p>The <a class="xref" href="../api/Unity.Entities.ComponentTypeHandle-1.html">ComponentTypeHandle</a> fields are part of the ECS job safety system that prevents race conditions when reading and writing of data in jobs. Always set the <code>isReadOnly</code> argument of the <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.GetComponentTypeHandle.html">GetComponentTypeHandle</a> function to accurately reflect how the component is accessed in a job. </p>
<p><a name="look-up-data" id="look-up-data"></a></p>
<h4 id="looking-up-data-for-other-entities">Looking up data for other entities</h4>
<p>Accessing component data through an <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> and an <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> job (or <a class="xref" href="ecs_entities_foreach.html">Entities.ForEach</a>) is almost always the most efficient way to access your data. However, there are often cases where you need to look up data in a random-access fashion, for example, when one entity depends on data in another. To perform this type of data lookup, you must pass a different type of handle to your job through the job struct:</p>
<p><a class="xref" href="../api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a> -- access the component of any entity with that component type</p>
<p><a class="xref" href="../api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a> -- access a buffer of any entity with that buffer type</p>
<p>These types provide an array-like interface to components and buffers, indexed by <a class="xref" href="../api/Unity.Entities.Entity.html">Entity</a> object. In addition to being relatively inefficient because of the random data access, looking up data this way can also increase the chances that you run into the safeguards erected by the job safety system. For example, if you try to set the transform of one entity based on the transform of another entity, the job safety system cannot tell if this is safe, since you have access to all transforms through the <a class="xref" href="../api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a> object. You could be writing to the same data you are reading and so creating a race condition. </p>
<p>To use <a class="xref" href="../api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a> and <a class="xref" href="../api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a>, declare a field of type <a class="xref" href="../api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a> or <a class="xref" href="../api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a> on the job struct and set the value of the field before scheduling the job.</p>
<p>For more information, see <a class="xref" href="ecs_lookup_data.html">Looking up data</a>.</p>
<p><a name="access-other-data" id="access-other-data"></a></p>
<h4 id="accessing-other-data">Accessing other data</h4>
<p>If you need other information when executing a job, you can define a field on the job struct and then access the field inside the <code>Execute</code> method. You can only set the value when scheduling the job and that value remains the same for all batches.</p>
<p>For example, if you are updating moving objects, you most likely need to pass in the time elapsed since the previous update. To do this, you could define a field named <code>DeltaTime</code>, set its value in <code>OnUpdate</code> and use that value in the job <code>Execute</code> function. At each frame, you would calculate and assign a new value to your <code>DeltaTime</code> field before scheduling the job for the new frame.</p>
<p><a name="write-execute-function" id="write-execute-function"></a></p>
<h3 id="write-the-execute-function">Write the Execute function</h3>
<p>Write the <code>Execute</code> function of your job struct to transform your data from its input state to the desired output state. </p>
<p>The signature of the <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.Execute.html">IJobEntityBatch.Execute</a> method is:</p>
<pre><code class="lang-cs">void Execute(ArchetypeChunk batchInChunk, int batchIndex)
</code></pre><p>And for <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.Execute.html">IJobEntityBatchWithIndex.Execute</a>, the signature is:</p>
<pre><code class="lang-cs">void Execute(ArchetypeChunk batchInChunk, int batchIndex, int indexOfFirstEntityInQuery)
</code></pre><h4 id="the-batchinchunk-parameter">The batchInChunk parameter</h4>
<p>The <code>batchInChunk</code> parameter provides the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk</a> instance that contains the entities and components for this iteration of the job. Because a chunk can only contain a single archetype, all of the entities in a chunk have the same set of components. By default, this object includes all the entities in a single chunk; however, if you schedule the job with <a class="xref" href="../api/Unity.Entities.JobEntityBatchExtensions.ScheduleParallel.html">ScheduleParallel</a>, you can specify that a batch contains only a fraction of the number of entities in the chunk. </p>
<p>Use the <code>batchInChunk</code> parameter to get the <a class="xref" href="https://docs.unity3d.com/2020.1/Documentation/ScriptReference/Unity.Collections.NativeArray_1.html">NativeArray</a> instances you need to access the component data. (You must also declare a field with the corresponding component type handle — and set that field when scheduling the job.)</p>
<h4 id="the-batchindex-parameter">The batchIndex parameter</h4>
<p>The <code>batchIndex</code> parameter is the index of the current batch in the list of all batches created for the current job. The batches in a job are not necessarily processed in the indexed order.</p>
<p>You can use the <code>batchIndex</code> value in situations where you have a native container with one element per batch to which you want to write a value computed in your <code>Execute</code> function. Use the <code>batchIndex</code> as the array index into this container.</p>
<p>If you use a parallel writing <a class="xref" href="entity_command_buffer.html">entity command buffer</a>, pass the <code>batchIndex</code> argument as the <code>sortKey</code> parameter to the command buffer functions. </p>
<h4 id="the-indexoffirstentityinquery-parameter">The indexOfFirstEntityInQuery parameter</h4>
<p>An <a class="xref" href="../api/Unity.Entities.IJobEntityBatchWithIndex.html">IJobEntityBatchWithIndex</a> <code>Execute</code> function has an additional parameter named <code>indexofFirstEntityInQuery</code>. If you picture the entities selected by your query as a single list, <code>indexOfFirstEntityInQuery</code> would be the index into that list of the first entity in the current batch. The batches in a job are not necessarily processed in the indexed order. </p>
<h4 id="optional-components">Optional components</h4>
<p>If you have the <a class="xref" href="../api/Unity.Entities.EntityQueryDesc.Any.html">Any</a> filter in your entity query or have completely optional components that don’t appear in the query at all, you can use the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.Has.html">ArchetypeChunk.Has</a> function to test whether the current chunk contains one of those components before you use it:</p>
<pre><code class="lang-cs" name="batch-has-component">// If entity has Rotation and LocalToWorld components,
// slerp to align to the velocity vector
if (batchInChunk.Has&lt;Rotation&gt;(rotationTypeHandle) &amp;&amp;
    batchInChunk.Has&lt;LocalToWorld&gt;(l2wTypeHandle))
{
    NativeArray&lt;Rotation&gt; rotations
        = batchInChunk.GetNativeArray(rotationTypeHandle);
    NativeArray&lt;LocalToWorld&gt; transforms
        = batchInChunk.GetNativeArray(l2wTypeHandle);

    // By putting the loop inside the check for the
    // optional components, we can check once per batch
    // rather than once per entity.
    for (int i = 0; i &lt; batchInChunk.Count; i++)
    {
        float3 direction = math.normalize(velocityVectors[i].Value);
        float3 up = transforms[i].Up;
        quaternion rotation = rotations[i].Value;

        quaternion look = quaternion.LookRotation(direction, up);
        quaternion newRotation = math.slerp(rotation, look, DeltaTime);

        rotations[i] = new Rotation() { Value = newRotation };
    }
}
</code></pre><p><a name="schedule-the-job" id="schedule-the-job"></a></p>
<h2 id="schedule-the-job">Schedule the job</h2>
<p>To run an <a class="xref" href="../api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a> job, you must create an instance of your job struct, set the struct fields, and then schedule the job. When you do this in the <a class="xref" href="../api/Unity.Entities.SystemBase.OnUpdate.html">OnUpdate</a> function of a <a class="xref" href="../api/Unity.Entities.SystemBase.html">SystemBase</a> implementation, the system schedules the job to run every frame.</p>
<pre><code class="lang-cs" name="schedule-job">public class UpdateTranslationFromVelocitySystem : SystemBase
{
    EntityQuery query;

    protected override void OnCreate()
    {
        // Set up the query
        var description = new EntityQueryDesc()
        {
            All = new ComponentType[]
                   {ComponentType.ReadWrite&lt;Translation&gt;(),
                    ComponentType.ReadOnly&lt;VelocityVector&gt;()}
        };
        query = this.GetEntityQuery(description);
    }

    protected override void OnUpdate()
    {
        // Instantiate the job struct
        var updateFromVelocityJob
            = new UpdateTranslationFromVelocityJob();

        // Set the job component type handles
        // &quot;this&quot; is your SystemBase subclass
        updateFromVelocityJob.translationTypeHandle
            = this.GetComponentTypeHandle&lt;Translation&gt;(false);
        updateFromVelocityJob.velocityTypeHandle
            = this.GetComponentTypeHandle&lt;VelocityVector&gt;(true);

        // Set other data need in job, such as time
        updateFromVelocityJob.DeltaTime = World.Time.DeltaTime;

        // Schedule the job
        this.Dependency
            = updateFromVelocityJob.ScheduleParallel(query, 1, this.Dependency);
    }
</code></pre><p>When you call the <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.GetComponentTypeHandle.html">GetComponentTypeHandle</a> function to set your component type variables, make sure that you set the <code>isReadOnly</code> parameter to true for components that the job reads, but doesn’t write. Setting these parameters correctly can have a significant impact on how efficiently the ECS framework can schedule your jobs. These access mode settings must match their equivalents in both the struct definition, and the <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a>.</p>
<p>Do not cache the return value of <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.GetComponentTypeHandle.html">GetComponentTypeHandle</a> in a system class variable. You must call the function every time the system runs, and pass the updated value to the job.</p>
<h3 id="scheduling-options">Scheduling options</h3>
<p>You can control how a job executes by choosing the appropriate function when you schedule the job:</p>
<ul>
<li><p><a class="xref" href="../api/Unity.Entities.JobEntityBatchExtensions.Run.html">Run</a> -- executes the job immediately on the current (main) thread. Run also completes any scheduled jobs that the current job depends upon. Batch size is always 1 (an entire chunk).</p>
</li>
<li><p><a class="xref" href="../api/Unity.Entities.JobEntityBatchExtensions.Schedule.html">Schedule</a> -- schedules the job to run on a worker thread after any scheduled jobs that the current job depends upon. The jobs execute function is called once for each chunk selected by the entity query. Chunks are processed in sequence. Batch size is always 1.</p>
</li>
<li><p><a class="xref" href="../api/Unity.Entities.JobEntityBatchExtensions.ScheduleParallel.html">ScheduleParallel</a> -- Like Schedule, except that you can specify a batch size and the batches are processed in parallel (assuming worker threads are available) rather than sequentially.</p>
</li>
</ul>
<h3 id="setting-the-batch-size">Setting the batch size</h3>
<p>To set a batch size, use the <a class="xref" href="../api/Unity.Entities.JobEntityBatchExtensions.ScheduleParallel.html">ScheduleParallel</a> method to schedule the job and set the <code>batchesPerChunk</code> parameter to a positive integer. Use a value of 1 to set the batch size to a full chunk. </p>
<p>Each chunk selected by the query used to schedule the job is divided into the number of batches specified by <code>batchesPerChunk</code>. Each batch from the same chunk contains approximately the same number of entities; however, batches from different chunks may contain very different numbers of entities. The largest batch size is 1, which means that all the entities in each chunk are processed together in one call to your <code>Execute</code> function. Entities from different chunks can never be included in the same batch.</p>
<div class="NOTE"><h5>Note</h5><p>Typically, it is most efficient to use a <code>batchesPerChunk</code> setting of 1 to process all the entities in a chunk in a single call to <code>Execute</code>. However, that is not always the case. For example, if you have a small number of entities and an expensive algorithm performed by your <code>Execute</code> function, you could gain additional benefit from parallel processing by using smaller batches of entities.  </p>
</div>
<h2 id="skipping-chunks-with-unchanged-entities">Skipping chunks with unchanged entities</h2>
<p>If you only need to update entities when a component value has changed, you can add that component type to the change filter of the <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> that selects the entities and chunks for the job. For example, if you have a system that reads two components and only needs to update a third when one of the first two has changed, you can use an <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> as follows:</p>
<pre><code class="lang-cs" name="filter-query">EntityQuery query;

protected override void OnCreate()
{
    query = GetEntityQuery(
        new ComponentType[]
        {
            ComponentType.ReadOnly&lt;InputA&gt;(),
            ComponentType.ReadOnly&lt;InputB&gt;(),
            ComponentType.ReadWrite&lt;Output&gt;()
        }
    );

    query.SetChangedVersionFilter(
            new ComponentType[]
            {
                typeof(InputA),
                typeof(InputB)
            }
        );
}
</code></pre><p>The <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> change filter supports up to two components. If you want to check more or you aren&#39;t using an <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a>, you can make the check manually. To make this check, use the <a class="xref" href="../api/Unity.Entities.ArchetypeChunk.DidChange.html">ArchetypeChunk.DidChange</a> function to compare the chunk’s change version for the component to the system&#39;s <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.LastSystemVersion.html#Unity_Entities_ComponentSystemBase_LastSystemVersion">LastSystemVersion</a>. If this function returns false, you can skip the current chunk altogether because none of the components of that type have changed since the last time the system ran.</p>
<p>You must use a struct field to pass the <a class="xref" href="../api/Unity.Entities.ComponentSystemBase.LastSystemVersion.html#Unity_Entities_ComponentSystemBase_LastSystemVersion">LastSystemVersion</a> from the system into the job, as follows:</p>
<pre><code class="lang-cs" name="skip-unchanged-batches-job">struct UpdateOnChangeJob : IJobEntityBatch
{
    public ComponentTypeHandle&lt;InputA&gt; InputATypeHandle;
    public ComponentTypeHandle&lt;InputB&gt; InputBTypeHandle;
    [ReadOnly] public ComponentTypeHandle&lt;Output&gt; OutputTypeHandle;
    public uint LastSystemVersion;

    [BurstCompile]
    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)
    {
        var inputAChanged = batchInChunk.DidChange(InputATypeHandle, LastSystemVersion);
        var inputBChanged = batchInChunk.DidChange(InputBTypeHandle, LastSystemVersion);

        // If neither component changed, skip the current batch
        if (!(inputAChanged || inputBChanged))
            return;

        var inputAs = batchInChunk.GetNativeArray(InputATypeHandle);
        var inputBs = batchInChunk.GetNativeArray(InputBTypeHandle);
        var outputs = batchInChunk.GetNativeArray(OutputTypeHandle);

        for (var i = 0; i &lt; outputs.Length; i++)
        {
            outputs[i] = new Output { Value = inputAs[i].Value + inputBs[i].Value };
        }
    }
}
</code></pre><p>As with all the job struct fields, you must assign its value before you schedule the job:</p>
<pre><code class="lang-cs" name="skip-unchanged-batches-system">public class UpdateDataOnChangeSystem : SystemBase {

    EntityQuery query;

    protected override void OnUpdate()
    {
        var job = new UpdateOnChangeJob();

        job.LastSystemVersion = this.LastSystemVersion;

        job.InputATypeHandle = GetComponentTypeHandle&lt;InputA&gt;(true);
        job.InputBTypeHandle = GetComponentTypeHandle&lt;InputB&gt;(true);
        job.OutputTypeHandle = GetComponentTypeHandle&lt;Output&gt;(false);

        this.Dependency = job.ScheduleParallel(query, 1, this.Dependency);
    }

    protected override void OnCreate()
    {
        query = GetEntityQuery(
            new ComponentType[]
            {
                ComponentType.ReadOnly&lt;InputA&gt;(),
                ComponentType.ReadOnly&lt;InputB&gt;(),
                ComponentType.ReadWrite&lt;Output&gt;()
            }
        );
    }
}
</code></pre><div class="NOTE"><h5>Note</h5><p>For efficiency, the change version applies to whole chunks not individual entities. If another job which has the ability to write to that type of component accesses a chunk, then ECS increments the change version for that component and the DidChange function returns true. ECS increments the change version even if the job that declares write access to a component does not actually change the component value. (This is one of the reasons you should always read-only when you are reading component data and not updating it.)</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2020 Unity Technologies<br>Generated by <strong>DocFX</strong></span> on Wednesday, October 28, 2020
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script type="text/javascript" src="../styles/metadata-collector.js"></script>
    <script type="text/javascript" src="../styles/version-switcher.js"></script>
    <script type="text/javascript" src="../styles/language-switcher.js"></script>
  </body>
</html>
