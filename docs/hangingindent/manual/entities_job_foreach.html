<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-5V25JL6');</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>JobComponentSystem lambda functions | Unity Entities Documentation | 0.2.0-preview.12 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="JobComponentSystem lambda functions | Unity Entities Documentation | 0.2.0-preview.12 ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="unity:packageTitle" content="Unity Entities Documentation | 0.2.0-preview.12">
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="manual">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="ecs-entities-foreach">
<h1 id="jobcomponentsystem-lambda-functions">JobComponentSystem lambda functions</h1>

<p><a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> lambda functions provide a concise way to define and execute your algorithms over entities, their components, or over native containers.</p>
<p>The <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> supports two types of lambda functions:</p>
<ul>
<li><strong><code>JobComponentSystem.Entities.ForEach(lambda)</code></strong> executes the lambda function over all the entities selected by an <a class="xref" href="../api/Unity.Entities.EntityQuery.html">entity query</a> (which is defined by the Entities.ForEach options and lambda parameters). </li>
<li><strong><code>JobComponentSystem.Job.WithCode(lambda)</code></strong>  executes the lambda function once as an IJob.</li>
</ul>
<p>To execute a job lambda function, you define the lambda using either <code>ForEach()</code> or <code>WithCode()</code>, and then you either schedule the job using <code>Schedule()</code> or execute it immediately (on the main thread) with <code>Run()</code>. Whether you use Entities.ForEach or Job.WthCode, you can use additional methods defined on these objects to set various job options and parameters.</p>
<p><strong>Entities.ForEach example:</strong></p>
<p>The following example illustrates a simple <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> that uses Entities.ForEach to read one component (Velocity in this case) and write to another (Translation):</p>
<pre><code class="lang-cs" name="entities-foreach-example">class ApplyVelocitySystem : JobComponentSystem
{
    protected override JobHandle OnUpdate(JobHandle inputDependencies)
    {
        var jobHandle = Entities
            .ForEach((ref Translation translation,
                      in Velocity velocity) =&gt;
            {
                translation.Value += velocity.Value;
            })
            .Schedule(inputDependencies);

        return jobHandle;
    }
}
</code></pre><p>Note the use of the keywords <code>ref</code> and <code>in</code> on the parameters of the ForEach lambda function. Use <code>ref</code> for components that you write to, and <code>in</code> for components that you only read. Marking components as read-only helps the job scheduler execute your jobs more efficiently.</p>
<p><strong>Job.WithCode example</strong></p>
<p>The following example illustrates a simple example that uses one Job.WithCode() lambda function to fill a <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">native array</a> with random numbers and another to add those numbers together:</p>
<pre><code class="lang-cs" name="job-with-code-example">public class RandomSumJob : JobComponentSystem
{
    private uint seed = 1;

    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        Random randomGen = new Random(seed++);
        NativeArray&lt;float&gt; randomNumbers
            = new NativeArray&lt;float&gt;(500, Allocator.TempJob);

        JobHandle generateNumbers = Job.WithCode(() =&gt;
        {
            for (int i = 0; i &lt; randomNumbers.Length; i++)
            {
                randomNumbers[i] = randomGen.NextFloat();
            }
        }).Schedule(inputDeps);


        NativeArray&lt;float&gt; result
            = new NativeArray&lt;float&gt;(1, Allocator.TempJob);

        JobHandle sumNumbers = Job.WithCode(() =&gt;
        {
            for (int i = 0; i &lt; randomNumbers.Length; i++)
            {
                result[0] += randomNumbers[i];
            }
        }).Schedule(generateNumbers);

        sumNumbers.Complete();
        UnityEngine.Debug.Log(&quot;The sum of &quot;
                              + randomNumbers.Length + &quot; numbers is &quot; + result[0]);

        randomNumbers.Dispose();
        result.Dispose();

        return sumNumbers;
    }
}

</code></pre><p>In a real application, the first job might calculate intermediate results from a set of entity components in a parallel job, while the second job combines those results to calculate the solution. </p>
<p><a name="foreach-entity-query"></a></p>
<h2 id="entitiesforeach-entity-query">Entities.ForEach entity query</h2>
<p>The entities and chunks processed by an Entities.ForEach lambda are selected by an <a class="xref" href="../api/Unity.Entities.EntityQuery.html">entity query</a>, which is implicitly created when the <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> is created. (Use <code>WithStoreEntityQueryInField(ref EntityQuery)</code> to get access to this implicit EntityQuery object.)</p>
<p>The query is constructed by combining the parameters you declare for the lambda function with the component types you add to the query explicitly using WithAll<t>, WithAny<t>, and WithNone<t> functions. You can also set specific query options using additional Entities functions. The query-related Entities functions include: <p>
<ul>
<li><strong><code>WithAll&lt;T&gt;</code></strong> — An entity must have all of these component types (in addition to having all the component types found in the lambda parameter list)</li>
<li><strong><code>WithAny&lt;T,U&gt;</code></strong> — An entity must have one or more of these component types. Note that specifying a single component type using WithAny is allowed; however, because an entity must have one or more of these “optional” component types to be selected by the query, using WithAny with a single type is equivalent to putting that type in the WithAll statement.</li>
<li><strong><code>WithNone&lt;T&gt;</code></strong> — An entity must not have any of these component types.</li>
<li><strong><code>WithChangeFilter&lt;T&gt;</code></strong> — Only selects entities in chunks in which the specified component might have changed since the last time this <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> updated. </li>
<li><strong><code>WithSharedComponentFilter</code></strong> — Only select chunks that have a specified value for a shared component.</li>
<li><strong><code>WithStoreEntityQueryInField</code></strong> — stores the <a class="xref" href="../api/Unity.Entities.EntityQuery.html">EntityQuery</a> object generated by the Entities.ForEach in an EntityQuery field on your JobComponentSystem. You can use this EntityQuery object for such purposes as getting the number of entities that will be selected by the query. Note that this function assigns the EntityQuery instance to your field when the JobComponentSystem is created. This means that you can use the query before the first execution of the lambda function.</li>
</ul>
<p><strong>Important:</strong> Do not add components in the parameter list to the query using WithAny&lt;T,U&gt; or WithNone<t>. All of the components you add to the lambda function parameter list are added to the WithAll list of the entity query automatically; adding a component to both the WithAll list and the WithAny or WithNone lists creates an illogical query. <p>
<p><strong>Entity query example:</strong></p>
<p>The following example selects entities that have the components, Destination, Source, and LocalToWorld; and have at least one of the components, Rotation, Translation, or Scale; but which do not have a LocalToParent component.</p>
<pre><code class="lang-cs" name="entity-query">return Entities.WithAll&lt;LocalToWorld&gt;()
    .WithAny&lt;Rotation, Translation, Scale&gt;()
    .WithNone&lt;LocalToParent&gt;()
    .ForEach((ref Destination outputData,
        in Source inputData) =&gt;
    {
        /* do some work */
    })
    .Schedule(inputDeps);
</code></pre><p>In this example, only the Destination and Source components can be accessed inside the lambda function since they are the only components in the parameter list.</p>
<p><strong>Access to EntityQuery object example:</strong></p>
<p>The following example illustrates how to access the EntityQuery object implicitly created for an Entities.ForEach construction. In this case, the example uses the EntityQuery object to invoke the <a class="xref" href="../api/Unity.Entities.EntityQuery.html#Unity_Entities_EntityQuery_CalculateEntityCount">CalculateEntityCount()</a> method. The example use this count to create a native array with enough space to store one value per entity selected by the query:</p>
<pre><code class="lang-cs" name="store-query">private EntityQuery query;
protected override JobHandle OnUpdate(JobHandle inputDeps)
{
    int dataCount = query.CalculateEntityCount();
    NativeArray&lt;float&gt; dataSquared
        = new NativeArray&lt;float&gt;(dataCount, Allocator.Temp);
    JobHandle GetSquaredValues = Entities
        .WithStoreEntityQueryInField(ref query)
        .ForEach((int entityInQueryIndex, in Data data) =&gt;
            {
                dataSquared[entityInQueryIndex] = data.Value * data.Value;
            })
        .Schedule(inputDeps);

    return Job
        .WithCode(() =&gt;
        {
            //Use dataSquared array...
            var v = dataSquared[dataSquared.Length -1];
        })
        .WithDeallocateOnJobCompletion(dataSquared)
        .Schedule(GetSquaredValues);
}
</code></pre><p><a name="optional-components"></a></p>
<h3 id="optional-components">Optional components</h3>
<p>You cannot create a query specifying optional components (using WithAny&lt;T,U&gt;) and also access those components in the lambda function. If you need to read or write to a component that is optional, you can split the Entities.ForEach construction into multiple jobs, one for each combination of the optional components. For example, if you had two optional components, you would need three ForEach constructions: one including the first optional component, one including the second, and one including both components. Another alternative is to iterate by chunk using IJobChunk.</p>
<p><a name="change-filtering"></a></p>
<h3 id="change-filtering">Change filtering</h3>
<p>In cases where you only want to process an entity component when another entity of that component has changed since the last time the current <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> has run, you can enable change filtering using WithChangeFilter<t>. The component type used in the change filter must either be in the lambda function parameter list or part of a WithAll<t> statement.<p>
<pre><code class="lang-cs" name="with-change-filter">return Entities
    .WithChangeFilter&lt;Source&gt;()
    .ForEach((ref Destination outputData,
        in Source inputData) =&gt;
    {
        /* Do work */
    })
    .Schedule(inputDeps);
</code></pre><p>An entity query supports change filtering on up to two component types.</p>
<p>Note that change filtering is applied at the chunk level. If any code accesses a component in a chunk with write access, then that component type in that chunk is marked as changed -- even if the code didn’t actually change any data. </p>
<p><a name="shared-component-filtering"></a></p>
<h3 id="shared-component-filtering">Shared component filtering</h3>
<p>Entities with shared components are grouped into chunks with other entities having the same value for their shared components. You can select groups of entities that have specific shared component values using the WithSharedComponentFilter() function.</p>
<p>The following example selects entities grouped by a Cohort ISharedComponentData. The lambda function in this example sets a DisplayColor IComponentData component based on the entity’s cohort:</p>
<pre><code class="lang-cs" name="with-shared-component">public class ColorCycleJob : JobComponentSystem
{
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        List&lt;Cohort&gt; cohorts = new List&lt;Cohort&gt;();
        EntityManager.GetAllUniqueSharedComponentData&lt;Cohort&gt;(cohorts);
        NativeList&lt;JobHandle&gt; dependencies
            = new NativeList&lt;JobHandle&gt;();

        foreach (Cohort cohort in cohorts)
        {
            DisplayColor newColor = ColorTable.GetNextColor(cohort.Value);
            JobHandle thisJobHandle
                = Entities.WithSharedComponentFilter(cohort)
                    .ForEach((ref DisplayColor color) =&gt; { color = newColor; })
                    .Schedule(inputDeps);
            dependencies.Add(thisJobHandle);
        }

        return JobHandle.CombineDependencies(dependencies);
    }
}
</code></pre><p>The example uses the EntityManager to get all the unique cohort values. It then schedules a lambda job for each cohort, passing the new color to the lambda function as a captured variable. Since all the jobs run on distinct chunks, they can run in parallel (they are all scheduled with the inputDeps object passed to the OnUpDate() function of the system). And, since the system schedules multiple, independent jobs, it also combine the independent job handles into one handle, which it uses as the return value for OnUpdate().</p>
<p><a name="lambda-parameters"></a></p>
<h2 id="lambda-parameters">Lambda parameters</h2>
<p>When you define the lambda function to use with Entities.ForEach, you can declare parameters that the <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> uses to pass information about the current entity (or chunk) when it executes the function. (A Job.WithCode lambda function does not take any parameters.)</p>
<p>You can pass up to eight parameters to an Entities.ForEach lambda function. The parameters must be grouped in the following order:</p>
<pre><code>1. Parameters passed-by-value first (no parameter modifiers)
2. Writable parameters second (`ref` parameter modifier)
3. Read-only parameters last (`in` parameter modifier)
</code></pre><p>All components should use either the <code>ref</code> or the <code>in</code> parameter modifier keywords.</p>
<p>If your function does not obey these rules, the compiler provides an error similar to:</p>
<p><code>error CS1593: Delegate &#39;Invalid_ForEach_Signature_See_ForEach_Documentation_For_Rules_And_Restrictions&#39; does not take N arguments</code></p>
<p>(Note that the error message cites the number of arguments as the issue even when the problem is the parameter order.)</p>
<p><a name="component-parameters"></a></p>
<h3 id="component-parameters">Component parameters</h3>
<p>To access a component associated with an entity, you must pass a parameter of that component type to the Entities.ForEach lambda function (unless you are iterating over chunks instead of entities). The compiler automatically adds all components passed to the function to the entity query as required components. </p>
<p>To update a component value, you must pass it to the lambda function by reference using the <code>ref</code> keyword in the parameter list. (Without the <code>ref</code> keyword, any modifications would be made to a temporary copy of the component since it would be passed by value.) Note that using <code>ref</code> means that the components in the current chunk are marked as changed, even if the lambda function does not actually modify them. For efficiency, always designate components that your lambda function does not modify as read only.</p>
<p>To designate a component passed to the lambda function as read-only, use the <code>in</code> keyword in the parameter list.</p>
<p>The following example passes a Source component parameter to the job as read-only, and a Destination component parameter as writable: </p>
<pre><code class="lang-cs" name="read-write-modifiers">return Entities.ForEach(
        (ref Destination outputData,
            in Source inputData) =&gt;
        {
            outputData.Value = inputData.Value;
        })
    .Schedule(inputDeps);
</code></pre><p><strong>Note:</strong> Currently, you cannot pass chunk components to the Entities.ForEach lambda function.</p>
<p>For dynamic buffers, use DynamicBuffer<t> rather than the Component type stored in the buffer:<p>
<pre><code class="lang-cs" name="dynamicbuffer">public class BufferSum : JobComponentSystem
{
    private EntityQuery query;

    //Schedules the two jobs with a dependency between them
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        //The query variable can be accessed here because we are
        //using WithStoreEntityQueryInField(query) in the entities.ForEach below
        int entitiesInQuery = query.CalculateEntityCount();

        //Create a native array to hold the intermediate sums
        //(one element per entity)
        NativeArray&lt;int&gt; intermediateSums
            = new NativeArray&lt;int&gt;(entitiesInQuery, Allocator.TempJob);

        //Schedule the first job to add all the buffer elements
        JobHandle bufferSumJob = Entities
            .ForEach((int entityInQueryIndex, in DynamicBuffer&lt;IntBufferData&gt; buffer) =&gt;
            {
                for (int i = 0; i &lt; buffer.Length; i++)
                {
                    intermediateSums[entityInQueryIndex] += buffer[i].Value;
                }
            })
            .WithStoreEntityQueryInField(ref query)
            .WithName(&quot;IntermediateSums&quot;)
            .Schedule(inputDeps);

        //Schedule the second job, which depends on the first
        JobHandle finalSumJob = Job
            .WithCode(() =&gt;
            {
                int result = 0;
                for (int i = 0; i &lt; intermediateSums.Length; i++)
                {
                    result += intermediateSums[i];
                }
                //Not burst compatible:
                Debug.Log(&quot;Final sum is &quot; + result);
            })
            .WithDeallocateOnJobCompletion(intermediateSums)
            .WithoutBurst()
            .WithName(&quot;FinalSum&quot;)
            .Schedule(bufferSumJob);

        return finalSumJob;
    }
}
</code></pre><p><a name="named-parameters"></a></p>
<h3 id="special-named-parameters">Special, named parameters</h3>
<p>In addition to components, you can pass the following special, named parameters to the Entities.ForEach lambda function, which are assigned values based on the entity the job is currently processing:</p>
<ul>
<li><strong><code>Entity entity</code></strong> — the Entity instance of the current entity. (The parameter can be named anything as long as the type is Entity.)</li>
<li><strong><code>int entityInQueryIndex</code></strong> — the index of the entity in the list of all entities selected by the query. Use the entity index value when you have a <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">native array</a> that you need to fill with a unique value for each entity. You can use the entityInQueryIndex as the index in that array. The entityInQueryIndex should also be used as the jobIndex for adding commands to a concurrent <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.Concurrent.html">EntityCommandBuffer</a>.</li>
<li><strong><code>int nativeThreadIndex</code></strong> — a unique index for the thread executing the current iteration of the lambda function. When you execute the lambda function using Run(), nativeThreadIndex is always zero.</li>
</ul>
<p><a name="capturing-variables"></a></p>
<h2 id="capturing-variables">Capturing variables</h2>
<p>You can capture local variables for Entities.ForEach and Job.WithCode lambda functions. When you execute the function using a job (by calling Schedule() instead of Run()) there are some restrictions on the captured variables and how you use them:</p>
<p>Only native containers and blittable types can be captured.
A job can only write to captured variables that are native containers. (To “return” a single value, create a <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">native array</a> with one element.)</p>
<p>You can use the following functions to apply modifiers and attributes to the captured variables:</p>
<ul>
<li><strong><code>WithReadOnly(myvar)</code></strong> — restricts access to the variable as read-only.</li>
<li><strong><code>WithDeallocateOnJobCompletion(myvar)</code></strong> — deallocates the native container after the job is complete. See <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.DeallocateOnJobCompletionAttribute.html">DeallocateOnJobCompletionAttribute</a>.</li>
<li><strong><code>WithNativeDisableParallelForRestriction(myvar)</code></strong> — permits multiple threads to access the same writable native container. Parallel access is only safe when each thread only accesses its own, unique range of elements in the container. If more than one thread accesses the same element a race condition is created in which the timing of the access changes the result. See <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeDisableParallelForRestrictionAttribute.html">NativeDisableParallelForRestriction</a>.</li>
<li><strong><code>WithNativeDisableContainerSafetyRestriction(myvar)</code></strong> — disables normal safety restrictions that prevent dangerous access to the native container. Disabling safety restrictions unwisely can lead to race conditions, subtle bugs, and crashes in your application. See <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeDisableContainerSafetyRestrictionAttribute.html">NativeDisableContainerSafetyRestrictionAttribute</a>.</li>
<li><strong><code>WithNativeDisableUnsafePtrRestrictionAttribute(myvar)</code></strong> — Allows you to use unsafe pointers provided by the native container. Incorrect pointer use can lead to subtle bugs, instability, and crashes in your application. See <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeDisableUnsafePtrRestrictionAttribute.html">NativeDisableUnsafePtrRestrictionAttribute</a>.</li>
</ul>
<p><a name="job-options"></a></p>
<h2 id="job-options">Job options</h2>
<p>You can use the following methods with both Entities.ForEach and Job.WithCode lambda functions:</p>
<ul>
<li><strong><code>JobHandle Schedule(JobHandle)</code></strong> — schedules the lambda function to execute as a job:<ul>
<li><strong>Entities.ForEach</strong> — the job executes the lambda function on parallel background, job threads. Each job iterates over the entities in the chunks selected by the ForEach query. (A job instance processes the entities in a single chunk at minimum.)</li>
<li><strong>Job.WithCode</strong> — the job executes a single instance of the lambda function on a background, job thread.  </li>
</ul>
</li>
<li><strong><code>void Run()</code></strong> — executes the lambda function synchronously on the main thread:<ul>
<li><strong>Entities.ForEach</strong> — the lambda function is executed once for each entity in the chunks selected by the ForEach query. Note that <code>Run()</code> does not take a JobHandle parameter and does not return a JobHandle since your lambda function does not run as a job.</li>
<li><strong>Job.WithCode</strong> — the lambda function is executed once.</li>
</ul>
</li>
<li><strong><code>WithBurst(FloatMode, FloatPrecision, bool)</code></strong> — sets options for the Burst compiler:<ul>
<li><strong>floatMode</strong> — sets the floating point math optimization mode. Fast mode executes faster, but produces larger floating point error than Strict mode. Defaults to Strict. See <a href="https://docs.unity3d.com/Packages/com.unity.burst@latest?subfolder=/api/Unity.Burst.FloatMode.html">Burst FloatMode</a>.</li>
<li><strong>floatPrecision</strong> — sets the floating point math precision. See <a href="https://docs.unity3d.com/Packages/com.unity.burst@latest?subfolder=/api/Unity.Burst.FloatPrecision.html">Burst FloatPrecision</a>.</li>
<li><strong>synchronousCompilation</strong> — compiles the function immediately instead of scheduling the function for compilation later.</li>
</ul>
</li>
<li><strong><code>WithoutBurst()</code></strong> — disables Burst compilation. Use this function when your lambda function contains code not supported by Burst.</li>
<li><strong><code>WithStructuralChanges()</code></strong> — executes the lambda function on the main thread and disables Burst so that you can make structural changes to your entity data within the function. For better performance, use a concurrent <a class="xref" href="../api/Unity.Entities.EntityCommandBuffer.Concurrent.html">EntityCommandBuffer</a> instead.</li>
<li><strong><code>WithName(string)</code></strong> — assigns the specified string as the name of the generated job class. Assigning a name is optional, but can help identify the function when debugging and profiling.</li>
</ul>
<h3 id="job-dependencies">Job dependencies</h3>
<p>The JobHandle object passed to the JobComponentSystem.OnUpdate method encapsulates all the component-related, read-write job dependencies declared by the JobComponentSystem instances that have already updated so far in the frame. When you pass the input dependencies from previous systems to your Schedule method, ECS ensures the prior completion of any jobs writing to the same component data accessed by the current lambda function. When you call Run(), the lambda function executes on the main thread, so any jobs scheduled by earlier systems are completed immediately. </p>
<p>Likewise, your OnUpdate() function must pass its dependencies to subsequent systems by returning a JobHandle. If your update function constructs a single job, you can return the JobHandle provided by Schedule(). If your update function constructs multiple jobs, you can either chain the individual dependencies by passing the JobHandle returned by one to the Schedule() method of the next, or, if the jobs do not depend on each other, you can combine their dependencies using <a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html">JobHandle.CombineDependencies()</a>. </p>
<p>Note, the JobHandle only includes dependences for component data, not native containers. If you have a system or job that reads data in a native container populated by another system or job, you must manage the dependency manually. One way to do this is to provide a method or property that allows the producing system to add a JobHandle as a dependency for the consuming system. (See the <a href="xref:Unity.Entities.EntityCommandBufferSystem.AddJobHandleForProducer(Unity.Jobs.JobHandle)">AddProducerForJob()</a> method of the EntityCommandBufferSystem for an example of this technique.)</p>
<p><a name="foreach-ecb"></a></p>
<h2 id="using-entitiesforeach-with-an-entitycommandbuffer">Using Entities.ForEach with an EntityCommandBuffer</h2>
<p>You cannot perform structural changes to entities in a job, including creating entities, adding or removing components, or destroying entities. Instead, you must defer structural changes to a later point in the frame using an entity command buffer. The default ECS system group setup provides entity command buffer systems at the beginning and end of the standard system groups. In general, you should pick the last entity command buffer system that runs before any of your other systems that rely on your structural changes. For example, if you create entities in the simulation system group and want to render those entities in the same frame, you could use entity command buffers created by the EndSimulationEntityCommandBufferSystem when creating the entities.</p>
<p>To create entity command buffers, you store a reference to the entity command buffer system you want to use. Them in your OnUpdate function, you use that reference to create an EntityCommandBuffer instance to use for the current frame. (You must create a new entity command buffer for every update.) </p>
<p>The following example illustrates how to create an entity command buffer, in this case, obtaining it from the EndSimulationEntityCommandBufferSystem:</p>
<pre><code class="lang-cs" name="basic-ecb">public class MyJobSystem : JobComponentSystem
{
    private EndSimulationEntityCommandBufferSystem commandBufferSystem;

    protected override void OnCreate()
    {
        commandBufferSystem = World
            .DefaultGameObjectInjectionWorld
            .GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();
    }

    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        EntityCommandBuffer.Concurrent commandBuffer
            = commandBufferSystem.CreateCommandBuffer().ToConcurrent();

        //.. The rest of the job system code
        return inputDeps;
    }
}
</code></pre><p>Since <code>Entities.ForEach.Schedule()</code> creates a parallel job, you must use the concurrent interface of the entity command buffer. </p>
<p><strong>Entites.ForEach lambda with entity command buffer example</strong></p>
<p>The following example illustrates using entity command buffers in a <a class="xref" href="../api/Unity.Entities.JobComponentSystem.html">JobComponentSystem</a> that implements a simple particle system:</p>
<pre><code class="lang-cs" name="full-ecb-pt-one">// ParticleSpawner.cs
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Transforms;

public struct Velocity : IComponentData
{
    public float3 Value;
}

public struct TimeToLive : IComponentData
{
    public float LifeLeft;
}

public class ParticleSpawner : JobComponentSystem
{
    private EndSimulationEntityCommandBufferSystem commandBufferSystem;

    protected override void OnCreate()
    {
        commandBufferSystem = World
            .DefaultGameObjectInjectionWorld
            .GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();
    }

    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        EntityCommandBuffer.Concurrent commandBufferCreate
            = commandBufferSystem.CreateCommandBuffer().ToConcurrent();
        EntityCommandBuffer.Concurrent commandBufferCull
            = commandBufferSystem.CreateCommandBuffer().ToConcurrent();

        float dt = Time.DeltaTime;
        Random rnd = new Random();
        rnd.InitState((uint) (dt * 100000));


        JobHandle spawnJobHandle = Entities
            .ForEach((int entityInQueryIndex,
                      in SpawnParticles spawn,
                      in LocalToWorld center) =&gt;
            {
                int spawnCount = spawn.Rate;
                for (int i = 0; i &lt; spawnCount; i++)
                {
                    Entity spawnedEntity = commandBufferCreate
                        .Instantiate(entityInQueryIndex,
                                     spawn.ParticlePrefab);

                    LocalToWorld spawnedCenter = center;
                    Translation spawnedOffset = new Translation()
                    {
                        Value = center.Position +
                                rnd.NextFloat3(-spawn.Offset, spawn.Offset)
                    };
                    Velocity spawnedVelocity = new Velocity()
                    {
                        Value = rnd.NextFloat3(-spawn.MaxVelocity, spawn.MaxVelocity)
                    };
                    TimeToLive spawnedLife = new TimeToLive()
                    {
                        LifeLeft = spawn.Lifetime
                    };

                    commandBufferCreate.SetComponent(entityInQueryIndex,
                                                     spawnedEntity,
                                                     spawnedCenter);
                    commandBufferCreate.SetComponent(entityInQueryIndex,
                                                     spawnedEntity,
                                                     spawnedOffset);
                    commandBufferCreate.AddComponent(entityInQueryIndex,
                                                     spawnedEntity,
                                                     spawnedVelocity);
                    commandBufferCreate.AddComponent(entityInQueryIndex,
                                                     spawnedEntity,
                                                     spawnedLife);
                }
            })
            .WithName(&quot;ParticleSpawning&quot;)
            .Schedule(inputDeps);

        JobHandle MoveJobHandle = Entities
            .ForEach((ref Translation translation, in Velocity velocity) =&gt;
            {
                translation = new Translation()
                {
                    Value = translation.Value + velocity.Value * dt
                };
            })
            .WithName(&quot;MoveParticles&quot;)
            .Schedule(spawnJobHandle);

        JobHandle cullJobHandle = Entities
            .ForEach((Entity entity, int entityInQueryIndex, ref TimeToLive life) =&gt;
            {
                life.LifeLeft -= dt;
                if (life.LifeLeft &lt; 0)
                    commandBufferCull.DestroyEntity(entityInQueryIndex, entity);
            })
            .WithName(&quot;CullOldEntities&quot;)
            .Schedule(inputDeps);

        JobHandle finalDependencies
            = JobHandle.CombineDependencies(MoveJobHandle, cullJobHandle);

        commandBufferSystem.AddJobHandleForProducer(spawnJobHandle);
        commandBufferSystem.AddJobHandleForProducer(cullJobHandle);

        return finalDependencies;
    }
}
</code></pre><pre><code class="lang-cs" name="full-ecb-pt-one">// SpawnParticles.cs
using Unity.Entities;
using Unity.Mathematics;

[GenerateAuthoringComponent]
public struct SpawnParticles : IComponentData
{
    public Entity ParticlePrefab;
    public int Rate;
    public float3 Offset;
    public float3 MaxVelocity;
    public float Lifetime;
}
</code></pre><h2 id="implementation-notes">Implementation notes</h2>
<p>Entities.ForEach and Job.WithCode use a compiler extension to convert the code that you write into efficient, job-based C# code. Essentially, when writing an Entities.ForEach or Job.WithCode construction, you are describing what you want the job to do and the compiler extension generates the required code to make that happen. In general, this conversion should be transparent to you; however, take note of the following:</p>
<ul>
<li>Performance drawbacks of lambda functions such as extra managed memory allocations when capturing variables do not apply.</li>
<li>Code completion in an IDE may not list the correct parameters for the Entities and Job object methods.</li>
<li>You may see the generated class names in places like warnings, error messages, and IL code disassembly.</li>
<li>When you use <code>WithStoreEntityQueryInField(ref query)</code>, the compiler extension assigns a value to the query field before the system&#39;s <code>OnCreate()</code> method. This means that you can access the EntityQuery object referenced by the field before the the Entities.ForEach lambda function runs for the first time.</li>
</ul>
</t></t></t></t></t></t></t></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2019 Unity Technologies<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
