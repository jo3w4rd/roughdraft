<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-MC35ML');</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  
    <title>Threading | Unity Technologies Developer Guide </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Threading | Unity Technologies Developer Guide ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" class="manual">
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MC35ML" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
        
        		<div class="back-to-unity-group">
        			<a class="back-to-unity" href="http://docs.unity3d.com/">docs.unity3d.com</a>
        		</div>
        
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="threading">Threading</h1>

<p>Much of the XDK API requires asynchronous callbacks that will be invoked on separate threads.  Unity handles this asynchronous behavior in the core of Unity and within the <a href="xboxone-plugins.html">plugins</a>.  If you use your own threads or implement your own code that uses asynchronous XDK calls, you must be careful with threading hazards with Unity objects.  Accessing GameObjects and other Unity classes is not thread safe, and you must avoid doing so on worker threads.</p>
<h2 id="unity-event-queue">Unity Event Queue</h2>
<p>The <strong>Unity Event Queue</strong> (<strong>UEQ</strong>) is a new feature that provides a way to send events and messages between different systems in your code.  Events can be queued up from any number of threads, and they will be processed on Unity&#39;s main thread.  This can be used in your own native plugins to facilitate communication between code systems, plugins, or to make sure a callback is processed on Unity&#39;s main thread where it is safe to access Unity classes.</p>
<p>If you look at the source for the <a href="xboxone-plugins.html">plugins</a>,you will find a file named <em>UnityEventQueue.h</em>. This has code that you can use to utilize the <strong>UEQ</strong> from your native plugins. There is no way to directly use the <strong>UEQ</strong> in your game&#39;s scripts. The following details will use pieces from that header to explain how the <strong>UEQ</strong> works. The <a href="xboxone-plugins.html">plugins</a> also serve as a great guide to using events effectively.</p>
<p><em>Keep in mind that the following code is C++ code, not C# code.</em></p>
<h2 id="ieventqueue">IEventQueue</h2>
<p>The <strong>IEventQueue</strong> interface provides access to the <strong>UEQ</strong>.  This is not an interface that is meant to be inherited from.  You can get a reference to the <strong>UEQ</strong> through the <strong>UnitySetEventQueue</strong> function.</p>
<pre><code>class IEventQueue
 {
 public:
    template&lt;typename T&gt;
    void SendEvent(T &amp; payload);

    virtual void AddHandler(EventHandler * handler);
    virtual bool RemoveHandler(EventHandler * handler);
 };
</code></pre><h3 id="sendevent">SendEvent</h3>
<p>Adds an event to the <strong>UEQ</strong>.  This can be called from any thread.  The event type must be registered and adhere to the guidelines described in <strong>Events</strong>.</p>
<h3 id="addhandler">AddHandler</h3>
<p>Adds a handler so it will process events.  This must be called on Unity&#39;s main thread.  If you must add a handler on a worker thread, you can use the <strong>AddEventHandler</strong> event.  It is not necessary to add your own handler for the <strong>AddEventHandler</strong> event.</p>
<h3 id="removehandler">RemoveHandler</h3>
<p>Removes a handler so it will no longer process events.  This must be called on Unity&#39;s main thread.  If you must add a handler on a worker thread, you can use the <strong>AddEventHandler</strong> event.  It is not necessary to add your own handler for the <strong>AddEventHandler</strong> event.</p>
<h2 id="events">Events</h2>
<p>Events are payloads that let you communicate with other systems.  The event can be an empty struct that simply acts as a notification that something has happened, or it can carry information along with it.  When the <strong>UEQ</strong> is processed, the event is given to an <strong>EventHandler</strong>.</p>
<pre><code>struct SimpleEvent
{
    SimpleEvent() {}
};
REGISTER_EVENT_ID(&lt;&lt;something unique&gt;&gt;,&lt;&lt;something else unique&gt;&gt;,SimpleEvent)
</code></pre><h3 id="registereventid"><strong>REGISTER_EVENT_ID</strong></h3>
<p>This is a macro that lets the <strong>UEQ</strong> know how to use your event by providing the information needed to associate your event with <strong>EventHandlers</strong>.  The first two parameters should be two separate, unique values.  The values must be literal unsigned 64-bit values (IE: use the &quot;ULL&quot; suffix).  These values separate an event from all other events, even others used by Unity or other plugins.  If you use a value that is shared with another event, <strong>EventHandlers</strong> will receive multiple event types.</p>
<h3 id="event-type-guidelines">Event Type Guidelines</h3>
<p>There are a few rules you must follow when creating an event&#39;s type.</p>
<ul>
<li>Events must be POD types.  Constructors and destructors will not be called, ergo events cannot be used to handle allocations or reference counted resources.</li>
<li>The <strong>UEQ</strong> is a finite size, and because of this it is advised that you keep your events small.  Any event that is more than 512 bytes in size will result in undefined behavior.</li>
</ul>
<h2 id="eventhandler">EventHandler</h2>
<p>An <strong>EventHandler</strong> takes care of processing events.  It is stored in the <strong>UEQ</strong> and handed the event that the handler is associated with.  There can be multiple handlers for a single event.  It is also possible to have a handler process multiple events, and this is best done by using the <strong>ClassBasedEventHandler</strong> or the <strong>StaticFunctionEventHandler</strong>.  </p>
<p>The <strong>UEQ</strong> processes all queued events each frame.  This normally occurs at the end of the frame, but this is guaranteed.  To prevent deadlocks, the queue may be processed immediately when it becomes full.  Because of this, your handler should not expect to be invoked at a certain point within your games frame.</p>
<pre><code>class EventHandler
{
public:
    virtual void HandleEvent ( EventId &amp; id, void * data );
    virtual EventId HandlerEventId();
};
</code></pre><h3 id="handleevent">HandleEvent</h3>
<p>This is where you will add logic to process the event.  When the desired event type is found in the <strong>UEQ</strong>, <strong>HandleEvent</strong> will be called on Unity&#39;s main thread.  It will be given the EventId along with the event.  The event must be cast back to the appropriate type.  </p>
<h2 id="eventhandler-utilities">EventHandler Utilities</h2>
<p>There are a few utilities available that help create new handlers or adapt existing code to use events.</p>
<h3 id="classbasedeventhandler"><strong>ClassBasedEventHandler</strong></h3>
<p>This class template implements the boiler plate code needed to have an <strong>EventHandler</strong> and forwards processing to a type you specify.  This can be a useful tool if you want to make an existing class an <strong>EventHandler</strong>.</p>
<pre><code>template&lt; typename EVENTTYPE, typename OBJECTTYPE &gt;
 class ClassBasedEventHandler : public EventHandler 
 {
    ClassBasedEventHandler( OBJECTTYPE * handler = NULL );

    ClassBasedEventHandler&lt;EVENTTYPE,OBJECTTYPE&gt; * 
        SetObject( OBJECTTYPE * handler );
 };
</code></pre><p><strong>EVENTTYPE</strong> is the type of your event object, and <strong>OBJECTTYPE</strong> is the type of your underlying handler object.  Create a <strong>ClassBasedEventHandler</strong> instance with a proper underlying handler object, and pass the <strong>ClassBasedEventHandler</strong> instance to the <strong>IEventQueue-&gt;AddHandler</strong> function.</p>
<p>The underlying handler object must provide a <strong>HandleEvent</strong> function like the standard <strong>Handler</strong>, but there are notable differences in the function signature.  It need not be virtual, the EventId is not passed as a parameter, and the event parameter is typed as a reference to the event type rather than a **void ***.  Because the event parameter is typed more strongly than with the <strong>EventHandler</strong> class, you can use the <strong>ClassBasedEventHandler</strong> along with function overloading to make the same class handle multiple events.</p>
<pre><code>class SomeClass
{
public:
    void HandleEvent ( SpecificEvent &amp; data ) { }
};
</code></pre><h3 id="staticfunctioneventhandler"><strong>StaticFunctionEventHandler</strong></h3>
<p>This class template implements the boiler plate code needed to have an <strong>EventHandler</strong> and forwards processing to a static function that you specify.  This can be a useful tool if you want to make an existing function an <strong>EventHandler</strong>.</p>
<pre><code>template&lt; typename EVENTTYPE &gt;
 class StaticFunctionEventHandler : public EventHandler
 {
 public:
    typedef void (*HandlerFunction)(const EVENTTYPE &amp; payload);

    StaticFunctionEventHandler( HandlerFunction handlerCallback );
 };
</code></pre><p><strong>EVENTTYPE</strong> is the type of your event object.  Create a <strong>ClassBasedEventHandler</strong> instance with proper handling function, and pass the <strong>ClassBasedEventHandler</strong> instance to the <strong>IEventQueue::AddHandler</strong> function.</p>
<p>Your function must have the same signature as the <strong>StaticFunctionEventHandler::HandlerFunction</strong> typedef. Because the event parameter is typed more strongly than with the <strong>EventHandler</strong> class, you can use the <strong>StaticFunctionEventHandler</strong> along with function overloading to use several functions of the same name handle different events.</p>
<h3 id="addeventhandler-event"><strong>AddEventHandler</strong> Event</h3>
<p>This event can be used to safely add a new event handler from a worker thread.  Create an instance of this event and set it with the correct <strong>EventHandler</strong>, then pass it to <strong>IEventQueue::SendEvent</strong> function.</p>
<pre><code>struct AddEventHandler
{
    AddEventHandler( EventHandler * handler ) : m_Handler(handler) {}
    EventHandler * m_Handler;
};
</code></pre><h3 id="removeeventhandler-event"><strong>RemoveEventHandler</strong> Event</h3>
<p>This event can be used to safely remove an existing event handler from a worker thread.  Create an instance of this event and set it with the correct <strong>EventHandler</strong>, then pass it to <strong>IEventQueue::SendEvent</strong> function.</p>
<pre><code>struct RemoveEventHandler
{
    RemoveEventHandler( EventHandler * handler ) : m_Handler(handler) {}
    EventHandler * m_Handler;
};
</code></pre><h2 id="unityseteventqueue">UnitySetEventQueue</h2>
<p>To get a proper reference to the <strong>UEQ</strong>, a native plugin must export a function named <em>UnitySetEventQueue</em>.  This function will get called by Unity when the plugin is loaded.  It must have the function signature shown below.  It takes in one parameter which will be a pointer to the <strong>UEQ</strong>.  </p>
<pre><code>UnityEventQueue::IEventQueue * g_internalQueue;
DLL_EXPORT void UnitySetEventQueue(void * queue)
{
  internalQueue = (UnityEventQueue::IEventQueue*)queue;

}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2019 Unity Technologies<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
